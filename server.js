import { createRequire } from "node:module";
var __create = Object.create;
var {
	getPrototypeOf: __getProtoOf,
	defineProperty: __defProp,
	getOwnPropertyNames: __getOwnPropNames,
} = Object;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
	target = mod != null ? __create(__getProtoOf(mod)) : {};
	let to =
		isNodeMode || !mod || !mod.__esModule
			? __defProp(target, "default", { value: mod, enumerable: !0 })
			: target;
	for (let key of __getOwnPropNames(mod))
		if (!__hasOwnProp.call(to, key))
			__defProp(to, key, { get: () => mod[key], enumerable: !0 });
	return to;
};
var __commonJS = (cb, mod) => () => (
	mod || cb((mod = { exports: {} }).exports, mod), mod.exports
);
var __export = (target, all) => {
	for (var name in all)
		__defProp(target, name, {
			get: all[name],
			enumerable: !0,
			configurable: !0,
			set: (newValue) => (all[name] = () => newValue),
		});
};
var __require = createRequire(import.meta.url);
var require_dist = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.parse = parse2;
	exports.serialize = serialize;
	var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
		cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/,
		domainValueRegExp =
			/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/,
		__toString = Object.prototype.toString,
		NullObject = (() => {
			let C = function () {};
			return (C.prototype = Object.create(null)), C;
		})();
	function parse2(str, options) {
		let obj = new NullObject(),
			len = str.length;
		if (len < 2) return obj;
		let dec = options?.decode || decode2,
			index = 0;
		do {
			let eqIdx = str.indexOf("=", index);
			if (eqIdx === -1) break;
			let colonIdx = str.indexOf(";", index),
				endIdx = colonIdx === -1 ? len : colonIdx;
			if (eqIdx > endIdx) {
				index = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			let keyStartIdx = startIndex(str, index, eqIdx),
				keyEndIdx = endIndex(str, eqIdx, keyStartIdx),
				key = str.slice(keyStartIdx, keyEndIdx);
			if (obj[key] === void 0) {
				let valStartIdx = startIndex(str, eqIdx + 1, endIdx),
					valEndIdx = endIndex(str, endIdx, valStartIdx),
					value = dec(str.slice(valStartIdx, valEndIdx));
				obj[key] = value;
			}
			index = endIdx + 1;
		} while (index < len);
		return obj;
	}
	function startIndex(str, index, max) {
		do {
			let code = str.charCodeAt(index);
			if (code !== 32 && code !== 9) return index;
		} while (++index < max);
		return max;
	}
	function endIndex(str, index, min) {
		while (index > min) {
			let code = str.charCodeAt(--index);
			if (code !== 32 && code !== 9) return index + 1;
		}
		return min;
	}
	function serialize(name, val, options) {
		let enc = options?.encode || encodeURIComponent;
		if (!cookieNameRegExp.test(name))
			throw new TypeError(`argument name is invalid: ${name}`);
		let value = enc(val);
		if (!cookieValueRegExp.test(value))
			throw new TypeError(`argument val is invalid: ${val}`);
		let str = name + "=" + value;
		if (!options) return str;
		if (options.maxAge !== void 0) {
			if (!Number.isInteger(options.maxAge))
				throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
			str += "; Max-Age=" + options.maxAge;
		}
		if (options.domain) {
			if (!domainValueRegExp.test(options.domain))
				throw new TypeError(`option domain is invalid: ${options.domain}`);
			str += "; Domain=" + options.domain;
		}
		if (options.path) {
			if (!pathValueRegExp.test(options.path))
				throw new TypeError(`option path is invalid: ${options.path}`);
			str += "; Path=" + options.path;
		}
		if (options.expires) {
			if (
				!isDate(options.expires) ||
				!Number.isFinite(options.expires.valueOf())
			)
				throw new TypeError(`option expires is invalid: ${options.expires}`);
			str += "; Expires=" + options.expires.toUTCString();
		}
		if (options.httpOnly) str += "; HttpOnly";
		if (options.secure) str += "; Secure";
		if (options.partitioned) str += "; Partitioned";
		if (options.priority)
			switch (
				typeof options.priority === "string"
					? options.priority.toLowerCase()
					: void 0
			) {
				case "low":
					str += "; Priority=Low";
					break;
				case "medium":
					str += "; Priority=Medium";
					break;
				case "high":
					str += "; Priority=High";
					break;
				default:
					throw new TypeError(
						`option priority is invalid: ${options.priority}`,
					);
			}
		if (options.sameSite)
			switch (
				typeof options.sameSite === "string"
					? options.sameSite.toLowerCase()
					: options.sameSite
			) {
				case !0:
				case "strict":
					str += "; SameSite=Strict";
					break;
				case "lax":
					str += "; SameSite=Lax";
					break;
				case "none":
					str += "; SameSite=None";
					break;
				default:
					throw new TypeError(
						`option sameSite is invalid: ${options.sameSite}`,
					);
			}
		return str;
	}
	function decode2(str) {
		if (str.indexOf("%") === -1) return str;
		try {
			return decodeURIComponent(str);
		} catch (e) {
			return str;
		}
	}
	function isDate(val) {
		return __toString.call(val) === "[object Date]";
	}
});
var require_constants = __commonJS((exports, module) => {
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
		RELEASE_TYPES = [
			"major",
			"premajor",
			"minor",
			"preminor",
			"patch",
			"prepatch",
			"prerelease",
		];
	module.exports = {
		MAX_LENGTH: 256,
		MAX_SAFE_COMPONENT_LENGTH: 16,
		MAX_SAFE_BUILD_LENGTH: 250,
		MAX_SAFE_INTEGER,
		RELEASE_TYPES,
		SEMVER_SPEC_VERSION: "2.0.0",
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2,
	};
});
var require_debug = __commonJS((exports, module) => {
	var debug =
		typeof process === "object" &&
		process.env &&
		process.env.NODE_DEBUG &&
		/\bsemver\b/i.test(process.env.NODE_DEBUG)
			? (...args) => console.error("SEMVER", ...args)
			: () => {};
	module.exports = debug;
});
var require_re = __commonJS((exports, module) => {
	var { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } =
			require_constants(),
		debug = require_debug();
	exports = module.exports = {};
	var re = (exports.re = []),
		safeRe = (exports.safeRe = []),
		src = (exports.src = []),
		safeSrc = (exports.safeSrc = []),
		t2 = (exports.t = {}),
		R = 0,
		LETTERDASHNUMBER = "[a-zA-Z0-9-]",
		safeRegexReplacements = [
			["\\s", 1],
			["\\d", MAX_LENGTH],
			[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		],
		makeSafeRegex = (value) => {
			for (let [token, max] of safeRegexReplacements)
				value = value
					.split(`${token}*`)
					.join(`${token}{0,${max}}`)
					.split(`${token}+`)
					.join(`${token}{1,${max}}`);
			return value;
		},
		createToken = (name, value, isGlobal) => {
			let safe = makeSafeRegex(value),
				index = R++;
			debug(name, index, value),
				(t2[name] = index),
				(src[index] = value),
				(safeSrc[index] = safe),
				(re[index] = new RegExp(value, isGlobal ? "g" : void 0)),
				(safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0));
		};
	createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
	createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
	createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
	createToken(
		"MAINVERSION",
		`(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`,
	);
	createToken(
		"MAINVERSIONLOOSE",
		`(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`,
	);
	createToken(
		"PRERELEASEIDENTIFIER",
		`(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`,
	);
	createToken(
		"PRERELEASEIDENTIFIERLOOSE",
		`(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`,
	);
	createToken(
		"PRERELEASE",
		`(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`,
	);
	createToken(
		"PRERELEASELOOSE",
		`(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`,
	);
	createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
	createToken(
		"BUILD",
		`(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`,
	);
	createToken(
		"FULLPLAIN",
		`v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`,
	);
	createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
	createToken(
		"LOOSEPLAIN",
		`[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`,
	);
	createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
	createToken("GTLT", "((?:<|>)?=?)");
	createToken(
		"XRANGEIDENTIFIERLOOSE",
		`${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`,
	);
	createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
	createToken(
		"XRANGEPLAIN",
		`[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`,
	);
	createToken(
		"XRANGEPLAINLOOSE",
		`[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`,
	);
	createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
	createToken(
		"XRANGELOOSE",
		`^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`,
	);
	createToken(
		"COERCEPLAIN",
		`(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`,
	);
	createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
	createToken(
		"COERCEFULL",
		src[t2.COERCEPLAIN] +
			`(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`,
	);
	createToken("COERCERTL", src[t2.COERCE], !0);
	createToken("COERCERTLFULL", src[t2.COERCEFULL], !0);
	createToken("LONETILDE", "(?:~>?)");
	createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, !0);
	exports.tildeTrimReplace = "$1~";
	createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
	createToken(
		"TILDELOOSE",
		`^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`,
	);
	createToken("LONECARET", "(?:\\^)");
	createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, !0);
	exports.caretTrimReplace = "$1^";
	createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
	createToken(
		"CARETLOOSE",
		`^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`,
	);
	createToken(
		"COMPARATORLOOSE",
		`^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`,
	);
	createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
	createToken(
		"COMPARATORTRIM",
		`(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`,
		!0,
	);
	exports.comparatorTrimReplace = "$1$2$3";
	createToken(
		"HYPHENRANGE",
		`^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`,
	);
	createToken(
		"HYPHENRANGELOOSE",
		`^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`,
	);
	createToken("STAR", "(<|>)?=?\\s*\\*");
	createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
	createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var require_parse_options = __commonJS((exports, module) => {
	var looseOption = Object.freeze({ loose: !0 }),
		emptyOpts = Object.freeze({}),
		parseOptions = (options) => {
			if (!options) return emptyOpts;
			if (typeof options !== "object") return looseOption;
			return options;
		};
	module.exports = parseOptions;
});
var require_identifiers = __commonJS((exports, module) => {
	var numeric = /^[0-9]+$/,
		compareIdentifiers = (a, b) => {
			let anum = numeric.test(a),
				bnum = numeric.test(b);
			if (anum && bnum) (a = +a), (b = +b);
			return a === b
				? 0
				: anum && !bnum
					? -1
					: bnum && !anum
						? 1
						: a < b
							? -1
							: 1;
		},
		rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
	module.exports = { compareIdentifiers, rcompareIdentifiers };
});
var require_semver = __commonJS((exports, module) => {
	var debug = require_debug(),
		{ MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants(),
		{ safeRe: re, safeSrc: src, t: t2 } = require_re(),
		parseOptions = require_parse_options(),
		{ compareIdentifiers } = require_identifiers();
	class SemVer {
		constructor(version, options) {
			if (((options = parseOptions(options)), version instanceof SemVer))
				if (
					version.loose === !!options.loose &&
					version.includePrerelease === !!options.includePrerelease
				)
					return version;
				else version = version.version;
			else if (typeof version !== "string")
				throw new TypeError(
					`Invalid version. Must be a string. Got type "${typeof version}".`,
				);
			if (version.length > MAX_LENGTH)
				throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
			debug("SemVer", version, options),
				(this.options = options),
				(this.loose = !!options.loose),
				(this.includePrerelease = !!options.includePrerelease);
			let m = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
			if (!m) throw new TypeError(`Invalid Version: ${version}`);
			if (
				((this.raw = version),
				(this.major = +m[1]),
				(this.minor = +m[2]),
				(this.patch = +m[3]),
				this.major > MAX_SAFE_INTEGER || this.major < 0)
			)
				throw new TypeError("Invalid major version");
			if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
				throw new TypeError("Invalid minor version");
			if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
				throw new TypeError("Invalid patch version");
			if (!m[4]) this.prerelease = [];
			else
				this.prerelease = m[4].split(".").map((id) => {
					if (/^[0-9]+$/.test(id)) {
						let num = +id;
						if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
					}
					return id;
				});
			(this.build = m[5] ? m[5].split(".") : []), this.format();
		}
		format() {
			if (
				((this.version = `${this.major}.${this.minor}.${this.patch}`),
				this.prerelease.length)
			)
				this.version += `-${this.prerelease.join(".")}`;
			return this.version;
		}
		toString() {
			return this.version;
		}
		compare(other) {
			if (
				(debug("SemVer.compare", this.version, this.options, other),
				!(other instanceof SemVer))
			) {
				if (typeof other === "string" && other === this.version) return 0;
				other = new SemVer(other, this.options);
			}
			if (other.version === this.version) return 0;
			return this.compareMain(other) || this.comparePre(other);
		}
		compareMain(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			return (
				compareIdentifiers(this.major, other.major) ||
				compareIdentifiers(this.minor, other.minor) ||
				compareIdentifiers(this.patch, other.patch)
			);
		}
		comparePre(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			if (this.prerelease.length && !other.prerelease.length) return -1;
			else if (!this.prerelease.length && other.prerelease.length) return 1;
			else if (!this.prerelease.length && !other.prerelease.length) return 0;
			let i = 0;
			do {
				let a = this.prerelease[i],
					b = other.prerelease[i];
				if (
					(debug("prerelease compare", i, a, b), a === void 0 && b === void 0)
				)
					return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		compareBuild(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			let i = 0;
			do {
				let a = this.build[i],
					b = other.build[i];
				if ((debug("build compare", i, a, b), a === void 0 && b === void 0))
					return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		inc(release, identifier, identifierBase) {
			if (release.startsWith("pre")) {
				if (!identifier && identifierBase === !1)
					throw new Error("invalid increment argument: identifier is empty");
				if (identifier) {
					let r = new RegExp(
							`^${this.options.loose ? src[t2.PRERELEASELOOSE] : src[t2.PRERELEASE]}$`,
						),
						match = `-${identifier}`.match(r);
					if (!match || match[1] !== identifier)
						throw new Error(`invalid identifier: ${identifier}`);
				}
			}
			switch (release) {
				case "premajor":
					(this.prerelease.length = 0),
						(this.patch = 0),
						(this.minor = 0),
						this.major++,
						this.inc("pre", identifier, identifierBase);
					break;
				case "preminor":
					(this.prerelease.length = 0),
						(this.patch = 0),
						this.minor++,
						this.inc("pre", identifier, identifierBase);
					break;
				case "prepatch":
					(this.prerelease.length = 0),
						this.inc("patch", identifier, identifierBase),
						this.inc("pre", identifier, identifierBase);
					break;
				case "prerelease":
					if (this.prerelease.length === 0)
						this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "release":
					if (this.prerelease.length === 0)
						throw new Error(`version ${this.raw} is not a prerelease`);
					this.prerelease.length = 0;
					break;
				case "major":
					if (
						this.minor !== 0 ||
						this.patch !== 0 ||
						this.prerelease.length === 0
					)
						this.major++;
					(this.minor = 0), (this.patch = 0), (this.prerelease = []);
					break;
				case "minor":
					if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
					(this.patch = 0), (this.prerelease = []);
					break;
				case "patch":
					if (this.prerelease.length === 0) this.patch++;
					this.prerelease = [];
					break;
				case "pre": {
					let base = Number(identifierBase) ? 1 : 0;
					if (this.prerelease.length === 0) this.prerelease = [base];
					else {
						let i = this.prerelease.length;
						while (--i >= 0)
							if (typeof this.prerelease[i] === "number")
								this.prerelease[i]++, (i = -2);
						if (i === -1) {
							if (
								identifier === this.prerelease.join(".") &&
								identifierBase === !1
							)
								throw new Error(
									"invalid increment argument: identifier already exists",
								);
							this.prerelease.push(base);
						}
					}
					if (identifier) {
						let prerelease = [identifier, base];
						if (identifierBase === !1) prerelease = [identifier];
						if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
							if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
						} else this.prerelease = prerelease;
					}
					break;
				}
				default:
					throw new Error(`invalid increment argument: ${release}`);
			}
			if (((this.raw = this.format()), this.build.length))
				this.raw += `+${this.build.join(".")}`;
			return this;
		}
	}
	module.exports = SemVer;
});
var require_parse = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		parse3 = (version, options, throwErrors = !1) => {
			if (version instanceof SemVer) return version;
			try {
				return new SemVer(version, options);
			} catch (er) {
				if (!throwErrors) return null;
				throw er;
			}
		};
	module.exports = parse3;
});
var require_valid = __commonJS((exports, module) => {
	var parse3 = require_parse(),
		valid = (version, options) => {
			let v = parse3(version, options);
			return v ? v.version : null;
		};
	module.exports = valid;
});
var require_clean = __commonJS((exports, module) => {
	var parse3 = require_parse(),
		clean2 = (version, options) => {
			let s = parse3(version.trim().replace(/^[=v]+/, ""), options);
			return s ? s.version : null;
		};
	module.exports = clean2;
});
var require_inc = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		inc = (version, release, options, identifier, identifierBase) => {
			if (typeof options === "string")
				(identifierBase = identifier),
					(identifier = options),
					(options = void 0);
			try {
				return new SemVer(
					version instanceof SemVer ? version.version : version,
					options,
				).inc(release, identifier, identifierBase).version;
			} catch (er) {
				return null;
			}
		};
	module.exports = inc;
});
var require_diff = __commonJS((exports, module) => {
	var parse3 = require_parse(),
		diff = (version1, version2) => {
			let v1 = parse3(version1, null, !0),
				v2 = parse3(version2, null, !0),
				comparison = v1.compare(v2);
			if (comparison === 0) return null;
			let v1Higher = comparison > 0,
				highVersion = v1Higher ? v1 : v2,
				lowVersion = v1Higher ? v2 : v1,
				highHasPre = !!highVersion.prerelease.length;
			if (!!lowVersion.prerelease.length && !highHasPre) {
				if (!lowVersion.patch && !lowVersion.minor) return "major";
				if (lowVersion.compareMain(highVersion) === 0) {
					if (lowVersion.minor && !lowVersion.patch) return "minor";
					return "patch";
				}
			}
			let prefix = highHasPre ? "pre" : "";
			if (v1.major !== v2.major) return prefix + "major";
			if (v1.minor !== v2.minor) return prefix + "minor";
			if (v1.patch !== v2.patch) return prefix + "patch";
			return "prerelease";
		};
	module.exports = diff;
});
var require_major = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		major = (a, loose) => new SemVer(a, loose).major;
	module.exports = major;
});
var require_minor = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		minor = (a, loose) => new SemVer(a, loose).minor;
	module.exports = minor;
});
var require_patch = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		patch = (a, loose) => new SemVer(a, loose).patch;
	module.exports = patch;
});
var require_prerelease = __commonJS((exports, module) => {
	var parse3 = require_parse(),
		prerelease = (version, options) => {
			let parsed = parse3(version, options);
			return parsed && parsed.prerelease.length ? parsed.prerelease : null;
		};
	module.exports = prerelease;
});
var require_compare = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		compare = (a, b, loose) =>
			new SemVer(a, loose).compare(new SemVer(b, loose));
	module.exports = compare;
});
var require_rcompare = __commonJS((exports, module) => {
	var compare = require_compare(),
		rcompare = (a, b, loose) => compare(b, a, loose);
	module.exports = rcompare;
});
var require_compare_loose = __commonJS((exports, module) => {
	var compare = require_compare(),
		compareLoose = (a, b) => compare(a, b, !0);
	module.exports = compareLoose;
});
var require_compare_build = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		compareBuild = (a, b, loose) => {
			let versionA = new SemVer(a, loose),
				versionB = new SemVer(b, loose);
			return versionA.compare(versionB) || versionA.compareBuild(versionB);
		};
	module.exports = compareBuild;
});
var require_sort = __commonJS((exports, module) => {
	var compareBuild = require_compare_build(),
		sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	module.exports = sort;
});
var require_rsort = __commonJS((exports, module) => {
	var compareBuild = require_compare_build(),
		rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	module.exports = rsort;
});
var require_gt = __commonJS((exports, module) => {
	var compare = require_compare(),
		gt = (a, b, loose) => compare(a, b, loose) > 0;
	module.exports = gt;
});
var require_lt = __commonJS((exports, module) => {
	var compare = require_compare(),
		lt = (a, b, loose) => compare(a, b, loose) < 0;
	module.exports = lt;
});
var require_eq = __commonJS((exports, module) => {
	var compare = require_compare(),
		eq = (a, b, loose) => compare(a, b, loose) === 0;
	module.exports = eq;
});
var require_neq = __commonJS((exports, module) => {
	var compare = require_compare(),
		neq = (a, b, loose) => compare(a, b, loose) !== 0;
	module.exports = neq;
});
var require_gte = __commonJS((exports, module) => {
	var compare = require_compare(),
		gte = (a, b, loose) => compare(a, b, loose) >= 0;
	module.exports = gte;
});
var require_lte = __commonJS((exports, module) => {
	var compare = require_compare(),
		lte = (a, b, loose) => compare(a, b, loose) <= 0;
	module.exports = lte;
});
var require_cmp = __commonJS((exports, module) => {
	var eq = require_eq(),
		neq = require_neq(),
		gt = require_gt(),
		gte = require_gte(),
		lt = require_lt(),
		lte = require_lte(),
		cmp = (a, op, b, loose) => {
			switch (op) {
				case "===":
					if (typeof a === "object") a = a.version;
					if (typeof b === "object") b = b.version;
					return a === b;
				case "!==":
					if (typeof a === "object") a = a.version;
					if (typeof b === "object") b = b.version;
					return a !== b;
				case "":
				case "=":
				case "==":
					return eq(a, b, loose);
				case "!=":
					return neq(a, b, loose);
				case ">":
					return gt(a, b, loose);
				case ">=":
					return gte(a, b, loose);
				case "<":
					return lt(a, b, loose);
				case "<=":
					return lte(a, b, loose);
				default:
					throw new TypeError(`Invalid operator: ${op}`);
			}
		};
	module.exports = cmp;
});
var require_coerce = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		parse3 = require_parse(),
		{ safeRe: re, t: t2 } = require_re(),
		coerce = (version, options) => {
			if (version instanceof SemVer) return version;
			if (typeof version === "number") version = String(version);
			if (typeof version !== "string") return null;
			options = options || {};
			let match = null;
			if (!options.rtl)
				match = version.match(
					options.includePrerelease ? re[t2.COERCEFULL] : re[t2.COERCE],
				);
			else {
				let coerceRtlRegex = options.includePrerelease
						? re[t2.COERCERTLFULL]
						: re[t2.COERCERTL],
					next2;
				while (
					(next2 = coerceRtlRegex.exec(version)) &&
					(!match || match.index + match[0].length !== version.length)
				) {
					if (
						!match ||
						next2.index + next2[0].length !== match.index + match[0].length
					)
						match = next2;
					coerceRtlRegex.lastIndex =
						next2.index + next2[1].length + next2[2].length;
				}
				coerceRtlRegex.lastIndex = -1;
			}
			if (match === null) return null;
			let major = match[2],
				minor = match[3] || "0",
				patch = match[4] || "0",
				prerelease =
					options.includePrerelease && match[5] ? `-${match[5]}` : "",
				build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
			return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
		};
	module.exports = coerce;
});
var require_lrucache = __commonJS((exports, module) => {
	class LRUCache {
		constructor() {
			(this.max = 1000), (this.map = new Map());
		}
		get(key) {
			let value = this.map.get(key);
			if (value === void 0) return;
			else return this.map.delete(key), this.map.set(key, value), value;
		}
		delete(key) {
			return this.map.delete(key);
		}
		set(key, value) {
			if (!this.delete(key) && value !== void 0) {
				if (this.map.size >= this.max) {
					let firstKey = this.map.keys().next().value;
					this.delete(firstKey);
				}
				this.map.set(key, value);
			}
			return this;
		}
	}
	module.exports = LRUCache;
});
var require_range = __commonJS((exports, module) => {
	var SPACE_CHARACTERS = /\s+/g;
	class Range {
		constructor(range, options) {
			if (((options = parseOptions(options)), range instanceof Range))
				if (
					range.loose === !!options.loose &&
					range.includePrerelease === !!options.includePrerelease
				)
					return range;
				else return new Range(range.raw, options);
			if (range instanceof Comparator)
				return (
					(this.raw = range.value),
					(this.set = [[range]]),
					(this.formatted = void 0),
					this
				);
			if (
				((this.options = options),
				(this.loose = !!options.loose),
				(this.includePrerelease = !!options.includePrerelease),
				(this.raw = range.trim().replace(SPACE_CHARACTERS, " ")),
				(this.set = this.raw
					.split("||")
					.map((r) => this.parseRange(r.trim()))
					.filter((c) => c.length)),
				!this.set.length)
			)
				throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
			if (this.set.length > 1) {
				let first = this.set[0];
				if (
					((this.set = this.set.filter((c) => !isNullSet(c[0]))),
					this.set.length === 0)
				)
					this.set = [first];
				else if (this.set.length > 1) {
					for (let c of this.set)
						if (c.length === 1 && isAny(c[0])) {
							this.set = [c];
							break;
						}
				}
			}
			this.formatted = void 0;
		}
		get range() {
			if (this.formatted === void 0) {
				this.formatted = "";
				for (let i = 0; i < this.set.length; i++) {
					if (i > 0) this.formatted += "||";
					let comps = this.set[i];
					for (let k = 0; k < comps.length; k++) {
						if (k > 0) this.formatted += " ";
						this.formatted += comps[k].toString().trim();
					}
				}
			}
			return this.formatted;
		}
		format() {
			return this.range;
		}
		toString() {
			return this.range;
		}
		parseRange(range) {
			let memoKey =
					((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
						(this.options.loose && FLAG_LOOSE)) +
					":" +
					range,
				cached = cache.get(memoKey);
			if (cached) return cached;
			let loose = this.options.loose,
				hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
			(range = range.replace(
				hr,
				hyphenReplace(this.options.includePrerelease),
			)),
				debug("hyphen replace", range),
				(range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace)),
				debug("comparator trim", range),
				(range = range.replace(re[t2.TILDETRIM], tildeTrimReplace)),
				debug("tilde trim", range),
				(range = range.replace(re[t2.CARETTRIM], caretTrimReplace)),
				debug("caret trim", range);
			let rangeList = range
				.split(" ")
				.map((comp) => parseComparator(comp, this.options))
				.join(" ")
				.split(/\s+/)
				.map((comp) => replaceGTE0(comp, this.options));
			if (loose)
				rangeList = rangeList.filter((comp) => {
					return (
						debug("loose invalid filter", comp, this.options),
						!!comp.match(re[t2.COMPARATORLOOSE])
					);
				});
			debug("range list", rangeList);
			let rangeMap = new Map(),
				comparators = rangeList.map(
					(comp) => new Comparator(comp, this.options),
				);
			for (let comp of comparators) {
				if (isNullSet(comp)) return [comp];
				rangeMap.set(comp.value, comp);
			}
			if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
			let result = [...rangeMap.values()];
			return cache.set(memoKey, result), result;
		}
		intersects(range, options) {
			if (!(range instanceof Range)) throw new TypeError("a Range is required");
			return this.set.some((thisComparators) => {
				return (
					isSatisfiable(thisComparators, options) &&
					range.set.some((rangeComparators) => {
						return (
							isSatisfiable(rangeComparators, options) &&
							thisComparators.every((thisComparator) => {
								return rangeComparators.every((rangeComparator) => {
									return thisComparator.intersects(rangeComparator, options);
								});
							})
						);
					})
				);
			});
		}
		test(version) {
			if (!version) return !1;
			if (typeof version === "string")
				try {
					version = new SemVer(version, this.options);
				} catch (er) {
					return !1;
				}
			for (let i = 0; i < this.set.length; i++)
				if (testSet(this.set[i], version, this.options)) return !0;
			return !1;
		}
	}
	module.exports = Range;
	var LRU = require_lrucache(),
		cache = new LRU(),
		parseOptions = require_parse_options(),
		Comparator = require_comparator(),
		debug = require_debug(),
		SemVer = require_semver(),
		{
			safeRe: re,
			t: t2,
			comparatorTrimReplace,
			tildeTrimReplace,
			caretTrimReplace,
		} = require_re(),
		{ FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants(),
		isNullSet = (c) => c.value === "<0.0.0-0",
		isAny = (c) => c.value === "",
		isSatisfiable = (comparators, options) => {
			let result = !0,
				remainingComparators = comparators.slice(),
				testComparator = remainingComparators.pop();
			while (result && remainingComparators.length)
				(result = remainingComparators.every((otherComparator) => {
					return testComparator.intersects(otherComparator, options);
				})),
					(testComparator = remainingComparators.pop());
			return result;
		},
		parseComparator = (comp, options) => {
			return (
				debug("comp", comp, options),
				(comp = replaceCarets(comp, options)),
				debug("caret", comp),
				(comp = replaceTildes(comp, options)),
				debug("tildes", comp),
				(comp = replaceXRanges(comp, options)),
				debug("xrange", comp),
				(comp = replaceStars(comp, options)),
				debug("stars", comp),
				comp
			);
		},
		isX = (id) => !id || id.toLowerCase() === "x" || id === "*",
		replaceTildes = (comp, options) => {
			return comp
				.trim()
				.split(/\s+/)
				.map((c) => replaceTilde(c, options))
				.join(" ");
		},
		replaceTilde = (comp, options) => {
			let r = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
			return comp.replace(r, (_, M, m, p, pr) => {
				debug("tilde", comp, _, M, m, p, pr);
				let ret;
				if (isX(M)) ret = "";
				else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
				else if (isX(p)) ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
				else if (pr)
					debug("replaceTilde pr", pr),
						(ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`);
				else ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
				return debug("tilde return", ret), ret;
			});
		},
		replaceCarets = (comp, options) => {
			return comp
				.trim()
				.split(/\s+/)
				.map((c) => replaceCaret(c, options))
				.join(" ");
		},
		replaceCaret = (comp, options) => {
			debug("caret", comp, options);
			let r = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET],
				z = options.includePrerelease ? "-0" : "";
			return comp.replace(r, (_, M, m, p, pr) => {
				debug("caret", comp, _, M, m, p, pr);
				let ret;
				if (isX(M)) ret = "";
				else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
				else if (isX(p))
					if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
					else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
				else if (pr)
					if ((debug("replaceCaret pr", pr), M === "0"))
						if (m === "0")
							ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
						else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
					else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
				else if ((debug("no pr"), M === "0"))
					if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
					else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
				else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
				return debug("caret return", ret), ret;
			});
		},
		replaceXRanges = (comp, options) => {
			return (
				debug("replaceXRanges", comp, options),
				comp
					.split(/\s+/)
					.map((c) => replaceXRange(c, options))
					.join(" ")
			);
		},
		replaceXRange = (comp, options) => {
			comp = comp.trim();
			let r = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
			return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
				debug("xRange", comp, ret, gtlt, M, m, p, pr);
				let xM = isX(M),
					xm = xM || isX(m),
					xp = xm || isX(p),
					anyX = xp;
				if (gtlt === "=" && anyX) gtlt = "";
				if (((pr = options.includePrerelease ? "-0" : ""), xM))
					if (gtlt === ">" || gtlt === "<") ret = "<0.0.0-0";
					else ret = "*";
				else if (gtlt && anyX) {
					if (xm) m = 0;
					if (((p = 0), gtlt === ">"))
						if (((gtlt = ">="), xm)) (M = +M + 1), (m = 0), (p = 0);
						else (m = +m + 1), (p = 0);
					else if (gtlt === "<=")
						if (((gtlt = "<"), xm)) M = +M + 1;
						else m = +m + 1;
					if (gtlt === "<") pr = "-0";
					ret = `${gtlt + M}.${m}.${p}${pr}`;
				} else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
				else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
				return debug("xRange return", ret), ret;
			});
		},
		replaceStars = (comp, options) => {
			return (
				debug("replaceStars", comp, options),
				comp.trim().replace(re[t2.STAR], "")
			);
		},
		replaceGTE0 = (comp, options) => {
			return (
				debug("replaceGTE0", comp, options),
				comp
					.trim()
					.replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "")
			);
		},
		hyphenReplace =
			(incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
				if (isX(fM)) from = "";
				else if (isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
				else if (isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
				else if (fpr) from = `>=${from}`;
				else from = `>=${from}${incPr ? "-0" : ""}`;
				if (isX(tM)) to = "";
				else if (isX(tm)) to = `<${+tM + 1}.0.0-0`;
				else if (isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
				else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
				else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
				else to = `<=${to}`;
				return `${from} ${to}`.trim();
			},
		testSet = (set2, version, options) => {
			for (let i = 0; i < set2.length; i++)
				if (!set2[i].test(version)) return !1;
			if (version.prerelease.length && !options.includePrerelease) {
				for (let i = 0; i < set2.length; i++) {
					if ((debug(set2[i].semver), set2[i].semver === Comparator.ANY))
						continue;
					if (set2[i].semver.prerelease.length > 0) {
						let allowed = set2[i].semver;
						if (
							allowed.major === version.major &&
							allowed.minor === version.minor &&
							allowed.patch === version.patch
						)
							return !0;
					}
				}
				return !1;
			}
			return !0;
		};
});
var require_comparator = __commonJS((exports, module) => {
	var ANY = Symbol("SemVer ANY");
	class Comparator {
		static get ANY() {
			return ANY;
		}
		constructor(comp, options) {
			if (((options = parseOptions(options)), comp instanceof Comparator))
				if (comp.loose === !!options.loose) return comp;
				else comp = comp.value;
			if (
				((comp = comp.trim().split(/\s+/).join(" ")),
				debug("comparator", comp, options),
				(this.options = options),
				(this.loose = !!options.loose),
				this.parse(comp),
				this.semver === ANY)
			)
				this.value = "";
			else this.value = this.operator + this.semver.version;
			debug("comp", this);
		}
		parse(comp) {
			let r = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR],
				m = comp.match(r);
			if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
			if (
				((this.operator = m[1] !== void 0 ? m[1] : ""), this.operator === "=")
			)
				this.operator = "";
			if (!m[2]) this.semver = ANY;
			else this.semver = new SemVer(m[2], this.options.loose);
		}
		toString() {
			return this.value;
		}
		test(version) {
			if (
				(debug("Comparator.test", version, this.options.loose),
				this.semver === ANY || version === ANY)
			)
				return !0;
			if (typeof version === "string")
				try {
					version = new SemVer(version, this.options);
				} catch (er) {
					return !1;
				}
			return cmp(version, this.operator, this.semver, this.options);
		}
		intersects(comp, options) {
			if (!(comp instanceof Comparator))
				throw new TypeError("a Comparator is required");
			if (this.operator === "") {
				if (this.value === "") return !0;
				return new Range(comp.value, options).test(this.value);
			} else if (comp.operator === "") {
				if (comp.value === "") return !0;
				return new Range(this.value, options).test(comp.semver);
			}
			if (
				((options = parseOptions(options)),
				options.includePrerelease &&
					(this.value === "<0.0.0-0" || comp.value === "<0.0.0-0"))
			)
				return !1;
			if (
				!options.includePrerelease &&
				(this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))
			)
				return !1;
			if (this.operator.startsWith(">") && comp.operator.startsWith(">"))
				return !0;
			if (this.operator.startsWith("<") && comp.operator.startsWith("<"))
				return !0;
			if (
				this.semver.version === comp.semver.version &&
				this.operator.includes("=") &&
				comp.operator.includes("=")
			)
				return !0;
			if (
				cmp(this.semver, "<", comp.semver, options) &&
				this.operator.startsWith(">") &&
				comp.operator.startsWith("<")
			)
				return !0;
			if (
				cmp(this.semver, ">", comp.semver, options) &&
				this.operator.startsWith("<") &&
				comp.operator.startsWith(">")
			)
				return !0;
			return !1;
		}
	}
	module.exports = Comparator;
	var parseOptions = require_parse_options(),
		{ safeRe: re, t: t2 } = require_re(),
		cmp = require_cmp(),
		debug = require_debug(),
		SemVer = require_semver(),
		Range = require_range();
});
var require_satisfies = __commonJS((exports, module) => {
	var Range = require_range(),
		satisfies = (version, range, options) => {
			try {
				range = new Range(range, options);
			} catch (er) {
				return !1;
			}
			return range.test(version);
		};
	module.exports = satisfies;
});
var require_to_comparators = __commonJS((exports, module) => {
	var Range = require_range(),
		toComparators = (range, options) =>
			new Range(range, options).set.map((comp) =>
				comp
					.map((c) => c.value)
					.join(" ")
					.trim()
					.split(" "),
			);
	module.exports = toComparators;
});
var require_max_satisfying = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		Range = require_range(),
		maxSatisfying = (versions, range, options) => {
			let max = null,
				maxSV = null,
				rangeObj = null;
			try {
				rangeObj = new Range(range, options);
			} catch (er) {
				return null;
			}
			return (
				versions.forEach((v) => {
					if (rangeObj.test(v)) {
						if (!max || maxSV.compare(v) === -1)
							(max = v), (maxSV = new SemVer(max, options));
					}
				}),
				max
			);
		};
	module.exports = maxSatisfying;
});
var require_min_satisfying = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		Range = require_range(),
		minSatisfying = (versions, range, options) => {
			let min = null,
				minSV = null,
				rangeObj = null;
			try {
				rangeObj = new Range(range, options);
			} catch (er) {
				return null;
			}
			return (
				versions.forEach((v) => {
					if (rangeObj.test(v)) {
						if (!min || minSV.compare(v) === 1)
							(min = v), (minSV = new SemVer(min, options));
					}
				}),
				min
			);
		};
	module.exports = minSatisfying;
});
var require_min_version = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		Range = require_range(),
		gt = require_gt(),
		minVersion = (range, loose) => {
			range = new Range(range, loose);
			let minver = new SemVer("0.0.0");
			if (range.test(minver)) return minver;
			if (((minver = new SemVer("0.0.0-0")), range.test(minver))) return minver;
			minver = null;
			for (let i = 0; i < range.set.length; ++i) {
				let comparators = range.set[i],
					setMin = null;
				if (
					(comparators.forEach((comparator) => {
						let compver = new SemVer(comparator.semver.version);
						switch (comparator.operator) {
							case ">":
								if (compver.prerelease.length === 0) compver.patch++;
								else compver.prerelease.push(0);
								compver.raw = compver.format();
							case "":
							case ">=":
								if (!setMin || gt(compver, setMin)) setMin = compver;
								break;
							case "<":
							case "<=":
								break;
							default:
								throw new Error(`Unexpected operation: ${comparator.operator}`);
						}
					}),
					setMin && (!minver || gt(minver, setMin)))
				)
					minver = setMin;
			}
			if (minver && range.test(minver)) return minver;
			return null;
		};
	module.exports = minVersion;
});
var require_valid2 = __commonJS((exports, module) => {
	var Range = require_range(),
		validRange = (range, options) => {
			try {
				return new Range(range, options).range || "*";
			} catch (er) {
				return null;
			}
		};
	module.exports = validRange;
});
var require_outside = __commonJS((exports, module) => {
	var SemVer = require_semver(),
		Comparator = require_comparator(),
		{ ANY } = Comparator,
		Range = require_range(),
		satisfies = require_satisfies(),
		gt = require_gt(),
		lt = require_lt(),
		lte = require_lte(),
		gte = require_gte(),
		outside = (version, range, hilo, options) => {
			(version = new SemVer(version, options)),
				(range = new Range(range, options));
			let gtfn, ltefn, ltfn, comp, ecomp;
			switch (hilo) {
				case ">":
					(gtfn = gt), (ltefn = lte), (ltfn = lt), (comp = ">"), (ecomp = ">=");
					break;
				case "<":
					(gtfn = lt), (ltefn = gte), (ltfn = gt), (comp = "<"), (ecomp = "<=");
					break;
				default:
					throw new TypeError('Must provide a hilo val of "<" or ">"');
			}
			if (satisfies(version, range, options)) return !1;
			for (let i = 0; i < range.set.length; ++i) {
				let comparators = range.set[i],
					high = null,
					low = null;
				if (
					(comparators.forEach((comparator) => {
						if (comparator.semver === ANY)
							comparator = new Comparator(">=0.0.0");
						if (
							((high = high || comparator),
							(low = low || comparator),
							gtfn(comparator.semver, high.semver, options))
						)
							high = comparator;
						else if (ltfn(comparator.semver, low.semver, options))
							low = comparator;
					}),
					high.operator === comp || high.operator === ecomp)
				)
					return !1;
				if (
					(!low.operator || low.operator === comp) &&
					ltefn(version, low.semver)
				)
					return !1;
				else if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
			}
			return !0;
		};
	module.exports = outside;
});
var require_gtr = __commonJS((exports, module) => {
	var outside = require_outside(),
		gtr = (version, range, options) => outside(version, range, ">", options);
	module.exports = gtr;
});
var require_ltr = __commonJS((exports, module) => {
	var outside = require_outside(),
		ltr = (version, range, options) => outside(version, range, "<", options);
	module.exports = ltr;
});
var require_intersects = __commonJS((exports, module) => {
	var Range = require_range(),
		intersects = (r1, r2, options) => {
			return (
				(r1 = new Range(r1, options)),
				(r2 = new Range(r2, options)),
				r1.intersects(r2, options)
			);
		};
	module.exports = intersects;
});
var require_simplify = __commonJS((exports, module) => {
	var satisfies = require_satisfies(),
		compare = require_compare();
	module.exports = (versions, range, options) => {
		let set2 = [],
			first = null,
			prev = null,
			v = versions.sort((a, b) => compare(a, b, options));
		for (let version of v)
			if (satisfies(version, range, options)) {
				if (((prev = version), !first)) first = version;
			} else {
				if (prev) set2.push([first, prev]);
				(prev = null), (first = null);
			}
		if (first) set2.push([first, null]);
		let ranges = [];
		for (let [min, max] of set2)
			if (min === max) ranges.push(min);
			else if (!max && min === v[0]) ranges.push("*");
			else if (!max) ranges.push(`>=${min}`);
			else if (min === v[0]) ranges.push(`<=${max}`);
			else ranges.push(`${min} - ${max}`);
		let simplified = ranges.join(" || "),
			original = typeof range.raw === "string" ? range.raw : String(range);
		return simplified.length < original.length ? simplified : range;
	};
});
var require_subset = __commonJS((exports, module) => {
	var Range = require_range(),
		Comparator = require_comparator(),
		{ ANY } = Comparator,
		satisfies = require_satisfies(),
		compare = require_compare(),
		subset = (sub, dom, options = {}) => {
			if (sub === dom) return !0;
			(sub = new Range(sub, options)), (dom = new Range(dom, options));
			let sawNonNull = !1;
			OUTER: for (let simpleSub of sub.set) {
				for (let simpleDom of dom.set) {
					let isSub = simpleSubset(simpleSub, simpleDom, options);
					if (((sawNonNull = sawNonNull || isSub !== null), isSub))
						continue OUTER;
				}
				if (sawNonNull) return !1;
			}
			return !0;
		},
		minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")],
		minimumVersion = [new Comparator(">=0.0.0")],
		simpleSubset = (sub, dom, options) => {
			if (sub === dom) return !0;
			if (sub.length === 1 && sub[0].semver === ANY)
				if (dom.length === 1 && dom[0].semver === ANY) return !0;
				else if (options.includePrerelease) sub = minimumVersionWithPreRelease;
				else sub = minimumVersion;
			if (dom.length === 1 && dom[0].semver === ANY)
				if (options.includePrerelease) return !0;
				else dom = minimumVersion;
			let eqSet = new Set(),
				gt,
				lt;
			for (let c of sub)
				if (c.operator === ">" || c.operator === ">=")
					gt = higherGT(gt, c, options);
				else if (c.operator === "<" || c.operator === "<=")
					lt = lowerLT(lt, c, options);
				else eqSet.add(c.semver);
			if (eqSet.size > 1) return null;
			let gtltComp;
			if (gt && lt) {
				if (((gtltComp = compare(gt.semver, lt.semver, options)), gtltComp > 0))
					return null;
				else if (
					gtltComp === 0 &&
					(gt.operator !== ">=" || lt.operator !== "<=")
				)
					return null;
			}
			for (let eq of eqSet) {
				if (gt && !satisfies(eq, String(gt), options)) return null;
				if (lt && !satisfies(eq, String(lt), options)) return null;
				for (let c of dom) if (!satisfies(eq, String(c), options)) return !1;
				return !0;
			}
			let higher,
				lower,
				hasDomLT,
				hasDomGT,
				needDomLTPre =
					lt && !options.includePrerelease && lt.semver.prerelease.length
						? lt.semver
						: !1,
				needDomGTPre =
					gt && !options.includePrerelease && gt.semver.prerelease.length
						? gt.semver
						: !1;
			if (
				needDomLTPre &&
				needDomLTPre.prerelease.length === 1 &&
				lt.operator === "<" &&
				needDomLTPre.prerelease[0] === 0
			)
				needDomLTPre = !1;
			for (let c of dom) {
				if (
					((hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">="),
					(hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<="),
					gt)
				) {
					if (needDomGTPre) {
						if (
							c.semver.prerelease &&
							c.semver.prerelease.length &&
							c.semver.major === needDomGTPre.major &&
							c.semver.minor === needDomGTPre.minor &&
							c.semver.patch === needDomGTPre.patch
						)
							needDomGTPre = !1;
					}
					if (c.operator === ">" || c.operator === ">=") {
						if (
							((higher = higherGT(gt, c, options)),
							higher === c && higher !== gt)
						)
							return !1;
					} else if (
						gt.operator === ">=" &&
						!satisfies(gt.semver, String(c), options)
					)
						return !1;
				}
				if (lt) {
					if (needDomLTPre) {
						if (
							c.semver.prerelease &&
							c.semver.prerelease.length &&
							c.semver.major === needDomLTPre.major &&
							c.semver.minor === needDomLTPre.minor &&
							c.semver.patch === needDomLTPre.patch
						)
							needDomLTPre = !1;
					}
					if (c.operator === "<" || c.operator === "<=") {
						if (
							((lower = lowerLT(lt, c, options)), lower === c && lower !== lt)
						)
							return !1;
					} else if (
						lt.operator === "<=" &&
						!satisfies(lt.semver, String(c), options)
					)
						return !1;
				}
				if (!c.operator && (lt || gt) && gtltComp !== 0) return !1;
			}
			if (gt && hasDomLT && !lt && gtltComp !== 0) return !1;
			if (lt && hasDomGT && !gt && gtltComp !== 0) return !1;
			if (needDomGTPre || needDomLTPre) return !1;
			return !0;
		},
		higherGT = (a, b, options) => {
			if (!a) return b;
			let comp = compare(a.semver, b.semver, options);
			return comp > 0
				? a
				: comp < 0
					? b
					: b.operator === ">" && a.operator === ">="
						? b
						: a;
		},
		lowerLT = (a, b, options) => {
			if (!a) return b;
			let comp = compare(a.semver, b.semver, options);
			return comp < 0
				? a
				: comp > 0
					? b
					: b.operator === "<" && a.operator === "<="
						? b
						: a;
		};
	module.exports = subset;
});
var require_semver2 = __commonJS((exports, module) => {
	var internalRe = require_re(),
		constants = require_constants(),
		SemVer = require_semver(),
		identifiers = require_identifiers(),
		parse3 = require_parse(),
		valid = require_valid(),
		clean2 = require_clean(),
		inc = require_inc(),
		diff = require_diff(),
		major = require_major(),
		minor = require_minor(),
		patch = require_patch(),
		prerelease = require_prerelease(),
		compare = require_compare(),
		rcompare = require_rcompare(),
		compareLoose = require_compare_loose(),
		compareBuild = require_compare_build(),
		sort = require_sort(),
		rsort = require_rsort(),
		gt = require_gt(),
		lt = require_lt(),
		eq = require_eq(),
		neq = require_neq(),
		gte = require_gte(),
		lte = require_lte(),
		cmp = require_cmp(),
		coerce = require_coerce(),
		Comparator = require_comparator(),
		Range = require_range(),
		satisfies = require_satisfies(),
		toComparators = require_to_comparators(),
		maxSatisfying = require_max_satisfying(),
		minSatisfying = require_min_satisfying(),
		minVersion = require_min_version(),
		validRange = require_valid2(),
		outside = require_outside(),
		gtr = require_gtr(),
		ltr = require_ltr(),
		intersects = require_intersects(),
		simplifyRange = require_simplify(),
		subset = require_subset();
	module.exports = {
		parse: parse3,
		valid,
		clean: clean2,
		inc,
		diff,
		major,
		minor,
		patch,
		prerelease,
		compare,
		rcompare,
		compareLoose,
		compareBuild,
		sort,
		rsort,
		gt,
		lt,
		eq,
		neq,
		gte,
		lte,
		cmp,
		coerce,
		Comparator,
		Range,
		satisfies,
		toComparators,
		maxSatisfying,
		minSatisfying,
		minVersion,
		validRange,
		outside,
		gtr,
		ltr,
		intersects,
		simplifyRange,
		subset,
		SemVer,
		re: internalRe.re,
		src: internalRe.src,
		tokens: internalRe.t,
		SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
		RELEASE_TYPES: constants.RELEASE_TYPES,
		compareIdentifiers: identifiers.compareIdentifiers,
		rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
});
var require_err_helpers = __commonJS((exports, module) => {
	var isErrorLike = (err) => {
			return err && typeof err.message === "string";
		},
		getErrorCause = (err) => {
			if (!err) return;
			let cause = err.cause;
			if (typeof cause === "function") {
				let causeResult = err.cause();
				return isErrorLike(causeResult) ? causeResult : void 0;
			} else return isErrorLike(cause) ? cause : void 0;
		},
		_stackWithCauses = (err, seen) => {
			if (!isErrorLike(err)) return "";
			let stack = err.stack || "";
			if (seen.has(err))
				return (
					stack +
					`
causes have become circular...`
				);
			let cause = getErrorCause(err);
			if (cause)
				return (
					seen.add(err),
					stack +
						`
caused by: ` +
						_stackWithCauses(cause, seen)
				);
			else return stack;
		},
		stackWithCauses = (err) => _stackWithCauses(err, new Set()),
		_messageWithCauses = (err, seen, skip) => {
			if (!isErrorLike(err)) return "";
			let message = skip ? "" : err.message || "";
			if (seen.has(err)) return message + ": ...";
			let cause = getErrorCause(err);
			if (cause) {
				seen.add(err);
				let skipIfVErrorStyleCause = typeof err.cause === "function";
				return (
					message +
					(skipIfVErrorStyleCause ? "" : ": ") +
					_messageWithCauses(cause, seen, skipIfVErrorStyleCause)
				);
			} else return message;
		},
		messageWithCauses = (err) => _messageWithCauses(err, new Set());
	module.exports = {
		isErrorLike,
		getErrorCause,
		stackWithCauses,
		messageWithCauses,
	};
});
var require_err_proto = __commonJS((exports, module) => {
	var seen = Symbol("circular-ref-tag"),
		rawSymbol = Symbol("pino-raw-err-ref"),
		pinoErrProto = Object.create(
			{},
			{
				type: { enumerable: !0, writable: !0, value: void 0 },
				message: { enumerable: !0, writable: !0, value: void 0 },
				stack: { enumerable: !0, writable: !0, value: void 0 },
				aggregateErrors: { enumerable: !0, writable: !0, value: void 0 },
				raw: {
					enumerable: !1,
					get: function () {
						return this[rawSymbol];
					},
					set: function (val) {
						this[rawSymbol] = val;
					},
				},
			},
		);
	Object.defineProperty(pinoErrProto, rawSymbol, { writable: !0, value: {} });
	module.exports = { pinoErrProto, pinoErrorSymbols: { seen, rawSymbol } };
});
var require_err = __commonJS((exports, module) => {
	module.exports = errSerializer;
	var { messageWithCauses, stackWithCauses, isErrorLike } =
			require_err_helpers(),
		{ pinoErrProto, pinoErrorSymbols } = require_err_proto(),
		{ seen } = pinoErrorSymbols,
		{ toString } = Object.prototype;
	function errSerializer(err) {
		if (!isErrorLike(err)) return err;
		err[seen] = void 0;
		let _err = Object.create(pinoErrProto);
		if (
			((_err.type =
				toString.call(err.constructor) === "[object Function]"
					? err.constructor.name
					: err.name),
			(_err.message = messageWithCauses(err)),
			(_err.stack = stackWithCauses(err)),
			Array.isArray(err.errors))
		)
			_err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
		for (let key in err)
			if (_err[key] === void 0) {
				let val = err[key];
				if (isErrorLike(val)) {
					if (
						key !== "cause" &&
						!Object.prototype.hasOwnProperty.call(val, seen)
					)
						_err[key] = errSerializer(val);
				} else _err[key] = val;
			}
		return delete err[seen], (_err.raw = err), _err;
	}
});
var require_err_with_cause = __commonJS((exports, module) => {
	module.exports = errWithCauseSerializer;
	var { isErrorLike } = require_err_helpers(),
		{ pinoErrProto, pinoErrorSymbols } = require_err_proto(),
		{ seen } = pinoErrorSymbols,
		{ toString } = Object.prototype;
	function errWithCauseSerializer(err) {
		if (!isErrorLike(err)) return err;
		err[seen] = void 0;
		let _err = Object.create(pinoErrProto);
		if (
			((_err.type =
				toString.call(err.constructor) === "[object Function]"
					? err.constructor.name
					: err.name),
			(_err.message = err.message),
			(_err.stack = err.stack),
			Array.isArray(err.errors))
		)
			_err.aggregateErrors = err.errors.map((err2) =>
				errWithCauseSerializer(err2),
			);
		if (
			isErrorLike(err.cause) &&
			!Object.prototype.hasOwnProperty.call(err.cause, seen)
		)
			_err.cause = errWithCauseSerializer(err.cause);
		for (let key in err)
			if (_err[key] === void 0) {
				let val = err[key];
				if (isErrorLike(val)) {
					if (!Object.prototype.hasOwnProperty.call(val, seen))
						_err[key] = errWithCauseSerializer(val);
				} else _err[key] = val;
			}
		return delete err[seen], (_err.raw = err), _err;
	}
});
var require_req = __commonJS((exports, module) => {
	module.exports = { mapHttpRequest, reqSerializer };
	var rawSymbol = Symbol("pino-raw-req-ref"),
		pinoReqProto = Object.create(
			{},
			{
				id: { enumerable: !0, writable: !0, value: "" },
				method: { enumerable: !0, writable: !0, value: "" },
				url: { enumerable: !0, writable: !0, value: "" },
				query: { enumerable: !0, writable: !0, value: "" },
				params: { enumerable: !0, writable: !0, value: "" },
				headers: { enumerable: !0, writable: !0, value: {} },
				remoteAddress: { enumerable: !0, writable: !0, value: "" },
				remotePort: { enumerable: !0, writable: !0, value: "" },
				raw: {
					enumerable: !1,
					get: function () {
						return this[rawSymbol];
					},
					set: function (val) {
						this[rawSymbol] = val;
					},
				},
			},
		);
	Object.defineProperty(pinoReqProto, rawSymbol, { writable: !0, value: {} });
	function reqSerializer(req) {
		let connection = req.info || req.socket,
			_req = Object.create(pinoReqProto);
		if (
			((_req.id =
				typeof req.id === "function"
					? req.id()
					: req.id || (req.info ? req.info.id : void 0)),
			(_req.method = req.method),
			req.originalUrl)
		)
			_req.url = req.originalUrl;
		else {
			let path = req.path;
			_req.url =
				typeof path === "string"
					? path
					: req.url
						? req.url.path || req.url
						: void 0;
		}
		if (req.query) _req.query = req.query;
		if (req.params) _req.params = req.params;
		return (
			(_req.headers = req.headers),
			(_req.remoteAddress = connection && connection.remoteAddress),
			(_req.remotePort = connection && connection.remotePort),
			(_req.raw = req.raw || req),
			_req
		);
	}
	function mapHttpRequest(req) {
		return { req: reqSerializer(req) };
	}
});
var require_res = __commonJS((exports, module) => {
	module.exports = { mapHttpResponse, resSerializer };
	var rawSymbol = Symbol("pino-raw-res-ref"),
		pinoResProto = Object.create(
			{},
			{
				statusCode: { enumerable: !0, writable: !0, value: 0 },
				headers: { enumerable: !0, writable: !0, value: "" },
				raw: {
					enumerable: !1,
					get: function () {
						return this[rawSymbol];
					},
					set: function (val) {
						this[rawSymbol] = val;
					},
				},
			},
		);
	Object.defineProperty(pinoResProto, rawSymbol, { writable: !0, value: {} });
	function resSerializer(res) {
		let _res = Object.create(pinoResProto);
		return (
			(_res.statusCode = res.headersSent ? res.statusCode : null),
			(_res.headers = res.getHeaders ? res.getHeaders() : res._headers),
			(_res.raw = res),
			_res
		);
	}
	function mapHttpResponse(res) {
		return { res: resSerializer(res) };
	}
});
var require_pino_std_serializers = __commonJS((exports, module) => {
	var errSerializer = require_err(),
		errWithCauseSerializer = require_err_with_cause(),
		reqSerializers = require_req(),
		resSerializers = require_res();
	module.exports = {
		err: errSerializer,
		errWithCause: errWithCauseSerializer,
		mapHttpRequest: reqSerializers.mapHttpRequest,
		mapHttpResponse: resSerializers.mapHttpResponse,
		req: reqSerializers.reqSerializer,
		res: resSerializers.resSerializer,
		wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
			if (customSerializer === errSerializer) return customSerializer;
			return function wrapErrSerializer(err) {
				return customSerializer(errSerializer(err));
			};
		},
		wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
			if (customSerializer === reqSerializers.reqSerializer)
				return customSerializer;
			return function wrappedReqSerializer(req) {
				return customSerializer(reqSerializers.reqSerializer(req));
			};
		},
		wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
			if (customSerializer === resSerializers.resSerializer)
				return customSerializer;
			return function wrappedResSerializer(res) {
				return customSerializer(resSerializers.resSerializer(res));
			};
		},
	};
});
var require_caller = __commonJS((exports, module) => {
	function noOpPrepareStackTrace(_, stack) {
		return stack;
	}
	module.exports = function getCallers() {
		let originalPrepare = Error.prepareStackTrace;
		Error.prepareStackTrace = noOpPrepareStackTrace;
		let stack = new Error().stack;
		if (((Error.prepareStackTrace = originalPrepare), !Array.isArray(stack)))
			return;
		let entries = stack.slice(2),
			fileNames = [];
		for (let entry of entries) {
			if (!entry) continue;
			fileNames.push(entry.getFileName());
		}
		return fileNames;
	};
});
var require_validator = __commonJS((exports, module) => {
	module.exports = validator;
	function validator(opts = {}) {
		let {
			ERR_PATHS_MUST_BE_STRINGS = () =>
				"fast-redact - Paths must be (non-empty) strings",
			ERR_INVALID_PATH = (s) => `fast-redact – Invalid path (${s})`,
		} = opts;
		return function validate({ paths }) {
			paths.forEach((s) => {
				if (typeof s !== "string") throw Error(ERR_PATHS_MUST_BE_STRINGS());
				try {
					if (/〇/.test(s)) throw Error();
					let expr =
						(s[0] === "[" ? "" : ".") +
						s
							.replace(/^\*/, "〇")
							.replace(/\.\*/g, ".〇")
							.replace(/\[\*\]/g, "[〇]");
					if (/\n|\r|;/.test(expr)) throw Error();
					if (/\/\*/.test(expr)) throw Error();
					Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const 〇 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
				} catch (e) {
					throw Error(ERR_INVALID_PATH(s));
				}
			});
		};
	}
});
var require_rx = __commonJS((exports, module) => {
	module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
});
var require_parse2 = __commonJS((exports, module) => {
	var rx = require_rx();
	module.exports = parse3;
	function parse3({ paths }) {
		let wildcards = [];
		var wcLen = 0;
		let secret = paths.reduce(function (o, strPath, ix) {
			var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
			let leadingBracket = strPath[0] === "[";
			path = path.map((p) => {
				if (p[0] === "[") return p.substr(1, p.length - 2);
				else return p;
			});
			let star = path.indexOf("*");
			if (star > -1) {
				let before = path.slice(0, star),
					beforeStr = before.join("."),
					after = path.slice(star + 1, path.length),
					nested = after.length > 0;
				wcLen++, wildcards.push({ before, beforeStr, after, nested });
			} else
				o[strPath] = {
					path,
					val: void 0,
					precensored: !1,
					circle: "",
					escPath: JSON.stringify(strPath),
					leadingBracket,
				};
			return o;
		}, {});
		return { wildcards, wcLen, secret };
	}
});
var require_redactor = __commonJS((exports, module) => {
	var rx = require_rx();
	module.exports = redactor;
	function redactor(
		{
			secret,
			serialize: serialize2,
			wcLen,
			strict,
			isCensorFct,
			censorFctTakesPath,
		},
		state,
	) {
		let redact = Function(
			"o",
			`
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize2)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize2)}
  `,
		).bind(state);
		if (((redact.state = state), serialize2 === !1))
			redact.restore = (o) => state.restore(o);
		return redact;
	}
	function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
		return Object.keys(secret)
			.map((path) => {
				let { escPath, leadingBracket, path: arrPath } = secret[path],
					skip = leadingBracket ? 1 : 0,
					delim = leadingBracket ? "" : ".",
					hops = [];
				var match;
				while ((match = rx.exec(path)) !== null) {
					let [, ix] = match,
						{ index, input } = match;
					if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
				}
				var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
				if (existence.length === 0) existence += `o${delim}${path} != null`;
				else existence += ` && o${delim}${path} != null`;
				let circularDetection = `
      switch (true) {
        ${hops
					.reverse()
					.map(
						(p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `,
					)
					.join(`
`)}
      }
    `,
					censorArgs = censorFctTakesPath
						? `val, ${JSON.stringify(arrPath)}`
						: "val";
				return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
			})
			.join(`
`);
	}
	function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
		return hasWildcards === !0
			? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  `
			: "";
	}
	function resultTmpl(serialize2) {
		return serialize2 === !1
			? "return o"
			: `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
	}
	function strictImpl(strict, serialize2) {
		return strict === !0
			? "throw Error('fast-redact: primitives cannot be redacted')"
			: serialize2 === !1
				? "return o"
				: "return this.serialize(o)";
	}
});
var require_modifiers = __commonJS((exports, module) => {
	module.exports = { groupRedact, groupRestore, nestedRedact, nestedRestore };
	function groupRestore({ keys, values, target }) {
		if (target == null || typeof target === "string") return;
		let length = keys.length;
		for (var i = 0; i < length; i++) {
			let k = keys[i];
			target[k] = values[i];
		}
	}
	function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
		let target = get(o, path);
		if (target == null || typeof target === "string")
			return { keys: null, values: null, target, flat: !0 };
		let keys = Object.keys(target),
			keysLength = keys.length,
			pathLength = path.length,
			pathWithKey = censorFctTakesPath ? [...path] : void 0,
			values = new Array(keysLength);
		for (var i = 0; i < keysLength; i++) {
			let key = keys[i];
			if (((values[i] = target[key]), censorFctTakesPath))
				(pathWithKey[pathLength] = key),
					(target[key] = censor(target[key], pathWithKey));
			else if (isCensorFct) target[key] = censor(target[key]);
			else target[key] = censor;
		}
		return { keys, values, target, flat: !0 };
	}
	function nestedRestore(instructions) {
		for (let i = 0; i < instructions.length; i++) {
			let { target, path, value } = instructions[i],
				current = target;
			for (let i2 = path.length - 1; i2 > 0; i2--) current = current[path[i2]];
			current[path[0]] = value;
		}
	}
	function nestedRedact(
		store,
		o,
		path,
		ns,
		censor,
		isCensorFct,
		censorFctTakesPath,
	) {
		let target = get(o, path);
		if (target == null) return;
		let keys = Object.keys(target),
			keysLength = keys.length;
		for (var i = 0; i < keysLength; i++) {
			let key = keys[i];
			specialSet(
				store,
				target,
				key,
				path,
				ns,
				censor,
				isCensorFct,
				censorFctTakesPath,
			);
		}
		return store;
	}
	function has(obj, prop) {
		return obj !== void 0 && obj !== null
			? "hasOwn" in Object
				? Object.hasOwn(obj, prop)
				: Object.prototype.hasOwnProperty.call(obj, prop)
			: !1;
	}
	function specialSet(
		store,
		o,
		k,
		path,
		afterPath,
		censor,
		isCensorFct,
		censorFctTakesPath,
	) {
		let afterPathLen = afterPath.length,
			lastPathIndex = afterPathLen - 1,
			originalKey = k;
		var i = -1,
			n,
			nv,
			ov,
			oov = null,
			wc = null,
			kIsWc,
			wcov,
			consecutive = !1,
			level = 0,
			depth = 0,
			redactPathCurrent = tree();
		if (((ov = n = o[k]), typeof n !== "object")) return;
		while (n != null && ++i < afterPathLen) {
			if (
				((depth += 1),
				(k = afterPath[i]),
				(oov = ov),
				k !== "*" && !wc && !(typeof n === "object" && k in n))
			)
				break;
			if (k === "*") {
				if (wc === "*") consecutive = !0;
				if (((wc = k), i !== lastPathIndex)) continue;
			}
			if (wc) {
				let wcKeys = Object.keys(n);
				for (var j = 0; j < wcKeys.length; j++) {
					let wck = wcKeys[j];
					if (((wcov = n[wck]), (kIsWc = k === "*"), consecutive))
						(redactPathCurrent = node(redactPathCurrent, wck, depth)),
							(level = i),
							(ov = iterateNthLevel(
								wcov,
								level - 1,
								k,
								path,
								afterPath,
								censor,
								isCensorFct,
								censorFctTakesPath,
								originalKey,
								n,
								nv,
								ov,
								kIsWc,
								wck,
								i,
								lastPathIndex,
								redactPathCurrent,
								store,
								o[originalKey],
								depth + 1,
							));
					else if (
						kIsWc ||
						(typeof wcov === "object" && wcov !== null && k in wcov)
					) {
						if (kIsWc) ov = wcov;
						else ov = wcov[k];
						if (
							((nv =
								i !== lastPathIndex
									? ov
									: isCensorFct
										? censorFctTakesPath
											? censor(ov, [...path, originalKey, ...afterPath])
											: censor(ov)
										: censor),
							kIsWc)
						) {
							let rv = restoreInstr(
								node(redactPathCurrent, wck, depth),
								ov,
								o[originalKey],
							);
							store.push(rv), (n[wck] = nv);
						} else if (wcov[k] === nv);
						else if (
							(nv === void 0 && censor !== void 0) ||
							(has(wcov, k) && nv === ov)
						)
							redactPathCurrent = node(redactPathCurrent, wck, depth);
						else {
							redactPathCurrent = node(redactPathCurrent, wck, depth);
							let rv = restoreInstr(
								node(redactPathCurrent, k, depth + 1),
								ov,
								o[originalKey],
							);
							store.push(rv), (wcov[k] = nv);
						}
					}
				}
				wc = null;
			} else {
				if (
					((ov = n[k]),
					(redactPathCurrent = node(redactPathCurrent, k, depth)),
					(nv =
						i !== lastPathIndex
							? ov
							: isCensorFct
								? censorFctTakesPath
									? censor(ov, [...path, originalKey, ...afterPath])
									: censor(ov)
								: censor),
					(has(n, k) && nv === ov) || (nv === void 0 && censor !== void 0))
				);
				else {
					let rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
					store.push(rv), (n[k] = nv);
				}
				n = n[k];
			}
			if (typeof n !== "object") break;
		}
	}
	function get(o, p) {
		var i = -1,
			l = p.length,
			n = o;
		while (n != null && ++i < l) n = n[p[i]];
		return n;
	}
	function iterateNthLevel(
		wcov,
		level,
		k,
		path,
		afterPath,
		censor,
		isCensorFct,
		censorFctTakesPath,
		originalKey,
		n,
		nv,
		ov,
		kIsWc,
		wck,
		i,
		lastPathIndex,
		redactPathCurrent,
		store,
		parent,
		depth,
	) {
		if (level === 0) {
			if (kIsWc || (typeof wcov === "object" && wcov !== null && k in wcov)) {
				if (kIsWc) ov = wcov;
				else ov = wcov[k];
				if (
					((nv =
						i !== lastPathIndex
							? ov
							: isCensorFct
								? censorFctTakesPath
									? censor(ov, [...path, originalKey, ...afterPath])
									: censor(ov)
								: censor),
					kIsWc)
				) {
					let rv = restoreInstr(redactPathCurrent, ov, parent);
					store.push(rv), (n[wck] = nv);
				} else if (wcov[k] === nv);
				else if (
					(nv === void 0 && censor !== void 0) ||
					(has(wcov, k) && nv === ov)
				);
				else {
					let rv = restoreInstr(
						node(redactPathCurrent, k, depth + 1),
						ov,
						parent,
					);
					store.push(rv), (wcov[k] = nv);
				}
			}
		}
		for (let key in wcov)
			if (typeof wcov[key] === "object")
				(redactPathCurrent = node(redactPathCurrent, key, depth)),
					iterateNthLevel(
						wcov[key],
						level - 1,
						k,
						path,
						afterPath,
						censor,
						isCensorFct,
						censorFctTakesPath,
						originalKey,
						n,
						nv,
						ov,
						kIsWc,
						wck,
						i,
						lastPathIndex,
						redactPathCurrent,
						store,
						parent,
						depth + 1,
					);
	}
	function tree() {
		return { parent: null, key: null, children: [], depth: 0 };
	}
	function node(parent, key, depth) {
		if (parent.depth === depth) return node(parent.parent, key, depth);
		var child = { parent, key, depth, children: [] };
		return parent.children.push(child), child;
	}
	function restoreInstr(node2, value, target) {
		let current = node2,
			path = [];
		do path.push(current.key), (current = current.parent);
		while (current.parent != null);
		return { path, value, target };
	}
});
var require_restorer = __commonJS((exports, module) => {
	var { groupRestore, nestedRestore } = require_modifiers();
	module.exports = restorer;
	function restorer() {
		return function compileRestore() {
			if (this.restore) {
				this.restore.state.secret = this.secret;
				return;
			}
			let { secret, wcLen } = this,
				paths = Object.keys(secret),
				resetters = resetTmpl(secret, paths),
				hasWildcards = wcLen > 0,
				state = hasWildcards
					? { secret, groupRestore, nestedRestore }
					: { secret };
			(this.restore = Function(
				"o",
				restoreTmpl(resetters, paths, hasWildcards),
			).bind(state)),
				(this.restore.state = state);
		};
	}
	function resetTmpl(secret, paths) {
		return paths
			.map((path) => {
				let { circle, escPath, leadingBracket } = secret[path],
					reset = circle
						? `o.${circle} = secret[${escPath}].val`
						: `o${leadingBracket ? "" : "."}${path} = secret[${escPath}].val`,
					clear = `secret[${escPath}].val = undefined`;
				return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
			})
			.join("");
	}
	function restoreTmpl(resetters, paths, hasWildcards) {
		return `
    const secret = this.secret
    ${
			hasWildcards === !0
				? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  `
				: ""
		}
    ${resetters}
    return o
  `;
	}
});
var require_state = __commonJS((exports, module) => {
	module.exports = state;
	function state(o) {
		let {
				secret,
				censor,
				compileRestore,
				serialize: serialize2,
				groupRedact,
				nestedRedact,
				wildcards,
				wcLen,
			} = o,
			builder = [{ secret, censor, compileRestore }];
		if (serialize2 !== !1) builder.push({ serialize: serialize2 });
		if (wcLen > 0)
			builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
		return Object.assign(...builder);
	}
});
var require_fast_redact = __commonJS((exports, module) => {
	var validator = require_validator(),
		parse3 = require_parse2(),
		redactor = require_redactor(),
		restorer = require_restorer(),
		{ groupRedact, nestedRedact } = require_modifiers(),
		state = require_state(),
		rx = require_rx(),
		validate = validator(),
		noop = (o) => o;
	noop.restore = noop;
	var DEFAULT_CENSOR = "[REDACTED]";
	fastRedact.rx = rx;
	fastRedact.validator = validator;
	module.exports = fastRedact;
	function fastRedact(opts = {}) {
		let paths = Array.from(new Set(opts.paths || [])),
			serialize2 =
				"serialize" in opts
					? opts.serialize === !1
						? opts.serialize
						: typeof opts.serialize === "function"
							? opts.serialize
							: JSON.stringify
					: JSON.stringify,
			remove = opts.remove;
		if (remove === !0 && serialize2 !== JSON.stringify)
			throw Error(
				"fast-redact – remove option may only be set when serializer is JSON.stringify",
			);
		let censor =
				remove === !0
					? void 0
					: "censor" in opts
						? opts.censor
						: DEFAULT_CENSOR,
			isCensorFct = typeof censor === "function",
			censorFctTakesPath = isCensorFct && censor.length > 1;
		if (paths.length === 0) return serialize2 || noop;
		validate({ paths, serialize: serialize2, censor });
		let { wildcards, wcLen, secret } = parse3({ paths, censor }),
			compileRestore = restorer(),
			strict = "strict" in opts ? opts.strict : !0;
		return redactor(
			{
				secret,
				wcLen,
				serialize: serialize2,
				strict,
				isCensorFct,
				censorFctTakesPath,
			},
			state({
				secret,
				censor,
				compileRestore,
				serialize: serialize2,
				groupRedact,
				nestedRedact,
				wildcards,
				wcLen,
			}),
		);
	}
});
var require_symbols = __commonJS((exports, module) => {
	var setLevelSym = Symbol("pino.setLevel"),
		getLevelSym = Symbol("pino.getLevel"),
		levelValSym = Symbol("pino.levelVal"),
		levelCompSym = Symbol("pino.levelComp"),
		useLevelLabelsSym = Symbol("pino.useLevelLabels"),
		useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels"),
		mixinSym = Symbol("pino.mixin"),
		lsCacheSym = Symbol("pino.lsCache"),
		chindingsSym = Symbol("pino.chindings"),
		asJsonSym = Symbol("pino.asJson"),
		writeSym = Symbol("pino.write"),
		redactFmtSym = Symbol("pino.redactFmt"),
		timeSym = Symbol("pino.time"),
		timeSliceIndexSym = Symbol("pino.timeSliceIndex"),
		streamSym = Symbol("pino.stream"),
		stringifySym = Symbol("pino.stringify"),
		stringifySafeSym = Symbol("pino.stringifySafe"),
		stringifiersSym = Symbol("pino.stringifiers"),
		endSym = Symbol("pino.end"),
		formatOptsSym = Symbol("pino.formatOpts"),
		messageKeySym = Symbol("pino.messageKey"),
		errorKeySym = Symbol("pino.errorKey"),
		nestedKeySym = Symbol("pino.nestedKey"),
		nestedKeyStrSym = Symbol("pino.nestedKeyStr"),
		mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy"),
		msgPrefixSym = Symbol("pino.msgPrefix"),
		wildcardFirstSym = Symbol("pino.wildcardFirst"),
		serializersSym = Symbol.for("pino.serializers"),
		formattersSym = Symbol.for("pino.formatters"),
		hooksSym = Symbol.for("pino.hooks"),
		needsMetadataGsym = Symbol.for("pino.metadata");
	module.exports = {
		setLevelSym,
		getLevelSym,
		levelValSym,
		levelCompSym,
		useLevelLabelsSym,
		mixinSym,
		lsCacheSym,
		chindingsSym,
		asJsonSym,
		writeSym,
		serializersSym,
		redactFmtSym,
		timeSym,
		timeSliceIndexSym,
		streamSym,
		stringifySym,
		stringifySafeSym,
		stringifiersSym,
		endSym,
		formatOptsSym,
		messageKeySym,
		errorKeySym,
		nestedKeySym,
		wildcardFirstSym,
		needsMetadataGsym,
		useOnlyCustomLevelsSym,
		formattersSym,
		hooksSym,
		nestedKeyStrSym,
		mixinMergeStrategySym,
		msgPrefixSym,
	};
});
var require_redaction = __commonJS((exports, module) => {
	var fastRedact = require_fast_redact(),
		{ redactFmtSym, wildcardFirstSym } = require_symbols(),
		{ rx, validator } = fastRedact,
		validate = validator({
			ERR_PATHS_MUST_BE_STRINGS: () => "pino – redacted paths must be strings",
			ERR_INVALID_PATH: (s) =>
				`pino – redact paths array contains an invalid path (${s})`,
		});
	function redaction(opts, serialize2) {
		let { paths, censor } = handle(opts),
			shape = paths.reduce((o, str) => {
				rx.lastIndex = 0;
				let first = rx.exec(str),
					next2 = rx.exec(str),
					ns =
						first[1] !== void 0
							? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1")
							: first[0];
				if (ns === "*") ns = wildcardFirstSym;
				if (next2 === null) return (o[ns] = null), o;
				if (o[ns] === null) return o;
				let { index } = next2,
					nextPath = `${str.substr(index, str.length - 1)}`;
				if (
					((o[ns] = o[ns] || []), ns !== wildcardFirstSym && o[ns].length === 0)
				)
					o[ns].push(...(o[wildcardFirstSym] || []));
				if (ns === wildcardFirstSym)
					Object.keys(o).forEach(function (k) {
						if (o[k]) o[k].push(nextPath);
					});
				return o[ns].push(nextPath), o;
			}, {}),
			result = {
				[redactFmtSym]: fastRedact({
					paths,
					censor,
					serialize: serialize2,
					strict: !1,
				}),
			},
			topCensor = (...args) => {
				return typeof censor === "function"
					? serialize2(censor(...args))
					: serialize2(censor);
			};
		return [
			...Object.keys(shape),
			...Object.getOwnPropertySymbols(shape),
		].reduce((o, k) => {
			if (shape[k] === null) o[k] = (value) => topCensor(value, [k]);
			else {
				let wrappedCensor =
					typeof censor === "function"
						? (value, path) => {
								return censor(value, [k, ...path]);
							}
						: censor;
				o[k] = fastRedact({
					paths: shape[k],
					censor: wrappedCensor,
					serialize: serialize2,
					strict: !1,
				});
			}
			return o;
		}, result);
	}
	function handle(opts) {
		if (Array.isArray(opts))
			return (
				(opts = { paths: opts, censor: "[Redacted]" }), validate(opts), opts
			);
		let { paths, censor = "[Redacted]", remove } = opts;
		if (Array.isArray(paths) === !1)
			throw Error("pino – redact must contain an array of strings");
		if (remove === !0) censor = void 0;
		return validate({ paths, censor }), { paths, censor };
	}
	module.exports = redaction;
});
var require_time = __commonJS((exports, module) => {
	var nullTime = () => "",
		epochTime = () => `,"time":${Date.now()}`,
		unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`,
		isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
	module.exports = { nullTime, epochTime, unixTime, isoTime };
});
var require_quick_format_unescaped = __commonJS((exports, module) => {
	function tryStringify(o) {
		try {
			return JSON.stringify(o);
		} catch (e) {
			return '"[Circular]"';
		}
	}
	module.exports = format;
	function format(f, args, opts) {
		var ss = (opts && opts.stringify) || tryStringify,
			offset = 1;
		if (typeof f === "object" && f !== null) {
			var len = args.length + offset;
			if (len === 1) return f;
			var objects = new Array(len);
			objects[0] = ss(f);
			for (var index = 1; index < len; index++)
				objects[index] = ss(args[index]);
			return objects.join(" ");
		}
		if (typeof f !== "string") return f;
		var argLen = args.length;
		if (argLen === 0) return f;
		var str = "",
			a = 1 - offset,
			lastPos = -1,
			flen = (f && f.length) || 0;
		for (var i = 0; i < flen; ) {
			if (f.charCodeAt(i) === 37 && i + 1 < flen) {
				switch (((lastPos = lastPos > -1 ? lastPos : 0), f.charCodeAt(i + 1))) {
					case 100:
					case 102:
						if (a >= argLen) break;
						if (args[a] == null) break;
						if (lastPos < i) str += f.slice(lastPos, i);
						(str += Number(args[a])), (lastPos = i + 2), i++;
						break;
					case 105:
						if (a >= argLen) break;
						if (args[a] == null) break;
						if (lastPos < i) str += f.slice(lastPos, i);
						(str += Math.floor(Number(args[a]))), (lastPos = i + 2), i++;
						break;
					case 79:
					case 111:
					case 106:
						if (a >= argLen) break;
						if (args[a] === void 0) break;
						if (lastPos < i) str += f.slice(lastPos, i);
						var type2 = typeof args[a];
						if (type2 === "string") {
							(str += "'" + args[a] + "'"), (lastPos = i + 2), i++;
							break;
						}
						if (type2 === "function") {
							(str += args[a].name || "<anonymous>"), (lastPos = i + 2), i++;
							break;
						}
						(str += ss(args[a])), (lastPos = i + 2), i++;
						break;
					case 115:
						if (a >= argLen) break;
						if (lastPos < i) str += f.slice(lastPos, i);
						(str += String(args[a])), (lastPos = i + 2), i++;
						break;
					case 37:
						if (lastPos < i) str += f.slice(lastPos, i);
						(str += "%"), (lastPos = i + 2), i++, a--;
						break;
				}
				++a;
			}
			++i;
		}
		if (lastPos === -1) return f;
		else if (lastPos < flen) str += f.slice(lastPos);
		return str;
	}
});
var require_atomic_sleep = __commonJS((exports, module) => {
	if (
		typeof SharedArrayBuffer !== "undefined" &&
		typeof Atomics !== "undefined"
	) {
		let sleep = function (ms) {
				if ((ms > 0 && ms < 1 / 0) === !1) {
					if (typeof ms !== "number" && typeof ms !== "bigint")
						throw TypeError("sleep: ms must be a number");
					throw RangeError(
						"sleep: ms must be a number that is greater than 0 but less than Infinity",
					);
				}
				Atomics.wait(nil, 0, 0, Number(ms));
			},
			nil = new Int32Array(new SharedArrayBuffer(4));
		module.exports = sleep;
	} else {
		let sleep = function (ms) {
			if ((ms > 0 && ms < 1 / 0) === !1) {
				if (typeof ms !== "number" && typeof ms !== "bigint")
					throw TypeError("sleep: ms must be a number");
				throw RangeError(
					"sleep: ms must be a number that is greater than 0 but less than Infinity",
				);
			}
			let target = Date.now() + Number(ms);
			while (target > Date.now());
		};
		module.exports = sleep;
	}
});
var require_sonic_boom = __commonJS((exports, module) => {
	var fs = __require("fs"),
		EventEmitter = __require("events"),
		inherits = __require("util").inherits,
		path = __require("path"),
		sleep = require_atomic_sleep(),
		kEmptyBuffer = Buffer.allocUnsafe(0);
	function openFile(file2, sonic) {
		(sonic._opening = !0),
			(sonic._writing = !0),
			(sonic._asyncDrainScheduled = !1);
		function fileOpened(err, fd) {
			if (err) {
				if (
					((sonic._reopening = !1),
					(sonic._writing = !1),
					(sonic._opening = !1),
					sonic.sync)
				)
					process.nextTick(() => {
						if (sonic.listenerCount("error") > 0) sonic.emit("error", err);
					});
				else sonic.emit("error", err);
				return;
			}
			let reopening = sonic._reopening;
			if (
				((sonic.fd = fd),
				(sonic.file = file2),
				(sonic._reopening = !1),
				(sonic._opening = !1),
				(sonic._writing = !1),
				sonic.sync)
			)
				process.nextTick(() => sonic.emit("ready"));
			else sonic.emit("ready");
			if (sonic.destroyed) return;
			if (
				(!sonic._writing && sonic._len > sonic.minLength) ||
				sonic._flushPending
			)
				sonic._actualWrite();
			else if (reopening) process.nextTick(() => sonic.emit("drain"));
		}
		let flags = sonic.append ? "a" : "w",
			mode = sonic.mode;
		if (sonic.sync)
			try {
				if (sonic.mkdir) fs.mkdirSync(path.dirname(file2), { recursive: !0 });
				let fd = fs.openSync(file2, flags, mode);
				fileOpened(null, fd);
			} catch (err) {
				throw (fileOpened(err), err);
			}
		else if (sonic.mkdir)
			fs.mkdir(path.dirname(file2), { recursive: !0 }, (err) => {
				if (err) return fileOpened(err);
				fs.open(file2, flags, mode, fileOpened);
			});
		else fs.open(file2, flags, mode, fileOpened);
	}
	function SonicBoom(opts) {
		if (!(this instanceof SonicBoom)) return new SonicBoom(opts);
		let {
			fd,
			dest,
			minLength,
			maxLength,
			maxWrite,
			sync,
			append = !0,
			mkdir,
			retryEAGAIN,
			fsync,
			contentMode,
			mode,
		} = opts || {};
		(fd = fd || dest),
			(this._len = 0),
			(this.fd = -1),
			(this._bufs = []),
			(this._lens = []),
			(this._writing = !1),
			(this._ending = !1),
			(this._reopening = !1),
			(this._asyncDrainScheduled = !1),
			(this._flushPending = !1),
			(this._hwm = Math.max(minLength || 0, 16387)),
			(this.file = null),
			(this.destroyed = !1),
			(this.minLength = minLength || 0),
			(this.maxLength = maxLength || 0),
			(this.maxWrite = maxWrite || 16384),
			(this.sync = sync || !1),
			(this.writable = !0),
			(this._fsync = fsync || !1),
			(this.append = append || !1),
			(this.mode = mode),
			(this.retryEAGAIN = retryEAGAIN || (() => !0)),
			(this.mkdir = mkdir || !1);
		let fsWriteSync, fsWrite;
		if (contentMode === "buffer")
			(this._writingBuf = kEmptyBuffer),
				(this.write = writeBuffer),
				(this.flush = flushBuffer),
				(this.flushSync = flushBufferSync),
				(this._actualWrite = actualWriteBuffer),
				(fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf)),
				(fsWrite = () => fs.write(this.fd, this._writingBuf, this.release));
		else if (contentMode === void 0 || contentMode === "utf8")
			(this._writingBuf = ""),
				(this.write = write),
				(this.flush = flush),
				(this.flushSync = flushSync),
				(this._actualWrite = actualWrite),
				(fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8")),
				(fsWrite = () =>
					fs.write(this.fd, this._writingBuf, "utf8", this.release));
		else
			throw new Error(
				`SonicBoom supports "utf8" and "buffer", but passed ${contentMode}`,
			);
		if (typeof fd === "number")
			(this.fd = fd), process.nextTick(() => this.emit("ready"));
		else if (typeof fd === "string") openFile(fd, this);
		else throw new Error("SonicBoom supports only file descriptors and files");
		if (this.minLength >= this.maxWrite)
			throw new Error(
				`minLength should be smaller than maxWrite (${this.maxWrite})`,
			);
		(this.release = (err, n) => {
			if (err) {
				if (
					(err.code === "EAGAIN" || err.code === "EBUSY") &&
					this.retryEAGAIN(
						err,
						this._writingBuf.length,
						this._len - this._writingBuf.length,
					)
				)
					if (this.sync)
						try {
							sleep(100), this.release(void 0, 0);
						} catch (err2) {
							this.release(err2);
						}
					else setTimeout(fsWrite, 100);
				else (this._writing = !1), this.emit("error", err);
				return;
			}
			this.emit("write", n);
			let releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
			if (
				((this._len = releasedBufObj.len),
				(this._writingBuf = releasedBufObj.writingBuf),
				this._writingBuf.length)
			) {
				if (!this.sync) {
					fsWrite();
					return;
				}
				try {
					do {
						let n2 = fsWriteSync(),
							releasedBufObj2 = releaseWritingBuf(
								this._writingBuf,
								this._len,
								n2,
							);
						(this._len = releasedBufObj2.len),
							(this._writingBuf = releasedBufObj2.writingBuf);
					} while (this._writingBuf.length);
				} catch (err2) {
					this.release(err2);
					return;
				}
			}
			if (this._fsync) fs.fsyncSync(this.fd);
			let len = this._len;
			if (this._reopening)
				(this._writing = !1), (this._reopening = !1), this.reopen();
			else if (len > this.minLength) this._actualWrite();
			else if (this._ending)
				if (len > 0) this._actualWrite();
				else (this._writing = !1), actualClose(this);
			else if (((this._writing = !1), this.sync)) {
				if (!this._asyncDrainScheduled)
					(this._asyncDrainScheduled = !0), process.nextTick(emitDrain, this);
			} else this.emit("drain");
		}),
			this.on("newListener", function (name) {
				if (name === "drain") this._asyncDrainScheduled = !1;
			});
	}
	function releaseWritingBuf(writingBuf, len, n) {
		if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n)
			n = Buffer.from(writingBuf).subarray(0, n).toString().length;
		return (
			(len = Math.max(len - n, 0)),
			(writingBuf = writingBuf.slice(n)),
			{ writingBuf, len }
		);
	}
	function emitDrain(sonic) {
		if (!(sonic.listenerCount("drain") > 0)) return;
		(sonic._asyncDrainScheduled = !1), sonic.emit("drain");
	}
	inherits(SonicBoom, EventEmitter);
	function mergeBuf(bufs, len) {
		if (bufs.length === 0) return kEmptyBuffer;
		if (bufs.length === 1) return bufs[0];
		return Buffer.concat(bufs, len);
	}
	function write(data) {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		let len = this._len + data.length,
			bufs = this._bufs;
		if (this.maxLength && len > this.maxLength)
			return this.emit("drop", data), this._len < this._hwm;
		if (
			bufs.length === 0 ||
			bufs[bufs.length - 1].length + data.length > this.maxWrite
		)
			bufs.push("" + data);
		else bufs[bufs.length - 1] += data;
		if (((this._len = len), !this._writing && this._len >= this.minLength))
			this._actualWrite();
		return this._len < this._hwm;
	}
	function writeBuffer(data) {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		let len = this._len + data.length,
			bufs = this._bufs,
			lens = this._lens;
		if (this.maxLength && len > this.maxLength)
			return this.emit("drop", data), this._len < this._hwm;
		if (
			bufs.length === 0 ||
			lens[lens.length - 1] + data.length > this.maxWrite
		)
			bufs.push([data]), lens.push(data.length);
		else
			bufs[bufs.length - 1].push(data), (lens[lens.length - 1] += data.length);
		if (((this._len = len), !this._writing && this._len >= this.minLength))
			this._actualWrite();
		return this._len < this._hwm;
	}
	function callFlushCallbackOnDrain(cb) {
		this._flushPending = !0;
		let onDrain = () => {
				if (!this._fsync)
					fs.fsync(this.fd, (err) => {
						(this._flushPending = !1), cb(err);
					});
				else (this._flushPending = !1), cb();
				this.off("error", onError);
			},
			onError = (err) => {
				(this._flushPending = !1), cb(err), this.off("drain", onDrain);
			};
		this.once("drain", onDrain), this.once("error", onError);
	}
	function flush(cb) {
		if (cb != null && typeof cb !== "function")
			throw new Error("flush cb must be a function");
		if (this.destroyed) {
			let error2 = new Error("SonicBoom destroyed");
			if (cb) {
				cb(error2);
				return;
			}
			throw error2;
		}
		if (this.minLength <= 0) {
			cb?.();
			return;
		}
		if (cb) callFlushCallbackOnDrain.call(this, cb);
		if (this._writing) return;
		if (this._bufs.length === 0) this._bufs.push("");
		this._actualWrite();
	}
	function flushBuffer(cb) {
		if (cb != null && typeof cb !== "function")
			throw new Error("flush cb must be a function");
		if (this.destroyed) {
			let error2 = new Error("SonicBoom destroyed");
			if (cb) {
				cb(error2);
				return;
			}
			throw error2;
		}
		if (this.minLength <= 0) {
			cb?.();
			return;
		}
		if (cb) callFlushCallbackOnDrain.call(this, cb);
		if (this._writing) return;
		if (this._bufs.length === 0) this._bufs.push([]), this._lens.push(0);
		this._actualWrite();
	}
	SonicBoom.prototype.reopen = function (file2) {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		if (this._opening) {
			this.once("ready", () => {
				this.reopen(file2);
			});
			return;
		}
		if (this._ending) return;
		if (!this.file)
			throw new Error(
				"Unable to reopen a file descriptor, you must pass a file to SonicBoom",
			);
		if (file2) this.file = file2;
		if (((this._reopening = !0), this._writing)) return;
		let fd = this.fd;
		this.once("ready", () => {
			if (fd !== this.fd)
				fs.close(fd, (err) => {
					if (err) return this.emit("error", err);
				});
		}),
			openFile(this.file, this);
	};
	SonicBoom.prototype.end = function () {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		if (this._opening) {
			this.once("ready", () => {
				this.end();
			});
			return;
		}
		if (this._ending) return;
		if (((this._ending = !0), this._writing)) return;
		if (this._len > 0 && this.fd >= 0) this._actualWrite();
		else actualClose(this);
	};
	function flushSync() {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		if (this.fd < 0) throw new Error("sonic boom is not ready yet");
		if (!this._writing && this._writingBuf.length > 0)
			this._bufs.unshift(this._writingBuf), (this._writingBuf = "");
		let buf = "";
		while (this._bufs.length || buf) {
			if (buf.length <= 0) buf = this._bufs[0];
			try {
				let n = fs.writeSync(this.fd, buf, "utf8"),
					releasedBufObj = releaseWritingBuf(buf, this._len, n);
				if (
					((buf = releasedBufObj.writingBuf),
					(this._len = releasedBufObj.len),
					buf.length <= 0)
				)
					this._bufs.shift();
			} catch (err) {
				if (
					(err.code === "EAGAIN" || err.code === "EBUSY") &&
					!this.retryEAGAIN(err, buf.length, this._len - buf.length)
				)
					throw err;
				sleep(100);
			}
		}
		try {
			fs.fsyncSync(this.fd);
		} catch {}
	}
	function flushBufferSync() {
		if (this.destroyed) throw new Error("SonicBoom destroyed");
		if (this.fd < 0) throw new Error("sonic boom is not ready yet");
		if (!this._writing && this._writingBuf.length > 0)
			this._bufs.unshift([this._writingBuf]), (this._writingBuf = kEmptyBuffer);
		let buf = kEmptyBuffer;
		while (this._bufs.length || buf.length) {
			if (buf.length <= 0) buf = mergeBuf(this._bufs[0], this._lens[0]);
			try {
				let n = fs.writeSync(this.fd, buf);
				if (
					((buf = buf.subarray(n)),
					(this._len = Math.max(this._len - n, 0)),
					buf.length <= 0)
				)
					this._bufs.shift(), this._lens.shift();
			} catch (err) {
				if (
					(err.code === "EAGAIN" || err.code === "EBUSY") &&
					!this.retryEAGAIN(err, buf.length, this._len - buf.length)
				)
					throw err;
				sleep(100);
			}
		}
	}
	SonicBoom.prototype.destroy = function () {
		if (this.destroyed) return;
		actualClose(this);
	};
	function actualWrite() {
		let release = this.release;
		if (
			((this._writing = !0),
			(this._writingBuf = this._writingBuf || this._bufs.shift() || ""),
			this.sync)
		)
			try {
				let written = fs.writeSync(this.fd, this._writingBuf, "utf8");
				release(null, written);
			} catch (err) {
				release(err);
			}
		else fs.write(this.fd, this._writingBuf, "utf8", release);
	}
	function actualWriteBuffer() {
		let release = this.release;
		if (
			((this._writing = !0),
			(this._writingBuf = this._writingBuf.length
				? this._writingBuf
				: mergeBuf(this._bufs.shift(), this._lens.shift())),
			this.sync)
		)
			try {
				let written = fs.writeSync(this.fd, this._writingBuf);
				release(null, written);
			} catch (err) {
				release(err);
			}
		else fs.write(this.fd, this._writingBuf, release);
	}
	function actualClose(sonic) {
		if (sonic.fd === -1) {
			sonic.once("ready", actualClose.bind(null, sonic));
			return;
		}
		(sonic.destroyed = !0),
			(sonic._bufs = []),
			(sonic._lens = []),
			fs.fsync(sonic.fd, closeWrapped);
		function closeWrapped() {
			if (sonic.fd !== 1 && sonic.fd !== 2) fs.close(sonic.fd, done);
			else done();
		}
		function done(err) {
			if (err) {
				sonic.emit("error", err);
				return;
			}
			if (sonic._ending && !sonic._writing) sonic.emit("finish");
			sonic.emit("close");
		}
	}
	SonicBoom.SonicBoom = SonicBoom;
	SonicBoom.default = SonicBoom;
	module.exports = SonicBoom;
});
var require_on_exit_leak_free = __commonJS((exports, module) => {
	var refs = { exit: [], beforeExit: [] },
		functions = { exit: onExit, beforeExit: onBeforeExit },
		registry;
	function ensureRegistry() {
		if (registry === void 0) registry = new FinalizationRegistry(clear);
	}
	function install(event) {
		if (refs[event].length > 0) return;
		process.on(event, functions[event]);
	}
	function uninstall(event) {
		if (refs[event].length > 0) return;
		if (
			(process.removeListener(event, functions[event]),
			refs.exit.length === 0 && refs.beforeExit.length === 0)
		)
			registry = void 0;
	}
	function onExit() {
		callRefs("exit");
	}
	function onBeforeExit() {
		callRefs("beforeExit");
	}
	function callRefs(event) {
		for (let ref of refs[event]) {
			let obj = ref.deref(),
				fn = ref.fn;
			if (obj !== void 0) fn(obj, event);
		}
		refs[event] = [];
	}
	function clear(ref) {
		for (let event of ["exit", "beforeExit"]) {
			let index = refs[event].indexOf(ref);
			refs[event].splice(index, index + 1), uninstall(event);
		}
	}
	function _register(event, obj, fn) {
		if (obj === void 0) throw new Error("the object can't be undefined");
		install(event);
		let ref = new WeakRef(obj);
		(ref.fn = fn),
			ensureRegistry(),
			registry.register(obj, ref),
			refs[event].push(ref);
	}
	function register(obj, fn) {
		_register("exit", obj, fn);
	}
	function registerBeforeExit(obj, fn) {
		_register("beforeExit", obj, fn);
	}
	function unregister(obj) {
		if (registry === void 0) return;
		registry.unregister(obj);
		for (let event of ["exit", "beforeExit"])
			(refs[event] = refs[event].filter((ref) => {
				let _obj = ref.deref();
				return _obj && _obj !== obj;
			})),
				uninstall(event);
	}
	module.exports = { register, registerBeforeExit, unregister };
});
var require_package = __commonJS((exports, module) => {
	module.exports = {
		name: "thread-stream",
		version: "2.7.0",
		description: "A streaming way to send data to a Node.js Worker Thread",
		main: "index.js",
		types: "index.d.ts",
		dependencies: { "real-require": "^0.2.0" },
		devDependencies: {
			"@types/node": "^20.1.0",
			"@types/tap": "^15.0.0",
			"@yao-pkg/pkg": "^5.11.5",
			desm: "^1.3.0",
			fastbench: "^1.0.1",
			husky: "^9.0.6",
			"pino-elasticsearch": "^8.0.0",
			"sonic-boom": "^3.0.0",
			standard: "^17.0.0",
			tap: "^16.2.0",
			"ts-node": "^10.8.0",
			typescript: "^5.3.2",
			"why-is-node-running": "^2.2.2",
		},
		scripts: {
			test: 'standard && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
			"test:ci":
				"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
			"test:ci:js":
				'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
			"test:ci:ts":
				'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
			"test:yarn":
				'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
			transpile: "sh ./test/ts/transpile.sh",
			prepare: "husky install",
		},
		standard: { ignore: ["test/ts/**/*"] },
		repository: {
			type: "git",
			url: "git+https://github.com/mcollina/thread-stream.git",
		},
		keywords: ["worker", "thread", "threads", "stream"],
		author: "Matteo Collina <hello@matteocollina.com>",
		license: "MIT",
		bugs: { url: "https://github.com/mcollina/thread-stream/issues" },
		homepage: "https://github.com/mcollina/thread-stream#readme",
	};
});
var require_wait = __commonJS((exports, module) => {
	function wait(state, index, expected, timeout, done) {
		let max = Date.now() + timeout,
			current = Atomics.load(state, index);
		if (current === expected) {
			done(null, "ok");
			return;
		}
		let prior = current,
			check2 = (backoff) => {
				if (Date.now() > max) done(null, "timed-out");
				else
					setTimeout(() => {
						if (
							((prior = current),
							(current = Atomics.load(state, index)),
							current === prior)
						)
							check2(backoff >= 1000 ? 1000 : backoff * 2);
						else if (current === expected) done(null, "ok");
						else done(null, "not-equal");
					}, backoff);
			};
		check2(1);
	}
	function waitDiff(state, index, expected, timeout, done) {
		let max = Date.now() + timeout,
			current = Atomics.load(state, index);
		if (current !== expected) {
			done(null, "ok");
			return;
		}
		let check2 = (backoff) => {
			if (Date.now() > max) done(null, "timed-out");
			else
				setTimeout(() => {
					if (((current = Atomics.load(state, index)), current !== expected))
						done(null, "ok");
					else check2(backoff >= 1000 ? 1000 : backoff * 2);
				}, backoff);
		};
		check2(1);
	}
	module.exports = { wait, waitDiff };
});
var require_indexes = __commonJS((exports, module) => {
	module.exports = { WRITE_INDEX: 4, READ_INDEX: 8 };
});
var require_thread_stream = __commonJS((exports, module) => {
	var __dirname = "A:\\Developer\\elsyiapr\\node_modules\\thread-stream",
		{ version } = require_package(),
		{ EventEmitter } = __require("events"),
		{ Worker } = __require("worker_threads"),
		{ join } = __require("path"),
		{ pathToFileURL } = __require("url"),
		{ wait } = require_wait(),
		{ WRITE_INDEX, READ_INDEX } = require_indexes(),
		buffer = __require("buffer"),
		assert2 = __require("assert"),
		kImpl = Symbol("kImpl"),
		MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
	class FakeWeakRef {
		constructor(value) {
			this._value = value;
		}
		deref() {
			return this._value;
		}
	}
	class FakeFinalizationRegistry {
		register() {}
		unregister() {}
	}
	var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE
			? FakeFinalizationRegistry
			: global.FinalizationRegistry || FakeFinalizationRegistry,
		WeakRef2 = process.env.NODE_V8_COVERAGE
			? FakeWeakRef
			: global.WeakRef || FakeWeakRef,
		registry = new FinalizationRegistry2((worker) => {
			if (worker.exited) return;
			worker.terminate();
		});
	function createWorker(stream, opts) {
		let { filename, workerData } = opts,
			toExecute =
				("__bundlerPathsOverrides" in globalThis
					? globalThis.__bundlerPathsOverrides
					: {})["thread-stream-worker"] || join(__dirname, "lib", "worker.js"),
			worker = new Worker(toExecute, {
				...opts.workerOpts,
				trackUnmanagedFds: !1,
				workerData: {
					filename:
						filename.indexOf("file://") === 0
							? filename
							: pathToFileURL(filename).href,
					dataBuf: stream[kImpl].dataBuf,
					stateBuf: stream[kImpl].stateBuf,
					workerData: {
						$context: { threadStreamVersion: version },
						...workerData,
					},
				},
			});
		return (
			(worker.stream = new FakeWeakRef(stream)),
			worker.on("message", onWorkerMessage),
			worker.on("exit", onWorkerExit),
			registry.register(stream, worker),
			worker
		);
	}
	function drain(stream) {
		if ((assert2(!stream[kImpl].sync), stream[kImpl].needDrain))
			(stream[kImpl].needDrain = !1), stream.emit("drain");
	}
	function nextFlush(stream) {
		let writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX),
			leftover = stream[kImpl].data.length - writeIndex;
		if (leftover > 0) {
			if (stream[kImpl].buf.length === 0) {
				if (((stream[kImpl].flushing = !1), stream[kImpl].ending)) end(stream);
				else if (stream[kImpl].needDrain) process.nextTick(drain, stream);
				return;
			}
			let toWrite = stream[kImpl].buf.slice(0, leftover),
				toWriteBytes = Buffer.byteLength(toWrite);
			if (toWriteBytes <= leftover)
				(stream[kImpl].buf = stream[kImpl].buf.slice(leftover)),
					write(stream, toWrite, nextFlush.bind(null, stream));
			else
				stream.flush(() => {
					if (stream.destroyed) return;
					Atomics.store(stream[kImpl].state, READ_INDEX, 0),
						Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
					while (toWriteBytes > stream[kImpl].data.length)
						(leftover = leftover / 2),
							(toWrite = stream[kImpl].buf.slice(0, leftover)),
							(toWriteBytes = Buffer.byteLength(toWrite));
					(stream[kImpl].buf = stream[kImpl].buf.slice(leftover)),
						write(stream, toWrite, nextFlush.bind(null, stream));
				});
		} else if (leftover === 0) {
			if (writeIndex === 0 && stream[kImpl].buf.length === 0) return;
			stream.flush(() => {
				Atomics.store(stream[kImpl].state, READ_INDEX, 0),
					Atomics.store(stream[kImpl].state, WRITE_INDEX, 0),
					nextFlush(stream);
			});
		} else destroy(stream, new Error("overwritten"));
	}
	function onWorkerMessage(msg) {
		let stream = this.stream.deref();
		if (stream === void 0) {
			(this.exited = !0), this.terminate();
			return;
		}
		switch (msg.code) {
			case "READY":
				(this.stream = new WeakRef2(stream)),
					stream.flush(() => {
						(stream[kImpl].ready = !0), stream.emit("ready");
					});
				break;
			case "ERROR":
				destroy(stream, msg.err);
				break;
			case "EVENT":
				if (Array.isArray(msg.args)) stream.emit(msg.name, ...msg.args);
				else stream.emit(msg.name, msg.args);
				break;
			case "WARNING":
				process.emitWarning(msg.err);
				break;
			default:
				destroy(stream, new Error("this should not happen: " + msg.code));
		}
	}
	function onWorkerExit(code) {
		let stream = this.stream.deref();
		if (stream === void 0) return;
		registry.unregister(stream),
			(stream.worker.exited = !0),
			stream.worker.off("exit", onWorkerExit),
			destroy(
				stream,
				code !== 0 ? new Error("the worker thread exited") : null,
			);
	}
	class ThreadStream extends EventEmitter {
		constructor(opts = {}) {
			super();
			if (opts.bufferSize < 4)
				throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
			(this[kImpl] = {}),
				(this[kImpl].stateBuf = new SharedArrayBuffer(128)),
				(this[kImpl].state = new Int32Array(this[kImpl].stateBuf)),
				(this[kImpl].dataBuf = new SharedArrayBuffer(
					opts.bufferSize || 4194304,
				)),
				(this[kImpl].data = Buffer.from(this[kImpl].dataBuf)),
				(this[kImpl].sync = opts.sync || !1),
				(this[kImpl].ending = !1),
				(this[kImpl].ended = !1),
				(this[kImpl].needDrain = !1),
				(this[kImpl].destroyed = !1),
				(this[kImpl].flushing = !1),
				(this[kImpl].ready = !1),
				(this[kImpl].finished = !1),
				(this[kImpl].errored = null),
				(this[kImpl].closed = !1),
				(this[kImpl].buf = ""),
				(this.worker = createWorker(this, opts)),
				this.on("message", (message, transferList) => {
					this.worker.postMessage(message, transferList);
				});
		}
		write(data) {
			if (this[kImpl].destroyed)
				return error2(this, new Error("the worker has exited")), !1;
			if (this[kImpl].ending)
				return error2(this, new Error("the worker is ending")), !1;
			if (
				this[kImpl].flushing &&
				this[kImpl].buf.length + data.length >= MAX_STRING
			)
				try {
					writeSync(this), (this[kImpl].flushing = !0);
				} catch (err) {
					return destroy(this, err), !1;
				}
			if (((this[kImpl].buf += data), this[kImpl].sync))
				try {
					return writeSync(this), !0;
				} catch (err) {
					return destroy(this, err), !1;
				}
			if (!this[kImpl].flushing)
				(this[kImpl].flushing = !0), setImmediate(nextFlush, this);
			return (
				(this[kImpl].needDrain =
					this[kImpl].data.length -
						this[kImpl].buf.length -
						Atomics.load(this[kImpl].state, WRITE_INDEX) <=
					0),
				!this[kImpl].needDrain
			);
		}
		end() {
			if (this[kImpl].destroyed) return;
			(this[kImpl].ending = !0), end(this);
		}
		flush(cb) {
			if (this[kImpl].destroyed) {
				if (typeof cb === "function")
					process.nextTick(cb, new Error("the worker has exited"));
				return;
			}
			let writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
			wait(this[kImpl].state, READ_INDEX, writeIndex, 1 / 0, (err, res) => {
				if (err) {
					destroy(this, err), process.nextTick(cb, err);
					return;
				}
				if (res === "not-equal") {
					this.flush(cb);
					return;
				}
				process.nextTick(cb);
			});
		}
		flushSync() {
			if (this[kImpl].destroyed) return;
			writeSync(this), flushSync(this);
		}
		unref() {
			this.worker.unref();
		}
		ref() {
			this.worker.ref();
		}
		get ready() {
			return this[kImpl].ready;
		}
		get destroyed() {
			return this[kImpl].destroyed;
		}
		get closed() {
			return this[kImpl].closed;
		}
		get writable() {
			return !this[kImpl].destroyed && !this[kImpl].ending;
		}
		get writableEnded() {
			return this[kImpl].ending;
		}
		get writableFinished() {
			return this[kImpl].finished;
		}
		get writableNeedDrain() {
			return this[kImpl].needDrain;
		}
		get writableObjectMode() {
			return !1;
		}
		get writableErrored() {
			return this[kImpl].errored;
		}
	}
	function error2(stream, err) {
		setImmediate(() => {
			stream.emit("error", err);
		});
	}
	function destroy(stream, err) {
		if (stream[kImpl].destroyed) return;
		if (((stream[kImpl].destroyed = !0), err))
			(stream[kImpl].errored = err), error2(stream, err);
		if (!stream.worker.exited)
			stream.worker
				.terminate()
				.catch(() => {})
				.then(() => {
					(stream[kImpl].closed = !0), stream.emit("close");
				});
		else
			setImmediate(() => {
				(stream[kImpl].closed = !0), stream.emit("close");
			});
	}
	function write(stream, data, cb) {
		let current = Atomics.load(stream[kImpl].state, WRITE_INDEX),
			length = Buffer.byteLength(data);
		return (
			stream[kImpl].data.write(data, current),
			Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length),
			Atomics.notify(stream[kImpl].state, WRITE_INDEX),
			cb(),
			!0
		);
	}
	function end(stream) {
		if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing)
			return;
		stream[kImpl].ended = !0;
		try {
			stream.flushSync();
			let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
			Atomics.store(stream[kImpl].state, WRITE_INDEX, -1),
				Atomics.notify(stream[kImpl].state, WRITE_INDEX);
			let spins = 0;
			while (readIndex !== -1) {
				if (
					(Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000),
					(readIndex = Atomics.load(stream[kImpl].state, READ_INDEX)),
					readIndex === -2)
				) {
					destroy(stream, new Error("end() failed"));
					return;
				}
				if (++spins === 10) {
					destroy(stream, new Error("end() took too long (10s)"));
					return;
				}
			}
			process.nextTick(() => {
				(stream[kImpl].finished = !0), stream.emit("finish");
			});
		} catch (err) {
			destroy(stream, err);
		}
	}
	function writeSync(stream) {
		let cb = () => {
			if (stream[kImpl].ending) end(stream);
			else if (stream[kImpl].needDrain) process.nextTick(drain, stream);
		};
		stream[kImpl].flushing = !1;
		while (stream[kImpl].buf.length !== 0) {
			let writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX),
				leftover = stream[kImpl].data.length - writeIndex;
			if (leftover === 0) {
				flushSync(stream),
					Atomics.store(stream[kImpl].state, READ_INDEX, 0),
					Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
				continue;
			} else if (leftover < 0) throw new Error("overwritten");
			let toWrite = stream[kImpl].buf.slice(0, leftover),
				toWriteBytes = Buffer.byteLength(toWrite);
			if (toWriteBytes <= leftover)
				(stream[kImpl].buf = stream[kImpl].buf.slice(leftover)),
					write(stream, toWrite, cb);
			else {
				flushSync(stream),
					Atomics.store(stream[kImpl].state, READ_INDEX, 0),
					Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
				while (toWriteBytes > stream[kImpl].buf.length)
					(leftover = leftover / 2),
						(toWrite = stream[kImpl].buf.slice(0, leftover)),
						(toWriteBytes = Buffer.byteLength(toWrite));
				(stream[kImpl].buf = stream[kImpl].buf.slice(leftover)),
					write(stream, toWrite, cb);
			}
		}
	}
	function flushSync(stream) {
		if (stream[kImpl].flushing)
			throw new Error("unable to flush while flushing");
		let writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX),
			spins = 0;
		while (!0) {
			let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
			if (readIndex === -2) throw Error("_flushSync failed");
			if (readIndex !== writeIndex)
				Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
			else break;
			if (++spins === 10) throw new Error("_flushSync took too long (10s)");
		}
	}
	module.exports = ThreadStream;
});
var require_transport = __commonJS((exports, module) => {
	var __dirname = "A:\\Developer\\elsyiapr\\node_modules\\pino\\lib",
		{ createRequire: createRequire2 } = __require("module"),
		getCallers = require_caller(),
		{ join, isAbsolute, sep } = __require("path"),
		sleep = require_atomic_sleep(),
		onExit = require_on_exit_leak_free(),
		ThreadStream = require_thread_stream();
	function setupOnExit(stream) {
		onExit.register(stream, autoEnd),
			onExit.registerBeforeExit(stream, flush),
			stream.on("close", function () {
				onExit.unregister(stream);
			});
	}
	function buildStream(filename, workerData, workerOpts) {
		let stream = new ThreadStream({ filename, workerData, workerOpts });
		stream.on("ready", onReady),
			stream.on("close", function () {
				process.removeListener("exit", onExit2);
			}),
			process.on("exit", onExit2);
		function onReady() {
			if (
				(process.removeListener("exit", onExit2),
				stream.unref(),
				workerOpts.autoEnd !== !1)
			)
				setupOnExit(stream);
		}
		function onExit2() {
			if (stream.closed) return;
			stream.flushSync(), sleep(100), stream.end();
		}
		return stream;
	}
	function autoEnd(stream) {
		stream.ref(),
			stream.flushSync(),
			stream.end(),
			stream.once("close", function () {
				stream.unref();
			});
	}
	function flush(stream) {
		stream.flushSync();
	}
	function transport(fullOptions) {
		let {
				pipeline,
				targets,
				levels,
				dedupe,
				options = {},
				worker = {},
				caller = getCallers(),
			} = fullOptions,
			callers = typeof caller === "string" ? [caller] : caller,
			bundlerOverrides =
				"__bundlerPathsOverrides" in globalThis
					? globalThis.__bundlerPathsOverrides
					: {},
			target = fullOptions.target;
		if (target && targets)
			throw new Error("only one of target or targets can be specified");
		if (targets)
			(target =
				bundlerOverrides["pino-worker"] || join(__dirname, "worker.js")),
				(options.targets = targets.map((dest) => {
					return { ...dest, target: fixTarget(dest.target) };
				}));
		else if (pipeline)
			(target =
				bundlerOverrides["pino-pipeline-worker"] ||
				join(__dirname, "worker-pipeline.js")),
				(options.targets = pipeline.map((dest) => {
					return { ...dest, target: fixTarget(dest.target) };
				}));
		if (levels) options.levels = levels;
		if (dedupe) options.dedupe = dedupe;
		return (
			(options.pinoWillSendConfig = !0),
			buildStream(fixTarget(target), options, worker)
		);
		function fixTarget(origin) {
			if (
				((origin = bundlerOverrides[origin] || origin),
				isAbsolute(origin) || origin.indexOf("file://") === 0)
			)
				return origin;
			if (origin === "pino/file") return join(__dirname, "..", "file.js");
			let fixTarget2;
			for (let filePath of callers)
				try {
					let context =
						filePath === "node:repl" ? process.cwd() + sep : filePath;
					fixTarget2 = createRequire2(context).resolve(origin);
					break;
				} catch (err) {
					continue;
				}
			if (!fixTarget2)
				throw new Error(`unable to determine transport target for "${origin}"`);
			return fixTarget2;
		}
	}
	module.exports = transport;
});
var require_tools = __commonJS((exports, module) => {
	var format = require_quick_format_unescaped(),
		{ mapHttpRequest, mapHttpResponse } = require_pino_std_serializers(),
		SonicBoom = require_sonic_boom(),
		onExit = require_on_exit_leak_free(),
		{
			lsCacheSym,
			chindingsSym,
			writeSym,
			serializersSym,
			formatOptsSym,
			endSym,
			stringifiersSym,
			stringifySym,
			stringifySafeSym,
			wildcardFirstSym,
			nestedKeySym,
			formattersSym,
			messageKeySym,
			errorKeySym,
			nestedKeyStrSym,
			msgPrefixSym,
		} = require_symbols(),
		{ isMainThread } = __require("worker_threads"),
		transport = require_transport();
	function noop() {}
	function genLog(level, hook) {
		if (!hook) return LOG;
		return function hookWrappedLog(...args) {
			hook.call(this, args, LOG, level);
		};
		function LOG(o, ...n) {
			if (typeof o === "object") {
				let msg = o;
				if (o !== null) {
					if (o.method && o.headers && o.socket) o = mapHttpRequest(o);
					else if (typeof o.setHeader === "function") o = mapHttpResponse(o);
				}
				let formatParams;
				if (msg === null && n.length === 0) formatParams = [null];
				else (msg = n.shift()), (formatParams = n);
				if (
					typeof this[msgPrefixSym] === "string" &&
					msg !== void 0 &&
					msg !== null
				)
					msg = this[msgPrefixSym] + msg;
				this[writeSym](
					o,
					format(msg, formatParams, this[formatOptsSym]),
					level,
				);
			} else {
				let msg = o === void 0 ? n.shift() : o;
				if (
					typeof this[msgPrefixSym] === "string" &&
					msg !== void 0 &&
					msg !== null
				)
					msg = this[msgPrefixSym] + msg;
				this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
			}
		}
	}
	function asString(str) {
		let result = "",
			last = 0,
			found = !1,
			point = 255,
			l = str.length;
		if (l > 100) return JSON.stringify(str);
		for (var i = 0; i < l && point >= 32; i++)
			if (((point = str.charCodeAt(i)), point === 34 || point === 92))
				(result += str.slice(last, i) + "\\"), (last = i), (found = !0);
		if (!found) result = str;
		else result += str.slice(last);
		return point < 32 ? JSON.stringify(str) : '"' + result + '"';
	}
	function asJson(obj, msg, num, time) {
		let stringify2 = this[stringifySym],
			stringifySafe = this[stringifySafeSym],
			stringifiers = this[stringifiersSym],
			end = this[endSym],
			chindings = this[chindingsSym],
			serializers = this[serializersSym],
			formatters = this[formattersSym],
			messageKey = this[messageKeySym],
			errorKey = this[errorKeySym],
			data = this[lsCacheSym][num] + time;
		data = data + chindings;
		let value;
		if (formatters.log) obj = formatters.log(obj);
		let wildcardStringifier = stringifiers[wildcardFirstSym],
			propStr = "";
		for (let key in obj)
			if (
				((value = obj[key]),
				Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0)
			) {
				if (serializers[key]) value = serializers[key](value);
				else if (key === errorKey && serializers.err)
					value = serializers.err(value);
				let stringifier = stringifiers[key] || wildcardStringifier;
				switch (typeof value) {
					case "undefined":
					case "function":
						continue;
					case "number":
						if (Number.isFinite(value) === !1) value = null;
					case "boolean":
						if (stringifier) value = stringifier(value);
						break;
					case "string":
						value = (stringifier || asString)(value);
						break;
					default:
						value = (stringifier || stringify2)(value, stringifySafe);
				}
				if (value === void 0) continue;
				let strKey = asString(key);
				propStr += "," + strKey + ":" + value;
			}
		let msgStr = "";
		if (msg !== void 0) {
			value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
			let stringifier = stringifiers[messageKey] || wildcardStringifier;
			switch (typeof value) {
				case "function":
					break;
				case "number":
					if (Number.isFinite(value) === !1) value = null;
				case "boolean":
					if (stringifier) value = stringifier(value);
					msgStr = ',"' + messageKey + '":' + value;
					break;
				case "string":
					(value = (stringifier || asString)(value)),
						(msgStr = ',"' + messageKey + '":' + value);
					break;
				default:
					(value = (stringifier || stringify2)(value, stringifySafe)),
						(msgStr = ',"' + messageKey + '":' + value);
			}
		}
		if (this[nestedKeySym] && propStr)
			return (
				data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end
			);
		else return data + propStr + msgStr + end;
	}
	function asChindings(instance, bindings) {
		let value,
			data = instance[chindingsSym],
			stringify2 = instance[stringifySym],
			stringifySafe = instance[stringifySafeSym],
			stringifiers = instance[stringifiersSym],
			wildcardStringifier = stringifiers[wildcardFirstSym],
			serializers = instance[serializersSym],
			formatter = instance[formattersSym].bindings;
		bindings = formatter(bindings);
		for (let key in bindings)
			if (
				((value = bindings[key]),
				(key !== "level" &&
					key !== "serializers" &&
					key !== "formatters" &&
					key !== "customLevels" &&
					bindings.hasOwnProperty(key) &&
					value !== void 0) === !0)
			) {
				if (
					((value = serializers[key] ? serializers[key](value) : value),
					(value = (stringifiers[key] || wildcardStringifier || stringify2)(
						value,
						stringifySafe,
					)),
					value === void 0)
				)
					continue;
				data += ',"' + key + '":' + value;
			}
		return data;
	}
	function hasBeenTampered(stream) {
		return stream.write !== stream.constructor.prototype.write;
	}
	var hasNodeCodeCoverage =
		process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
	function buildSafeSonicBoom(opts) {
		let stream = new SonicBoom(opts);
		if (
			(stream.on("error", filterBrokenPipe),
			!hasNodeCodeCoverage && !opts.sync && isMainThread)
		)
			onExit.register(stream, autoEnd),
				stream.on("close", function () {
					onExit.unregister(stream);
				});
		return stream;
		function filterBrokenPipe(err) {
			if (err.code === "EPIPE") {
				(stream.write = noop),
					(stream.end = noop),
					(stream.flushSync = noop),
					(stream.destroy = noop);
				return;
			}
			stream.removeListener("error", filterBrokenPipe),
				stream.emit("error", err);
		}
	}
	function autoEnd(stream, eventName) {
		if (stream.destroyed) return;
		if (eventName === "beforeExit")
			stream.flush(),
				stream.on("drain", function () {
					stream.end();
				});
		else stream.flushSync();
	}
	function createArgsNormalizer(defaultOptions) {
		return function normalizeArgs(instance, caller, opts = {}, stream) {
			if (typeof opts === "string")
				(stream = buildSafeSonicBoom({ dest: opts })), (opts = {});
			else if (typeof stream === "string") {
				if (opts && opts.transport)
					throw Error(
						"only one of option.transport or stream can be specified",
					);
				stream = buildSafeSonicBoom({ dest: stream });
			} else if (
				opts instanceof SonicBoom ||
				opts.writable ||
				opts._writableState
			)
				(stream = opts), (opts = {});
			else if (opts.transport) {
				if (
					opts.transport instanceof SonicBoom ||
					opts.transport.writable ||
					opts.transport._writableState
				)
					throw Error(
						"option.transport do not allow stream, please pass to option directly. e.g. pino(transport)",
					);
				if (
					opts.transport.targets &&
					opts.transport.targets.length &&
					opts.formatters &&
					typeof opts.formatters.level === "function"
				)
					throw Error(
						"option.transport.targets do not allow custom level formatters",
					);
				let customLevels;
				if (opts.customLevels)
					customLevels = opts.useOnlyCustomLevels
						? opts.customLevels
						: Object.assign({}, opts.levels, opts.customLevels);
				stream = transport({ caller, ...opts.transport, levels: customLevels });
			}
			if (
				((opts = Object.assign({}, defaultOptions, opts)),
				(opts.serializers = Object.assign(
					{},
					defaultOptions.serializers,
					opts.serializers,
				)),
				(opts.formatters = Object.assign(
					{},
					defaultOptions.formatters,
					opts.formatters,
				)),
				opts.prettyPrint)
			)
				throw new Error(
					"prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)",
				);
			let { enabled, onChild } = opts;
			if (enabled === !1) opts.level = "silent";
			if (!onChild) opts.onChild = noop;
			if (!stream)
				if (!hasBeenTampered(process.stdout))
					stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
				else stream = process.stdout;
			return { opts, stream };
		};
	}
	function stringify(obj, stringifySafeFn) {
		try {
			return JSON.stringify(obj);
		} catch (_) {
			try {
				return (stringifySafeFn || this[stringifySafeSym])(obj);
			} catch (_2) {
				return '"[unable to serialize, circular reference is too complex to analyze]"';
			}
		}
	}
	function buildFormatters(level, bindings, log) {
		return { level, bindings, log };
	}
	function normalizeDestFileDescriptor(destination) {
		let fd = Number(destination);
		if (typeof destination === "string" && Number.isFinite(fd)) return fd;
		if (destination === void 0) return 1;
		return destination;
	}
	module.exports = {
		noop,
		buildSafeSonicBoom,
		asChindings,
		asJson,
		genLog,
		createArgsNormalizer,
		stringify,
		buildFormatters,
		normalizeDestFileDescriptor,
	};
});
var require_constants2 = __commonJS((exports, module) => {
	var DEFAULT_LEVELS = {
			trace: 10,
			debug: 20,
			info: 30,
			warn: 40,
			error: 50,
			fatal: 60,
		},
		SORTING_ORDER = { ASC: "ASC", DESC: "DESC" };
	module.exports = { DEFAULT_LEVELS, SORTING_ORDER };
});
var require_levels = __commonJS((exports, module) => {
	var {
			lsCacheSym,
			levelValSym,
			useOnlyCustomLevelsSym,
			streamSym,
			formattersSym,
			hooksSym,
			levelCompSym,
		} = require_symbols(),
		{ noop, genLog } = require_tools(),
		{ DEFAULT_LEVELS, SORTING_ORDER } = require_constants2(),
		levelMethods = {
			fatal: (hook) => {
				let logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
				return function (...args) {
					let stream = this[streamSym];
					if (
						(logFatal.call(this, ...args),
						typeof stream.flushSync === "function")
					)
						try {
							stream.flushSync();
						} catch (e) {}
				};
			},
			error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
			warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
			info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
			debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
			trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook),
		},
		nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
			return (o[DEFAULT_LEVELS[k]] = k), o;
		}, {}),
		initialLsCache = Object.keys(nums).reduce((o, k) => {
			return (o[k] = '{"level":' + Number(k)), o;
		}, {});
	function genLsCache(instance) {
		let formatter = instance[formattersSym].level,
			{ labels } = instance.levels,
			cache = {};
		for (let label in labels) {
			let level = formatter(labels[label], Number(label));
			cache[label] = JSON.stringify(level).slice(0, -1);
		}
		return (instance[lsCacheSym] = cache), instance;
	}
	function isStandardLevel(level, useOnlyCustomLevels) {
		if (useOnlyCustomLevels) return !1;
		switch (level) {
			case "fatal":
			case "error":
			case "warn":
			case "info":
			case "debug":
			case "trace":
				return !0;
			default:
				return !1;
		}
	}
	function setLevel(level) {
		let { labels, values } = this.levels;
		if (typeof level === "number") {
			if (labels[level] === void 0) throw Error("unknown level value" + level);
			level = labels[level];
		}
		if (values[level] === void 0) throw Error("unknown level " + level);
		let preLevelVal = this[levelValSym],
			levelVal = (this[levelValSym] = values[level]),
			useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym],
			levelComparison = this[levelCompSym],
			hook = this[hooksSym].logMethod;
		for (let key in values) {
			if (levelComparison(values[key], levelVal) === !1) {
				this[key] = noop;
				continue;
			}
			this[key] = isStandardLevel(key, useOnlyCustomLevelsVal)
				? levelMethods[key](hook)
				: genLog(values[key], hook);
		}
		this.emit(
			"level-change",
			level,
			levelVal,
			labels[preLevelVal],
			preLevelVal,
			this,
		);
	}
	function getLevel(level) {
		let { levels, levelVal } = this;
		return levels && levels.labels ? levels.labels[levelVal] : "";
	}
	function isLevelEnabled(logLevel) {
		let { values } = this.levels,
			logLevelVal = values[logLevel];
		return (
			logLevelVal !== void 0 &&
			this[levelCompSym](logLevelVal, this[levelValSym])
		);
	}
	function compareLevel(direction, current, expected) {
		if (direction === SORTING_ORDER.DESC) return current <= expected;
		return current >= expected;
	}
	function genLevelComparison(levelComparison) {
		if (typeof levelComparison === "string")
			return compareLevel.bind(null, levelComparison);
		return levelComparison;
	}
	function mappings(customLevels = null, useOnlyCustomLevels = !1) {
		let customNums = customLevels
				? Object.keys(customLevels).reduce((o, k) => {
						return (o[customLevels[k]] = k), o;
					}, {})
				: null,
			labels = Object.assign(
				Object.create(Object.prototype, { Infinity: { value: "silent" } }),
				useOnlyCustomLevels ? null : nums,
				customNums,
			),
			values = Object.assign(
				Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
				useOnlyCustomLevels ? null : DEFAULT_LEVELS,
				customLevels,
			);
		return { labels, values };
	}
	function assertDefaultLevelFound(
		defaultLevel,
		customLevels,
		useOnlyCustomLevels,
	) {
		if (typeof defaultLevel === "number") {
			if (
				![]
					.concat(
						Object.keys(customLevels || {}).map((key) => customLevels[key]),
						useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
						1 / 0,
					)
					.includes(defaultLevel)
			)
				throw Error(
					`default level:${defaultLevel} must be included in custom levels`,
				);
			return;
		}
		let labels = Object.assign(
			Object.create(Object.prototype, { silent: { value: 1 / 0 } }),
			useOnlyCustomLevels ? null : DEFAULT_LEVELS,
			customLevels,
		);
		if (!(defaultLevel in labels))
			throw Error(
				`default level:${defaultLevel} must be included in custom levels`,
			);
	}
	function assertNoLevelCollisions(levels, customLevels) {
		let { labels, values } = levels;
		for (let k in customLevels) {
			if (k in values) throw Error("levels cannot be overridden");
			if (customLevels[k] in labels)
				throw Error("pre-existing level values cannot be used for new levels");
		}
	}
	function assertLevelComparison(levelComparison) {
		if (typeof levelComparison === "function") return;
		if (
			typeof levelComparison === "string" &&
			Object.values(SORTING_ORDER).includes(levelComparison)
		)
			return;
		throw new Error(
			'Levels comparison should be one of "ASC", "DESC" or "function" type',
		);
	}
	module.exports = {
		initialLsCache,
		genLsCache,
		levelMethods,
		getLevel,
		setLevel,
		isLevelEnabled,
		mappings,
		assertNoLevelCollisions,
		assertDefaultLevelFound,
		genLevelComparison,
		assertLevelComparison,
	};
});
var require_meta = __commonJS((exports, module) => {
	module.exports = { version: "8.21.0" };
});
var require_proto = __commonJS((exports, module) => {
	var { EventEmitter } = __require("events"),
		{
			lsCacheSym,
			levelValSym,
			setLevelSym,
			getLevelSym,
			chindingsSym,
			parsedChindingsSym,
			mixinSym,
			asJsonSym,
			writeSym,
			mixinMergeStrategySym,
			timeSym,
			timeSliceIndexSym,
			streamSym,
			serializersSym,
			formattersSym,
			errorKeySym,
			messageKeySym,
			useOnlyCustomLevelsSym,
			needsMetadataGsym,
			redactFmtSym,
			stringifySym,
			formatOptsSym,
			stringifiersSym,
			msgPrefixSym,
		} = require_symbols(),
		{
			getLevel,
			setLevel,
			isLevelEnabled,
			mappings,
			initialLsCache,
			genLsCache,
			assertNoLevelCollisions,
		} = require_levels(),
		{ asChindings, asJson, buildFormatters, stringify } = require_tools(),
		{ version } = require_meta(),
		redaction = require_redaction(),
		constructor = class Pino {},
		prototype = {
			constructor,
			child,
			bindings,
			setBindings,
			flush,
			isLevelEnabled,
			version,
			get level() {
				return this[getLevelSym]();
			},
			set level(lvl) {
				this[setLevelSym](lvl);
			},
			get levelVal() {
				return this[levelValSym];
			},
			set levelVal(n) {
				throw Error("levelVal is read-only");
			},
			[lsCacheSym]: initialLsCache,
			[writeSym]: write,
			[asJsonSym]: asJson,
			[getLevelSym]: getLevel,
			[setLevelSym]: setLevel,
		};
	Object.setPrototypeOf(prototype, EventEmitter.prototype);
	module.exports = function () {
		return Object.create(prototype);
	};
	var resetChildingsFormatter = (bindings2) => bindings2;
	function child(bindings2, options) {
		if (!bindings2) throw Error("missing bindings for child Pino");
		options = options || {};
		let serializers = this[serializersSym],
			formatters = this[formattersSym],
			instance = Object.create(this);
		if (options.hasOwnProperty("serializers") === !0) {
			instance[serializersSym] = Object.create(null);
			for (let k in serializers) instance[serializersSym][k] = serializers[k];
			let parentSymbols = Object.getOwnPropertySymbols(serializers);
			for (var i = 0; i < parentSymbols.length; i++) {
				let ks = parentSymbols[i];
				instance[serializersSym][ks] = serializers[ks];
			}
			for (let bk in options.serializers)
				instance[serializersSym][bk] = options.serializers[bk];
			let bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
			for (var bi = 0; bi < bindingsSymbols.length; bi++) {
				let bks = bindingsSymbols[bi];
				instance[serializersSym][bks] = options.serializers[bks];
			}
		} else instance[serializersSym] = serializers;
		if (options.hasOwnProperty("formatters")) {
			let { level, bindings: chindings, log } = options.formatters;
			instance[formattersSym] = buildFormatters(
				level || formatters.level,
				chindings || resetChildingsFormatter,
				log || formatters.log,
			);
		} else
			instance[formattersSym] = buildFormatters(
				formatters.level,
				resetChildingsFormatter,
				formatters.log,
			);
		if (options.hasOwnProperty("customLevels") === !0)
			assertNoLevelCollisions(this.levels, options.customLevels),
				(instance.levels = mappings(
					options.customLevels,
					instance[useOnlyCustomLevelsSym],
				)),
				genLsCache(instance);
		if (
			(typeof options.redact === "object" && options.redact !== null) ||
			Array.isArray(options.redact)
		) {
			instance.redact = options.redact;
			let stringifiers = redaction(instance.redact, stringify),
				formatOpts = { stringify: stringifiers[redactFmtSym] };
			(instance[stringifySym] = stringify),
				(instance[stringifiersSym] = stringifiers),
				(instance[formatOptsSym] = formatOpts);
		}
		if (typeof options.msgPrefix === "string")
			instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
		instance[chindingsSym] = asChindings(instance, bindings2);
		let childLevel = options.level || this.level;
		return instance[setLevelSym](childLevel), this.onChild(instance), instance;
	}
	function bindings() {
		let chindingsJson = `{${this[chindingsSym].substr(1)}}`,
			bindingsFromJson = JSON.parse(chindingsJson);
		return (
			delete bindingsFromJson.pid,
			delete bindingsFromJson.hostname,
			bindingsFromJson
		);
	}
	function setBindings(newBindings) {
		let chindings = asChindings(this, newBindings);
		(this[chindingsSym] = chindings), delete this[parsedChindingsSym];
	}
	function defaultMixinMergeStrategy(mergeObject, mixinObject) {
		return Object.assign(mixinObject, mergeObject);
	}
	function write(_obj, msg, num) {
		let t2 = this[timeSym](),
			mixin = this[mixinSym],
			errorKey = this[errorKeySym],
			messageKey = this[messageKeySym],
			mixinMergeStrategy =
				this[mixinMergeStrategySym] || defaultMixinMergeStrategy,
			obj;
		if (_obj === void 0 || _obj === null) obj = {};
		else if (_obj instanceof Error) {
			if (((obj = { [errorKey]: _obj }), msg === void 0)) msg = _obj.message;
		} else if (
			((obj = _obj),
			msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey])
		)
			msg = _obj[errorKey].message;
		if (mixin) obj = mixinMergeStrategy(obj, mixin(obj, num, this));
		let s = this[asJsonSym](obj, msg, num, t2),
			stream = this[streamSym];
		if (stream[needsMetadataGsym] === !0)
			(stream.lastLevel = num),
				(stream.lastObj = obj),
				(stream.lastMsg = msg),
				(stream.lastTime = t2.slice(this[timeSliceIndexSym])),
				(stream.lastLogger = this);
		stream.write(s);
	}
	function noop() {}
	function flush(cb) {
		if (cb != null && typeof cb !== "function")
			throw Error("callback must be a function");
		let stream = this[streamSym];
		if (typeof stream.flush === "function") stream.flush(cb || noop);
		else if (cb) cb();
	}
});
var require_safe_stable_stringify = __commonJS((exports, module) => {
	var { hasOwnProperty } = Object.prototype,
		stringify = configure();
	stringify.configure = configure;
	stringify.stringify = stringify;
	stringify.default = stringify;
	exports.stringify = stringify;
	exports.configure = configure;
	module.exports = stringify;
	var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
	function strEscape(str) {
		if (str.length < 5000 && !strEscapeSequencesRegExp.test(str))
			return `"${str}"`;
		return JSON.stringify(str);
	}
	function sort(array, comparator) {
		if (array.length > 200 || comparator) return array.sort(comparator);
		for (let i = 1; i < array.length; i++) {
			let currentValue = array[i],
				position = i;
			while (position !== 0 && array[position - 1] > currentValue)
				(array[position] = array[position - 1]), position--;
			array[position] = currentValue;
		}
		return array;
	}
	var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
		Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())),
		Symbol.toStringTag,
	).get;
	function isTypedArrayWithEntries(value) {
		return (
			typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 &&
			value.length !== 0
		);
	}
	function stringifyTypedArray(array, separator, maximumBreadth) {
		if (array.length < maximumBreadth) maximumBreadth = array.length;
		let whitespace = separator === "," ? "" : " ",
			res = `"0":${whitespace}${array[0]}`;
		for (let i = 1; i < maximumBreadth; i++)
			res += `${separator}"${i}":${whitespace}${array[i]}`;
		return res;
	}
	function getCircularValueOption(options) {
		if (hasOwnProperty.call(options, "circularValue")) {
			let circularValue = options.circularValue;
			if (typeof circularValue === "string") return `"${circularValue}"`;
			if (circularValue == null) return circularValue;
			if (circularValue === Error || circularValue === TypeError)
				return {
					toString() {
						throw new TypeError("Converting circular structure to JSON");
					},
				};
			throw new TypeError(
				'The "circularValue" argument must be of type string or the value null or undefined',
			);
		}
		return '"[Circular]"';
	}
	function getDeterministicOption(options) {
		let value;
		if (hasOwnProperty.call(options, "deterministic")) {
			if (
				((value = options.deterministic),
				typeof value !== "boolean" && typeof value !== "function")
			)
				throw new TypeError(
					'The "deterministic" argument must be of type boolean or comparator function',
				);
		}
		return value === void 0 ? !0 : value;
	}
	function getBooleanOption(options, key) {
		let value;
		if (hasOwnProperty.call(options, key)) {
			if (((value = options[key]), typeof value !== "boolean"))
				throw new TypeError(`The "${key}" argument must be of type boolean`);
		}
		return value === void 0 ? !0 : value;
	}
	function getPositiveIntegerOption(options, key) {
		let value;
		if (hasOwnProperty.call(options, key)) {
			if (((value = options[key]), typeof value !== "number"))
				throw new TypeError(`The "${key}" argument must be of type number`);
			if (!Number.isInteger(value))
				throw new TypeError(`The "${key}" argument must be an integer`);
			if (value < 1) throw new RangeError(`The "${key}" argument must be >= 1`);
		}
		return value === void 0 ? 1 / 0 : value;
	}
	function getItemCount(number) {
		if (number === 1) return "1 item";
		return `${number} items`;
	}
	function getUniqueReplacerSet(replacerArray) {
		let replacerSet = new Set();
		for (let value of replacerArray)
			if (typeof value === "string" || typeof value === "number")
				replacerSet.add(String(value));
		return replacerSet;
	}
	function getStrictOption(options) {
		if (hasOwnProperty.call(options, "strict")) {
			let value = options.strict;
			if (typeof value !== "boolean")
				throw new TypeError('The "strict" argument must be of type boolean');
			if (value)
				return (value2) => {
					let message = `Object can not safely be stringified. Received type ${typeof value2}`;
					if (typeof value2 !== "function")
						message += ` (${value2.toString()})`;
					throw new Error(message);
				};
		}
	}
	function configure(options) {
		options = { ...options };
		let fail = getStrictOption(options);
		if (fail) {
			if (options.bigint === void 0) options.bigint = !1;
			if (!("circularValue" in options)) options.circularValue = Error;
		}
		let circularValue = getCircularValueOption(options),
			bigint = getBooleanOption(options, "bigint"),
			deterministic = getDeterministicOption(options),
			comparator = typeof deterministic === "function" ? deterministic : void 0,
			maximumDepth = getPositiveIntegerOption(options, "maximumDepth"),
			maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
		function stringifyFnReplacer(
			key,
			parent,
			stack,
			replacer,
			spacer,
			indentation,
		) {
			let value = parent[key];
			if (
				typeof value === "object" &&
				value !== null &&
				typeof value.toJSON === "function"
			)
				value = value.toJSON(key);
			switch (((value = replacer.call(parent, key, value)), typeof value)) {
				case "string":
					return strEscape(value);
				case "object": {
					if (value === null) return "null";
					if (stack.indexOf(value) !== -1) return circularValue;
					let res = "",
						join = ",",
						originalIndentation = indentation;
					if (Array.isArray(value)) {
						if (value.length === 0) return "[]";
						if (maximumDepth < stack.length + 1) return '"[Array]"';
						if ((stack.push(value), spacer !== ""))
							(indentation += spacer),
								(res += `
${indentation}`),
								(join = `,
${indentation}`);
						let maximumValuesToStringify = Math.min(
								value.length,
								maximumBreadth,
							),
							i = 0;
						for (; i < maximumValuesToStringify - 1; i++) {
							let tmp2 = stringifyFnReplacer(
								String(i),
								value,
								stack,
								replacer,
								spacer,
								indentation,
							);
							(res += tmp2 !== void 0 ? tmp2 : "null"), (res += join);
						}
						let tmp = stringifyFnReplacer(
							String(i),
							value,
							stack,
							replacer,
							spacer,
							indentation,
						);
						if (
							((res += tmp !== void 0 ? tmp : "null"),
							value.length - 1 > maximumBreadth)
						) {
							let removedKeys = value.length - maximumBreadth - 1;
							res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
						}
						if (spacer !== "")
							res += `
${originalIndentation}`;
						return stack.pop(), `[${res}]`;
					}
					let keys = Object.keys(value),
						keyLength = keys.length;
					if (keyLength === 0) return "{}";
					if (maximumDepth < stack.length + 1) return '"[Object]"';
					let whitespace = "",
						separator = "";
					if (spacer !== "")
						(indentation += spacer),
							(join = `,
${indentation}`),
							(whitespace = " ");
					let maximumPropertiesToStringify = Math.min(
						keyLength,
						maximumBreadth,
					);
					if (deterministic && !isTypedArrayWithEntries(value))
						keys = sort(keys, comparator);
					stack.push(value);
					for (let i = 0; i < maximumPropertiesToStringify; i++) {
						let key2 = keys[i],
							tmp = stringifyFnReplacer(
								key2,
								value,
								stack,
								replacer,
								spacer,
								indentation,
							);
						if (tmp !== void 0)
							(res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`),
								(separator = join);
					}
					if (keyLength > maximumBreadth) {
						let removedKeys = keyLength - maximumBreadth;
						(res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`),
							(separator = join);
					}
					if (spacer !== "" && separator.length > 1)
						res = `
${indentation}${res}
${originalIndentation}`;
					return stack.pop(), `{${res}}`;
				}
				case "number":
					return isFinite(value) ? String(value) : fail ? fail(value) : "null";
				case "boolean":
					return value === !0 ? "true" : "false";
				case "undefined":
					return;
				case "bigint":
					if (bigint) return String(value);
				default:
					return fail ? fail(value) : void 0;
			}
		}
		function stringifyArrayReplacer(
			key,
			value,
			stack,
			replacer,
			spacer,
			indentation,
		) {
			if (
				typeof value === "object" &&
				value !== null &&
				typeof value.toJSON === "function"
			)
				value = value.toJSON(key);
			switch (typeof value) {
				case "string":
					return strEscape(value);
				case "object": {
					if (value === null) return "null";
					if (stack.indexOf(value) !== -1) return circularValue;
					let originalIndentation = indentation,
						res = "",
						join = ",";
					if (Array.isArray(value)) {
						if (value.length === 0) return "[]";
						if (maximumDepth < stack.length + 1) return '"[Array]"';
						if ((stack.push(value), spacer !== ""))
							(indentation += spacer),
								(res += `
${indentation}`),
								(join = `,
${indentation}`);
						let maximumValuesToStringify = Math.min(
								value.length,
								maximumBreadth,
							),
							i = 0;
						for (; i < maximumValuesToStringify - 1; i++) {
							let tmp2 = stringifyArrayReplacer(
								String(i),
								value[i],
								stack,
								replacer,
								spacer,
								indentation,
							);
							(res += tmp2 !== void 0 ? tmp2 : "null"), (res += join);
						}
						let tmp = stringifyArrayReplacer(
							String(i),
							value[i],
							stack,
							replacer,
							spacer,
							indentation,
						);
						if (
							((res += tmp !== void 0 ? tmp : "null"),
							value.length - 1 > maximumBreadth)
						) {
							let removedKeys = value.length - maximumBreadth - 1;
							res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
						}
						if (spacer !== "")
							res += `
${originalIndentation}`;
						return stack.pop(), `[${res}]`;
					}
					stack.push(value);
					let whitespace = "";
					if (spacer !== "")
						(indentation += spacer),
							(join = `,
${indentation}`),
							(whitespace = " ");
					let separator = "";
					for (let key2 of replacer) {
						let tmp = stringifyArrayReplacer(
							key2,
							value[key2],
							stack,
							replacer,
							spacer,
							indentation,
						);
						if (tmp !== void 0)
							(res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`),
								(separator = join);
					}
					if (spacer !== "" && separator.length > 1)
						res = `
${indentation}${res}
${originalIndentation}`;
					return stack.pop(), `{${res}}`;
				}
				case "number":
					return isFinite(value) ? String(value) : fail ? fail(value) : "null";
				case "boolean":
					return value === !0 ? "true" : "false";
				case "undefined":
					return;
				case "bigint":
					if (bigint) return String(value);
				default:
					return fail ? fail(value) : void 0;
			}
		}
		function stringifyIndent(key, value, stack, spacer, indentation) {
			switch (typeof value) {
				case "string":
					return strEscape(value);
				case "object": {
					if (value === null) return "null";
					if (typeof value.toJSON === "function") {
						if (((value = value.toJSON(key)), typeof value !== "object"))
							return stringifyIndent(key, value, stack, spacer, indentation);
						if (value === null) return "null";
					}
					if (stack.indexOf(value) !== -1) return circularValue;
					let originalIndentation = indentation;
					if (Array.isArray(value)) {
						if (value.length === 0) return "[]";
						if (maximumDepth < stack.length + 1) return '"[Array]"';
						stack.push(value), (indentation += spacer);
						let res2 = `
${indentation}`,
							join2 = `,
${indentation}`,
							maximumValuesToStringify = Math.min(value.length, maximumBreadth),
							i = 0;
						for (; i < maximumValuesToStringify - 1; i++) {
							let tmp2 = stringifyIndent(
								String(i),
								value[i],
								stack,
								spacer,
								indentation,
							);
							(res2 += tmp2 !== void 0 ? tmp2 : "null"), (res2 += join2);
						}
						let tmp = stringifyIndent(
							String(i),
							value[i],
							stack,
							spacer,
							indentation,
						);
						if (
							((res2 += tmp !== void 0 ? tmp : "null"),
							value.length - 1 > maximumBreadth)
						) {
							let removedKeys = value.length - maximumBreadth - 1;
							res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
						}
						return (
							(res2 += `
${originalIndentation}`),
							stack.pop(),
							`[${res2}]`
						);
					}
					let keys = Object.keys(value),
						keyLength = keys.length;
					if (keyLength === 0) return "{}";
					if (maximumDepth < stack.length + 1) return '"[Object]"';
					indentation += spacer;
					let join = `,
${indentation}`,
						res = "",
						separator = "",
						maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
					if (isTypedArrayWithEntries(value))
						(res += stringifyTypedArray(value, join, maximumBreadth)),
							(keys = keys.slice(value.length)),
							(maximumPropertiesToStringify -= value.length),
							(separator = join);
					if (deterministic) keys = sort(keys, comparator);
					stack.push(value);
					for (let i = 0; i < maximumPropertiesToStringify; i++) {
						let key2 = keys[i],
							tmp = stringifyIndent(
								key2,
								value[key2],
								stack,
								spacer,
								indentation,
							);
						if (tmp !== void 0)
							(res += `${separator}${strEscape(key2)}: ${tmp}`),
								(separator = join);
					}
					if (keyLength > maximumBreadth) {
						let removedKeys = keyLength - maximumBreadth;
						(res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`),
							(separator = join);
					}
					if (separator !== "")
						res = `
${indentation}${res}
${originalIndentation}`;
					return stack.pop(), `{${res}}`;
				}
				case "number":
					return isFinite(value) ? String(value) : fail ? fail(value) : "null";
				case "boolean":
					return value === !0 ? "true" : "false";
				case "undefined":
					return;
				case "bigint":
					if (bigint) return String(value);
				default:
					return fail ? fail(value) : void 0;
			}
		}
		function stringifySimple(key, value, stack) {
			switch (typeof value) {
				case "string":
					return strEscape(value);
				case "object": {
					if (value === null) return "null";
					if (typeof value.toJSON === "function") {
						if (((value = value.toJSON(key)), typeof value !== "object"))
							return stringifySimple(key, value, stack);
						if (value === null) return "null";
					}
					if (stack.indexOf(value) !== -1) return circularValue;
					let res = "",
						hasLength = value.length !== void 0;
					if (hasLength && Array.isArray(value)) {
						if (value.length === 0) return "[]";
						if (maximumDepth < stack.length + 1) return '"[Array]"';
						stack.push(value);
						let maximumValuesToStringify = Math.min(
								value.length,
								maximumBreadth,
							),
							i = 0;
						for (; i < maximumValuesToStringify - 1; i++) {
							let tmp2 = stringifySimple(String(i), value[i], stack);
							(res += tmp2 !== void 0 ? tmp2 : "null"), (res += ",");
						}
						let tmp = stringifySimple(String(i), value[i], stack);
						if (
							((res += tmp !== void 0 ? tmp : "null"),
							value.length - 1 > maximumBreadth)
						) {
							let removedKeys = value.length - maximumBreadth - 1;
							res += `,"... ${getItemCount(removedKeys)} not stringified"`;
						}
						return stack.pop(), `[${res}]`;
					}
					let keys = Object.keys(value),
						keyLength = keys.length;
					if (keyLength === 0) return "{}";
					if (maximumDepth < stack.length + 1) return '"[Object]"';
					let separator = "",
						maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
					if (hasLength && isTypedArrayWithEntries(value))
						(res += stringifyTypedArray(value, ",", maximumBreadth)),
							(keys = keys.slice(value.length)),
							(maximumPropertiesToStringify -= value.length),
							(separator = ",");
					if (deterministic) keys = sort(keys, comparator);
					stack.push(value);
					for (let i = 0; i < maximumPropertiesToStringify; i++) {
						let key2 = keys[i],
							tmp = stringifySimple(key2, value[key2], stack);
						if (tmp !== void 0)
							(res += `${separator}${strEscape(key2)}:${tmp}`),
								(separator = ",");
					}
					if (keyLength > maximumBreadth) {
						let removedKeys = keyLength - maximumBreadth;
						res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
					}
					return stack.pop(), `{${res}}`;
				}
				case "number":
					return isFinite(value) ? String(value) : fail ? fail(value) : "null";
				case "boolean":
					return value === !0 ? "true" : "false";
				case "undefined":
					return;
				case "bigint":
					if (bigint) return String(value);
				default:
					return fail ? fail(value) : void 0;
			}
		}
		function stringify2(value, replacer, space) {
			if (arguments.length > 1) {
				let spacer = "";
				if (typeof space === "number") spacer = " ".repeat(Math.min(space, 10));
				else if (typeof space === "string") spacer = space.slice(0, 10);
				if (replacer != null) {
					if (typeof replacer === "function")
						return stringifyFnReplacer(
							"",
							{ "": value },
							[],
							replacer,
							spacer,
							"",
						);
					if (Array.isArray(replacer))
						return stringifyArrayReplacer(
							"",
							value,
							[],
							getUniqueReplacerSet(replacer),
							spacer,
							"",
						);
				}
				if (spacer.length !== 0)
					return stringifyIndent("", value, [], spacer, "");
			}
			return stringifySimple("", value, []);
		}
		return stringify2;
	}
});
var require_multistream = __commonJS((exports, module) => {
	var metadata = Symbol.for("pino.metadata"),
		{ DEFAULT_LEVELS } = require_constants2(),
		DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
	function multistream(streamsArray, opts) {
		let counter = 0;
		(streamsArray = streamsArray || []), (opts = opts || { dedupe: !1 });
		let streamLevels = Object.create(DEFAULT_LEVELS);
		if (
			((streamLevels.silent = 1 / 0),
			opts.levels && typeof opts.levels === "object")
		)
			Object.keys(opts.levels).forEach((i) => {
				streamLevels[i] = opts.levels[i];
			});
		let res = {
			write,
			add,
			emit,
			flushSync,
			end,
			minLevel: 0,
			streams: [],
			clone: clone2,
			[metadata]: !0,
			streamLevels,
		};
		if (Array.isArray(streamsArray)) streamsArray.forEach(add, res);
		else add.call(res, streamsArray);
		return (streamsArray = null), res;
		function write(data) {
			let dest,
				level = this.lastLevel,
				{ streams } = this,
				recordedLevel = 0,
				stream;
			for (
				let i = initLoopVar(streams.length, opts.dedupe);
				checkLoopVar(i, streams.length, opts.dedupe);
				i = adjustLoopVar(i, opts.dedupe)
			)
				if (((dest = streams[i]), dest.level <= level)) {
					if (recordedLevel !== 0 && recordedLevel !== dest.level) break;
					if (((stream = dest.stream), stream[metadata])) {
						let { lastTime, lastMsg, lastObj, lastLogger } = this;
						(stream.lastLevel = level),
							(stream.lastTime = lastTime),
							(stream.lastMsg = lastMsg),
							(stream.lastObj = lastObj),
							(stream.lastLogger = lastLogger);
					}
					if ((stream.write(data), opts.dedupe)) recordedLevel = dest.level;
				} else if (!opts.dedupe) break;
		}
		function emit(...args) {
			for (let { stream } of this.streams)
				if (typeof stream.emit === "function") stream.emit(...args);
		}
		function flushSync() {
			for (let { stream } of this.streams)
				if (typeof stream.flushSync === "function") stream.flushSync();
		}
		function add(dest) {
			if (!dest) return res;
			let isStream = typeof dest.write === "function" || dest.stream,
				stream_ = dest.write ? dest : dest.stream;
			if (!isStream)
				throw Error(
					"stream object needs to implement either StreamEntry or DestinationStream interface",
				);
			let { streams, streamLevels: streamLevels2 } = this,
				level;
			if (typeof dest.levelVal === "number") level = dest.levelVal;
			else if (typeof dest.level === "string")
				level = streamLevels2[dest.level];
			else if (typeof dest.level === "number") level = dest.level;
			else level = DEFAULT_INFO_LEVEL;
			let dest_ = { stream: stream_, level, levelVal: void 0, id: counter++ };
			return (
				streams.unshift(dest_),
				streams.sort(compareByLevel),
				(this.minLevel = streams[0].level),
				res
			);
		}
		function end() {
			for (let { stream } of this.streams) {
				if (typeof stream.flushSync === "function") stream.flushSync();
				stream.end();
			}
		}
		function clone2(level) {
			let streams = new Array(this.streams.length);
			for (let i = 0; i < streams.length; i++)
				streams[i] = { level, stream: this.streams[i].stream };
			return {
				write,
				add,
				minLevel: level,
				streams,
				clone: clone2,
				emit,
				flushSync,
				[metadata]: !0,
			};
		}
	}
	function compareByLevel(a, b) {
		return a.level - b.level;
	}
	function initLoopVar(length, dedupe) {
		return dedupe ? length - 1 : 0;
	}
	function adjustLoopVar(i, dedupe) {
		return dedupe ? i - 1 : i + 1;
	}
	function checkLoopVar(i, length, dedupe) {
		return dedupe ? i >= 0 : i < length;
	}
	module.exports = multistream;
});
var require_pino = __commonJS((exports, module) => {
	var os = __require("os"),
		stdSerializers = require_pino_std_serializers(),
		caller = require_caller(),
		redaction = require_redaction(),
		time = require_time(),
		proto = require_proto(),
		symbols = require_symbols(),
		{ configure } = require_safe_stable_stringify(),
		{
			assertDefaultLevelFound,
			mappings,
			genLsCache,
			genLevelComparison,
			assertLevelComparison,
		} = require_levels(),
		{ DEFAULT_LEVELS, SORTING_ORDER } = require_constants2(),
		{
			createArgsNormalizer,
			asChindings,
			buildSafeSonicBoom,
			buildFormatters,
			stringify,
			normalizeDestFileDescriptor,
			noop,
		} = require_tools(),
		{ version } = require_meta(),
		{
			chindingsSym,
			redactFmtSym,
			serializersSym,
			timeSym,
			timeSliceIndexSym,
			streamSym,
			stringifySym,
			stringifySafeSym,
			stringifiersSym,
			setLevelSym,
			endSym,
			formatOptsSym,
			messageKeySym,
			errorKeySym,
			nestedKeySym,
			mixinSym,
			levelCompSym,
			useOnlyCustomLevelsSym,
			formattersSym,
			hooksSym,
			nestedKeyStrSym,
			mixinMergeStrategySym,
			msgPrefixSym,
		} = symbols,
		{ epochTime, nullTime } = time,
		{ pid } = process,
		hostname = os.hostname(),
		defaultErrorSerializer = stdSerializers.err,
		defaultOptions = {
			level: "info",
			levelComparison: SORTING_ORDER.ASC,
			levels: DEFAULT_LEVELS,
			messageKey: "msg",
			errorKey: "err",
			nestedKey: null,
			enabled: !0,
			base: { pid, hostname },
			serializers: Object.assign(Object.create(null), {
				err: defaultErrorSerializer,
			}),
			formatters: Object.assign(Object.create(null), {
				bindings(bindings) {
					return bindings;
				},
				level(label, number) {
					return { level: number };
				},
			}),
			hooks: { logMethod: void 0 },
			timestamp: epochTime,
			name: void 0,
			redact: null,
			customLevels: null,
			useOnlyCustomLevels: !1,
			depthLimit: 5,
			edgeLimit: 100,
		},
		normalize = createArgsNormalizer(defaultOptions),
		serializers = Object.assign(Object.create(null), stdSerializers);
	function pino(...args) {
		let instance = {},
			{ opts, stream } = normalize(instance, caller(), ...args),
			{
				redact,
				crlf,
				serializers: serializers2,
				timestamp,
				messageKey,
				errorKey,
				nestedKey,
				base,
				name,
				level,
				customLevels,
				levelComparison,
				mixin,
				mixinMergeStrategy,
				useOnlyCustomLevels,
				formatters,
				hooks,
				depthLimit,
				edgeLimit,
				onChild,
				msgPrefix,
			} = opts,
			stringifySafe = configure({
				maximumDepth: depthLimit,
				maximumBreadth: edgeLimit,
			}),
			allFormatters = buildFormatters(
				formatters.level,
				formatters.bindings,
				formatters.log,
			),
			stringifyFn = stringify.bind({ [stringifySafeSym]: stringifySafe }),
			stringifiers = redact ? redaction(redact, stringifyFn) : {},
			formatOpts = redact
				? { stringify: stringifiers[redactFmtSym] }
				: { stringify: stringifyFn },
			end =
				"}" +
				(crlf
					? `\r
`
					: `
`),
			coreChindings = asChindings.bind(null, {
				[chindingsSym]: "",
				[serializersSym]: serializers2,
				[stringifiersSym]: stringifiers,
				[stringifySym]: stringify,
				[stringifySafeSym]: stringifySafe,
				[formattersSym]: allFormatters,
			}),
			chindings = "";
		if (base !== null)
			if (name === void 0) chindings = coreChindings(base);
			else chindings = coreChindings(Object.assign({}, base, { name }));
		let time2 =
				timestamp instanceof Function
					? timestamp
					: timestamp
						? epochTime
						: nullTime,
			timeSliceIndex = time2().indexOf(":") + 1;
		if (useOnlyCustomLevels && !customLevels)
			throw Error(
				"customLevels is required if useOnlyCustomLevels is set true",
			);
		if (mixin && typeof mixin !== "function")
			throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
		if (msgPrefix && typeof msgPrefix !== "string")
			throw Error(
				`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`,
			);
		assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
		let levels = mappings(customLevels, useOnlyCustomLevels);
		if (typeof stream.emit === "function")
			stream.emit("message", {
				code: "PINO_CONFIG",
				config: { levels, messageKey, errorKey },
			});
		assertLevelComparison(levelComparison);
		let levelCompFunc = genLevelComparison(levelComparison);
		return (
			Object.assign(instance, {
				levels,
				[levelCompSym]: levelCompFunc,
				[useOnlyCustomLevelsSym]: useOnlyCustomLevels,
				[streamSym]: stream,
				[timeSym]: time2,
				[timeSliceIndexSym]: timeSliceIndex,
				[stringifySym]: stringify,
				[stringifySafeSym]: stringifySafe,
				[stringifiersSym]: stringifiers,
				[endSym]: end,
				[formatOptsSym]: formatOpts,
				[messageKeySym]: messageKey,
				[errorKeySym]: errorKey,
				[nestedKeySym]: nestedKey,
				[nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
				[serializersSym]: serializers2,
				[mixinSym]: mixin,
				[mixinMergeStrategySym]: mixinMergeStrategy,
				[chindingsSym]: chindings,
				[formattersSym]: allFormatters,
				[hooksSym]: hooks,
				silent: noop,
				onChild,
				[msgPrefixSym]: msgPrefix,
			}),
			Object.setPrototypeOf(instance, proto()),
			genLsCache(instance),
			instance[setLevelSym](level),
			instance
		);
	}
	module.exports = pino;
	module.exports.destination = (dest = process.stdout.fd) => {
		if (typeof dest === "object")
			return (
				(dest.dest = normalizeDestFileDescriptor(
					dest.dest || process.stdout.fd,
				)),
				buildSafeSonicBoom(dest)
			);
		else
			return buildSafeSonicBoom({
				dest: normalizeDestFileDescriptor(dest),
				minLength: 0,
			});
	};
	module.exports.transport = require_transport();
	module.exports.multistream = require_multistream();
	module.exports.levels = mappings();
	module.exports.stdSerializers = serializers;
	module.exports.stdTimeFunctions = Object.assign({}, time);
	module.exports.symbols = symbols;
	module.exports.version = version;
	module.exports.default = pino;
	module.exports.pino = pino;
});
var require_secure_json_parse = __commonJS((exports, module) => {
	var hasBuffer = typeof Buffer !== "undefined",
		suspectProtoRx =
			/"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/,
		suspectConstructorRx =
			/"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
	function _parse(text, reviver, options) {
		if (options == null) {
			if (reviver !== null && typeof reviver === "object")
				(options = reviver), (reviver = void 0);
		}
		if (hasBuffer && Buffer.isBuffer(text)) text = text.toString();
		if (text && text.charCodeAt(0) === 65279) text = text.slice(1);
		let obj = JSON.parse(text, reviver);
		if (obj === null || typeof obj !== "object") return obj;
		let protoAction = (options && options.protoAction) || "error",
			constructorAction = (options && options.constructorAction) || "error";
		if (protoAction === "ignore" && constructorAction === "ignore") return obj;
		if (protoAction !== "ignore" && constructorAction !== "ignore") {
			if (
				suspectProtoRx.test(text) === !1 &&
				suspectConstructorRx.test(text) === !1
			)
				return obj;
		} else if (protoAction !== "ignore" && constructorAction === "ignore") {
			if (suspectProtoRx.test(text) === !1) return obj;
		} else if (suspectConstructorRx.test(text) === !1) return obj;
		return filter(obj, {
			protoAction,
			constructorAction,
			safe: options && options.safe,
		});
	}
	function filter(
		obj,
		{ protoAction = "error", constructorAction = "error", safe } = {},
	) {
		let next2 = [obj];
		while (next2.length) {
			let nodes = next2;
			next2 = [];
			for (let node of nodes) {
				if (
					protoAction !== "ignore" &&
					Object.prototype.hasOwnProperty.call(node, "__proto__")
				) {
					if (safe === !0) return null;
					else if (protoAction === "error")
						throw new SyntaxError(
							"Object contains forbidden prototype property",
						);
					delete node.__proto__;
				}
				if (
					constructorAction !== "ignore" &&
					Object.prototype.hasOwnProperty.call(node, "constructor") &&
					Object.prototype.hasOwnProperty.call(node.constructor, "prototype")
				) {
					if (safe === !0) return null;
					else if (constructorAction === "error")
						throw new SyntaxError(
							"Object contains forbidden prototype property",
						);
					delete node.constructor;
				}
				for (let key in node) {
					let value = node[key];
					if (value && typeof value === "object") next2.push(value);
				}
			}
		}
		return obj;
	}
	function parse3(text, reviver, options) {
		let stackTraceLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 0;
		try {
			return _parse(text, reviver, options);
		} finally {
			Error.stackTraceLimit = stackTraceLimit;
		}
	}
	function safeParse(text, reviver) {
		let stackTraceLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 0;
		try {
			return _parse(text, reviver, { safe: !0 });
		} catch (_e) {
			return null;
		} finally {
			Error.stackTraceLimit = stackTraceLimit;
		}
	}
	module.exports = parse3;
	module.exports.default = parse3;
	module.exports.parse = parse3;
	module.exports.safeParse = safeParse;
	module.exports.scan = filter;
});
var require_globalThis = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports._globalThis = void 0;
	exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});
var require_node = __commonJS((exports) => {
	var __createBinding =
			(exports && exports.__createBinding) ||
			(Object.create
				? function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						Object.defineProperty(o, k2, {
							enumerable: !0,
							get: function () {
								return m[k];
							},
						});
					}
				: function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						o[k2] = m[k];
					}),
		__exportStar =
			(exports && exports.__exportStar) ||
			function (m, exports2) {
				for (var p in m)
					if (
						p !== "default" &&
						!Object.prototype.hasOwnProperty.call(exports2, p)
					)
						__createBinding(exports2, m, p);
			};
	Object.defineProperty(exports, "__esModule", { value: !0 });
	__exportStar(require_globalThis(), exports);
});
var require_platform = __commonJS((exports) => {
	var __createBinding =
			(exports && exports.__createBinding) ||
			(Object.create
				? function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						Object.defineProperty(o, k2, {
							enumerable: !0,
							get: function () {
								return m[k];
							},
						});
					}
				: function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						o[k2] = m[k];
					}),
		__exportStar =
			(exports && exports.__exportStar) ||
			function (m, exports2) {
				for (var p in m)
					if (
						p !== "default" &&
						!Object.prototype.hasOwnProperty.call(exports2, p)
					)
						__createBinding(exports2, m, p);
			};
	Object.defineProperty(exports, "__esModule", { value: !0 });
	__exportStar(require_node(), exports);
});
var require_version = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.VERSION = void 0;
	exports.VERSION = "1.9.0";
});
var require_semver3 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.isCompatible = exports._makeCompatibilityCheck = void 0;
	var version_1 = require_version(),
		re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
	function _makeCompatibilityCheck(ownVersion) {
		let acceptedVersions = new Set([ownVersion]),
			rejectedVersions = new Set(),
			myVersionMatch = ownVersion.match(re);
		if (!myVersionMatch) return () => !1;
		let ownVersionParsed = {
			major: +myVersionMatch[1],
			minor: +myVersionMatch[2],
			patch: +myVersionMatch[3],
			prerelease: myVersionMatch[4],
		};
		if (ownVersionParsed.prerelease != null)
			return function isExactmatch(globalVersion) {
				return globalVersion === ownVersion;
			};
		function _reject(v) {
			return rejectedVersions.add(v), !1;
		}
		function _accept(v) {
			return acceptedVersions.add(v), !0;
		}
		return function isCompatible(globalVersion) {
			if (acceptedVersions.has(globalVersion)) return !0;
			if (rejectedVersions.has(globalVersion)) return !1;
			let globalVersionMatch = globalVersion.match(re);
			if (!globalVersionMatch) return _reject(globalVersion);
			let globalVersionParsed = {
				major: +globalVersionMatch[1],
				minor: +globalVersionMatch[2],
				patch: +globalVersionMatch[3],
				prerelease: globalVersionMatch[4],
			};
			if (globalVersionParsed.prerelease != null) return _reject(globalVersion);
			if (ownVersionParsed.major !== globalVersionParsed.major)
				return _reject(globalVersion);
			if (ownVersionParsed.major === 0) {
				if (
					ownVersionParsed.minor === globalVersionParsed.minor &&
					ownVersionParsed.patch <= globalVersionParsed.patch
				)
					return _accept(globalVersion);
				return _reject(globalVersion);
			}
			if (ownVersionParsed.minor <= globalVersionParsed.minor)
				return _accept(globalVersion);
			return _reject(globalVersion);
		};
	}
	exports._makeCompatibilityCheck = _makeCompatibilityCheck;
	exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});
var require_global_utils = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.unregisterGlobal =
		exports.getGlobal =
		exports.registerGlobal =
			void 0;
	var platform_1 = require_platform(),
		version_1 = require_version(),
		semver_1 = require_semver3(),
		major = version_1.VERSION.split(".")[0],
		GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`),
		_global = platform_1._globalThis;
	function registerGlobal(type2, instance, diag, allowOverride = !1) {
		var _a15;
		let api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] =
			(_a15 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a15 !== void 0
				? _a15
				: { version: version_1.VERSION });
		if (!allowOverride && api[type2]) {
			let err = new Error(
				`@opentelemetry/api: Attempted duplicate registration of API: ${type2}`,
			);
			return diag.error(err.stack || err.message), !1;
		}
		if (api.version !== version_1.VERSION) {
			let err = new Error(
				`@opentelemetry/api: Registration of version v${api.version} for ${type2} does not match previously registered API v${version_1.VERSION}`,
			);
			return diag.error(err.stack || err.message), !1;
		}
		return (
			(api[type2] = instance),
			diag.debug(
				`@opentelemetry/api: Registered a global for ${type2} v${version_1.VERSION}.`,
			),
			!0
		);
	}
	exports.registerGlobal = registerGlobal;
	function getGlobal(type2) {
		var _a15, _b;
		let globalVersion =
			(_a15 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a15 === void 0
				? void 0
				: _a15.version;
		if (!globalVersion || !semver_1.isCompatible(globalVersion)) return;
		return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null ||
			_b === void 0
			? void 0
			: _b[type2];
	}
	exports.getGlobal = getGlobal;
	function unregisterGlobal(type2, diag) {
		diag.debug(
			`@opentelemetry/api: Unregistering a global for ${type2} v${version_1.VERSION}.`,
		);
		let api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
		if (api) delete api[type2];
	}
	exports.unregisterGlobal = unregisterGlobal;
});
var require_ComponentLogger = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.DiagComponentLogger = void 0;
	var global_utils_1 = require_global_utils();
	class DiagComponentLogger {
		constructor(props) {
			this._namespace = props.namespace || "DiagComponentLogger";
		}
		debug(...args) {
			return logProxy("debug", this._namespace, args);
		}
		error(...args) {
			return logProxy("error", this._namespace, args);
		}
		info(...args) {
			return logProxy("info", this._namespace, args);
		}
		warn(...args) {
			return logProxy("warn", this._namespace, args);
		}
		verbose(...args) {
			return logProxy("verbose", this._namespace, args);
		}
	}
	exports.DiagComponentLogger = DiagComponentLogger;
	function logProxy(funcName, namespace, args) {
		let logger = global_utils_1.getGlobal("diag");
		if (!logger) return;
		return args.unshift(namespace), logger[funcName](...args);
	}
});
var require_types = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.DiagLogLevel = void 0;
	var DiagLogLevel;
	(function (DiagLogLevel2) {
		(DiagLogLevel2[(DiagLogLevel2.NONE = 0)] = "NONE"),
			(DiagLogLevel2[(DiagLogLevel2.ERROR = 30)] = "ERROR"),
			(DiagLogLevel2[(DiagLogLevel2.WARN = 50)] = "WARN"),
			(DiagLogLevel2[(DiagLogLevel2.INFO = 60)] = "INFO"),
			(DiagLogLevel2[(DiagLogLevel2.DEBUG = 70)] = "DEBUG"),
			(DiagLogLevel2[(DiagLogLevel2.VERBOSE = 80)] = "VERBOSE"),
			(DiagLogLevel2[(DiagLogLevel2.ALL = 9999)] = "ALL");
	})((DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {})));
});
var require_logLevelLogger = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.createLogLevelDiagLogger = void 0;
	var types_1 = require_types();
	function createLogLevelDiagLogger(maxLevel, logger) {
		if (maxLevel < types_1.DiagLogLevel.NONE)
			maxLevel = types_1.DiagLogLevel.NONE;
		else if (maxLevel > types_1.DiagLogLevel.ALL)
			maxLevel = types_1.DiagLogLevel.ALL;
		logger = logger || {};
		function _filterFunc(funcName, theLevel) {
			let theFunc = logger[funcName];
			if (typeof theFunc === "function" && maxLevel >= theLevel)
				return theFunc.bind(logger);
			return function () {};
		}
		return {
			error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
			warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
			info: _filterFunc("info", types_1.DiagLogLevel.INFO),
			debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
			verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE),
		};
	}
	exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});
var require_diag = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.DiagAPI = void 0;
	var ComponentLogger_1 = require_ComponentLogger(),
		logLevelLogger_1 = require_logLevelLogger(),
		types_1 = require_types(),
		global_utils_1 = require_global_utils(),
		API_NAME = "diag";
	class DiagAPI {
		constructor() {
			function _logProxy(funcName) {
				return function (...args) {
					let logger = global_utils_1.getGlobal("diag");
					if (!logger) return;
					return logger[funcName](...args);
				};
			}
			let self = this,
				setLogger = (
					logger,
					optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO },
				) => {
					var _a15, _b, _c;
					if (logger === self) {
						let err = new Error(
							"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation",
						);
						return (
							self.error(
								(_a15 = err.stack) !== null && _a15 !== void 0
									? _a15
									: err.message,
							),
							!1
						);
					}
					if (typeof optionsOrLogLevel === "number")
						optionsOrLogLevel = { logLevel: optionsOrLogLevel };
					let oldLogger = global_utils_1.getGlobal("diag"),
						newLogger = logLevelLogger_1.createLogLevelDiagLogger(
							(_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0
								? _b
								: types_1.DiagLogLevel.INFO,
							logger,
						);
					if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
						let stack =
							(_c = new Error().stack) !== null && _c !== void 0
								? _c
								: "<failed to generate stacktrace>";
						oldLogger.warn(`Current logger will be overwritten from ${stack}`),
							newLogger.warn(
								`Current logger will overwrite one already registered from ${stack}`,
							);
					}
					return global_utils_1.registerGlobal("diag", newLogger, self, !0);
				};
			(self.setLogger = setLogger),
				(self.disable = () => {
					global_utils_1.unregisterGlobal(API_NAME, self);
				}),
				(self.createComponentLogger = (options) => {
					return new ComponentLogger_1.DiagComponentLogger(options);
				}),
				(self.verbose = _logProxy("verbose")),
				(self.debug = _logProxy("debug")),
				(self.info = _logProxy("info")),
				(self.warn = _logProxy("warn")),
				(self.error = _logProxy("error"));
		}
		static instance() {
			if (!this._instance) this._instance = new DiagAPI();
			return this._instance;
		}
	}
	exports.DiagAPI = DiagAPI;
});
var require_baggage_impl = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.BaggageImpl = void 0;
	class BaggageImpl {
		constructor(entries) {
			this._entries = entries ? new Map(entries) : new Map();
		}
		getEntry(key) {
			let entry = this._entries.get(key);
			if (!entry) return;
			return Object.assign({}, entry);
		}
		getAllEntries() {
			return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
		}
		setEntry(key, entry) {
			let newBaggage = new BaggageImpl(this._entries);
			return newBaggage._entries.set(key, entry), newBaggage;
		}
		removeEntry(key) {
			let newBaggage = new BaggageImpl(this._entries);
			return newBaggage._entries.delete(key), newBaggage;
		}
		removeEntries(...keys) {
			let newBaggage = new BaggageImpl(this._entries);
			for (let key of keys) newBaggage._entries.delete(key);
			return newBaggage;
		}
		clear() {
			return new BaggageImpl();
		}
	}
	exports.BaggageImpl = BaggageImpl;
});
var require_symbol = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.baggageEntryMetadataSymbol = void 0;
	exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});
var require_utils = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
	var diag_1 = require_diag(),
		baggage_impl_1 = require_baggage_impl(),
		symbol_1 = require_symbol(),
		diag = diag_1.DiagAPI.instance();
	function createBaggage(entries = {}) {
		return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
	}
	exports.createBaggage = createBaggage;
	function baggageEntryMetadataFromString(str) {
		if (typeof str !== "string")
			diag.error(
				`Cannot create baggage metadata from unknown type: ${typeof str}`,
			),
				(str = "");
		return {
			__TYPE__: symbol_1.baggageEntryMetadataSymbol,
			toString() {
				return str;
			},
		};
	}
	exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});
var require_context = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.ROOT_CONTEXT = exports.createContextKey = void 0;
	function createContextKey(description) {
		return Symbol.for(description);
	}
	exports.createContextKey = createContextKey;
	class BaseContext {
		constructor(parentContext) {
			let self = this;
			(self._currentContext = parentContext
				? new Map(parentContext)
				: new Map()),
				(self.getValue = (key) => self._currentContext.get(key)),
				(self.setValue = (key, value) => {
					let context = new BaseContext(self._currentContext);
					return context._currentContext.set(key, value), context;
				}),
				(self.deleteValue = (key) => {
					let context = new BaseContext(self._currentContext);
					return context._currentContext.delete(key), context;
				});
		}
	}
	exports.ROOT_CONTEXT = new BaseContext();
});
var require_consoleLogger = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.DiagConsoleLogger = void 0;
	var consoleMap = [
		{ n: "error", c: "error" },
		{ n: "warn", c: "warn" },
		{ n: "info", c: "info" },
		{ n: "debug", c: "debug" },
		{ n: "verbose", c: "trace" },
	];
	class DiagConsoleLogger {
		constructor() {
			function _consoleFunc(funcName) {
				return function (...args) {
					if (console) {
						let theFunc = console[funcName];
						if (typeof theFunc !== "function") theFunc = console.log;
						if (typeof theFunc === "function")
							return theFunc.apply(console, args);
					}
				};
			}
			for (let i = 0; i < consoleMap.length; i++)
				this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
		}
	}
	exports.DiagConsoleLogger = DiagConsoleLogger;
});
var require_NoopMeter = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.createNoopMeter =
		exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
		exports.NOOP_OBSERVABLE_GAUGE_METRIC =
		exports.NOOP_OBSERVABLE_COUNTER_METRIC =
		exports.NOOP_UP_DOWN_COUNTER_METRIC =
		exports.NOOP_HISTOGRAM_METRIC =
		exports.NOOP_GAUGE_METRIC =
		exports.NOOP_COUNTER_METRIC =
		exports.NOOP_METER =
		exports.NoopObservableUpDownCounterMetric =
		exports.NoopObservableGaugeMetric =
		exports.NoopObservableCounterMetric =
		exports.NoopObservableMetric =
		exports.NoopHistogramMetric =
		exports.NoopGaugeMetric =
		exports.NoopUpDownCounterMetric =
		exports.NoopCounterMetric =
		exports.NoopMetric =
		exports.NoopMeter =
			void 0;
	class NoopMeter {
		constructor() {}
		createGauge(_name, _options) {
			return exports.NOOP_GAUGE_METRIC;
		}
		createHistogram(_name, _options) {
			return exports.NOOP_HISTOGRAM_METRIC;
		}
		createCounter(_name, _options) {
			return exports.NOOP_COUNTER_METRIC;
		}
		createUpDownCounter(_name, _options) {
			return exports.NOOP_UP_DOWN_COUNTER_METRIC;
		}
		createObservableGauge(_name, _options) {
			return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
		}
		createObservableCounter(_name, _options) {
			return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
		}
		createObservableUpDownCounter(_name, _options) {
			return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
		}
		addBatchObservableCallback(_callback, _observables) {}
		removeBatchObservableCallback(_callback) {}
	}
	exports.NoopMeter = NoopMeter;
	class NoopMetric {}
	exports.NoopMetric = NoopMetric;
	class NoopCounterMetric extends NoopMetric {
		add(_value, _attributes) {}
	}
	exports.NoopCounterMetric = NoopCounterMetric;
	class NoopUpDownCounterMetric extends NoopMetric {
		add(_value, _attributes) {}
	}
	exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
	class NoopGaugeMetric extends NoopMetric {
		record(_value, _attributes) {}
	}
	exports.NoopGaugeMetric = NoopGaugeMetric;
	class NoopHistogramMetric extends NoopMetric {
		record(_value, _attributes) {}
	}
	exports.NoopHistogramMetric = NoopHistogramMetric;
	class NoopObservableMetric {
		addCallback(_callback) {}
		removeCallback(_callback) {}
	}
	exports.NoopObservableMetric = NoopObservableMetric;
	class NoopObservableCounterMetric extends NoopObservableMetric {}
	exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
	class NoopObservableGaugeMetric extends NoopObservableMetric {}
	exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
	class NoopObservableUpDownCounterMetric extends NoopObservableMetric {}
	exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
	exports.NOOP_METER = new NoopMeter();
	exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
	exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
	exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
	exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
	exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
	exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
	exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
		new NoopObservableUpDownCounterMetric();
	function createNoopMeter() {
		return exports.NOOP_METER;
	}
	exports.createNoopMeter = createNoopMeter;
});
var require_Metric = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.ValueType = void 0;
	var ValueType4;
	(function (ValueType5) {
		(ValueType5[(ValueType5.INT = 0)] = "INT"),
			(ValueType5[(ValueType5.DOUBLE = 1)] = "DOUBLE");
	})((ValueType4 = exports.ValueType || (exports.ValueType = {})));
});
var require_TextMapPropagator = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
	exports.defaultTextMapGetter = {
		get(carrier, key) {
			if (carrier == null) return;
			return carrier[key];
		},
		keys(carrier) {
			if (carrier == null) return [];
			return Object.keys(carrier);
		},
	};
	exports.defaultTextMapSetter = {
		set(carrier, key, value) {
			if (carrier == null) return;
			carrier[key] = value;
		},
	};
});
var require_NoopContextManager = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NoopContextManager = void 0;
	var context_1 = require_context();
	class NoopContextManager {
		active() {
			return context_1.ROOT_CONTEXT;
		}
		with(_context, fn, thisArg, ...args) {
			return fn.call(thisArg, ...args);
		}
		bind(_context, target) {
			return target;
		}
		enable() {
			return this;
		}
		disable() {
			return this;
		}
	}
	exports.NoopContextManager = NoopContextManager;
});
var require_context2 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.ContextAPI = void 0;
	var NoopContextManager_1 = require_NoopContextManager(),
		global_utils_1 = require_global_utils(),
		diag_1 = require_diag(),
		API_NAME = "context",
		NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
	class ContextAPI {
		constructor() {}
		static getInstance() {
			if (!this._instance) this._instance = new ContextAPI();
			return this._instance;
		}
		setGlobalContextManager(contextManager) {
			return global_utils_1.registerGlobal(
				API_NAME,
				contextManager,
				diag_1.DiagAPI.instance(),
			);
		}
		active() {
			return this._getContextManager().active();
		}
		with(context, fn, thisArg, ...args) {
			return this._getContextManager().with(context, fn, thisArg, ...args);
		}
		bind(context, target) {
			return this._getContextManager().bind(context, target);
		}
		_getContextManager() {
			return global_utils_1.getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;
		}
		disable() {
			this._getContextManager().disable(),
				global_utils_1.unregisterGlobal(API_NAME, diag_1.DiagAPI.instance());
		}
	}
	exports.ContextAPI = ContextAPI;
});
var require_trace_flags = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.TraceFlags = void 0;
	var TraceFlags;
	(function (TraceFlags2) {
		(TraceFlags2[(TraceFlags2.NONE = 0)] = "NONE"),
			(TraceFlags2[(TraceFlags2.SAMPLED = 1)] = "SAMPLED");
	})((TraceFlags = exports.TraceFlags || (exports.TraceFlags = {})));
});
var require_invalid_span_constants = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.INVALID_SPAN_CONTEXT =
		exports.INVALID_TRACEID =
		exports.INVALID_SPANID =
			void 0;
	var trace_flags_1 = require_trace_flags();
	exports.INVALID_SPANID = "0000000000000000";
	exports.INVALID_TRACEID = "00000000000000000000000000000000";
	exports.INVALID_SPAN_CONTEXT = {
		traceId: exports.INVALID_TRACEID,
		spanId: exports.INVALID_SPANID,
		traceFlags: trace_flags_1.TraceFlags.NONE,
	};
});
var require_NonRecordingSpan = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NonRecordingSpan = void 0;
	var invalid_span_constants_1 = require_invalid_span_constants();
	class NonRecordingSpan {
		constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
			this._spanContext = _spanContext;
		}
		spanContext() {
			return this._spanContext;
		}
		setAttribute(_key, _value) {
			return this;
		}
		setAttributes(_attributes) {
			return this;
		}
		addEvent(_name, _attributes) {
			return this;
		}
		addLink(_link) {
			return this;
		}
		addLinks(_links) {
			return this;
		}
		setStatus(_status) {
			return this;
		}
		updateName(_name) {
			return this;
		}
		end(_endTime) {}
		isRecording() {
			return !1;
		}
		recordException(_exception, _time) {}
	}
	exports.NonRecordingSpan = NonRecordingSpan;
});
var require_context_utils = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.getSpanContext =
		exports.setSpanContext =
		exports.deleteSpan =
		exports.setSpan =
		exports.getActiveSpan =
		exports.getSpan =
			void 0;
	var context_1 = require_context(),
		NonRecordingSpan_1 = require_NonRecordingSpan(),
		context_2 = require_context2(),
		SPAN_KEY = context_1.createContextKey("OpenTelemetry Context Key SPAN");
	function getSpan(context) {
		return context.getValue(SPAN_KEY) || void 0;
	}
	exports.getSpan = getSpan;
	function getActiveSpan() {
		return getSpan(context_2.ContextAPI.getInstance().active());
	}
	exports.getActiveSpan = getActiveSpan;
	function setSpan(context, span) {
		return context.setValue(SPAN_KEY, span);
	}
	exports.setSpan = setSpan;
	function deleteSpan(context) {
		return context.deleteValue(SPAN_KEY);
	}
	exports.deleteSpan = deleteSpan;
	function setSpanContext(context, spanContext) {
		return setSpan(
			context,
			new NonRecordingSpan_1.NonRecordingSpan(spanContext),
		);
	}
	exports.setSpanContext = setSpanContext;
	function getSpanContext(context) {
		var _a15;
		return (_a15 = getSpan(context)) === null || _a15 === void 0
			? void 0
			: _a15.spanContext();
	}
	exports.getSpanContext = getSpanContext;
});
var require_spancontext_utils = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.wrapSpanContext =
		exports.isSpanContextValid =
		exports.isValidSpanId =
		exports.isValidTraceId =
			void 0;
	var invalid_span_constants_1 = require_invalid_span_constants(),
		NonRecordingSpan_1 = require_NonRecordingSpan(),
		VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i,
		VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
	function isValidTraceId(traceId) {
		return (
			VALID_TRACEID_REGEX.test(traceId) &&
			traceId !== invalid_span_constants_1.INVALID_TRACEID
		);
	}
	exports.isValidTraceId = isValidTraceId;
	function isValidSpanId(spanId) {
		return (
			VALID_SPANID_REGEX.test(spanId) &&
			spanId !== invalid_span_constants_1.INVALID_SPANID
		);
	}
	exports.isValidSpanId = isValidSpanId;
	function isSpanContextValid(spanContext) {
		return (
			isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)
		);
	}
	exports.isSpanContextValid = isSpanContextValid;
	function wrapSpanContext(spanContext) {
		return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
	}
	exports.wrapSpanContext = wrapSpanContext;
});
var require_NoopTracer = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NoopTracer = void 0;
	var context_1 = require_context2(),
		context_utils_1 = require_context_utils(),
		NonRecordingSpan_1 = require_NonRecordingSpan(),
		spancontext_utils_1 = require_spancontext_utils(),
		contextApi = context_1.ContextAPI.getInstance();
	class NoopTracer {
		startSpan(name14, options, context = contextApi.active()) {
			if (
				Boolean(options === null || options === void 0 ? void 0 : options.root)
			)
				return new NonRecordingSpan_1.NonRecordingSpan();
			let parentFromContext =
				context && context_utils_1.getSpanContext(context);
			if (
				isSpanContext(parentFromContext) &&
				spancontext_utils_1.isSpanContextValid(parentFromContext)
			)
				return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
			else return new NonRecordingSpan_1.NonRecordingSpan();
		}
		startActiveSpan(name14, arg2, arg3, arg4) {
			let opts, ctx, fn;
			if (arguments.length < 2) return;
			else if (arguments.length === 2) fn = arg2;
			else if (arguments.length === 3) (opts = arg2), (fn = arg3);
			else (opts = arg2), (ctx = arg3), (fn = arg4);
			let parentContext =
					ctx !== null && ctx !== void 0 ? ctx : contextApi.active(),
				span = this.startSpan(name14, opts, parentContext),
				contextWithSpanSet = context_utils_1.setSpan(parentContext, span);
			return contextApi.with(contextWithSpanSet, fn, void 0, span);
		}
	}
	exports.NoopTracer = NoopTracer;
	function isSpanContext(spanContext) {
		return (
			typeof spanContext === "object" &&
			typeof spanContext.spanId === "string" &&
			typeof spanContext.traceId === "string" &&
			typeof spanContext.traceFlags === "number"
		);
	}
});
var require_ProxyTracer = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.ProxyTracer = void 0;
	var NoopTracer_1 = require_NoopTracer(),
		NOOP_TRACER = new NoopTracer_1.NoopTracer();
	class ProxyTracer {
		constructor(_provider, name14, version, options) {
			(this._provider = _provider),
				(this.name = name14),
				(this.version = version),
				(this.options = options);
		}
		startSpan(name14, options, context) {
			return this._getTracer().startSpan(name14, options, context);
		}
		startActiveSpan(_name, _options, _context, _fn) {
			let tracer = this._getTracer();
			return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
		}
		_getTracer() {
			if (this._delegate) return this._delegate;
			let tracer = this._provider.getDelegateTracer(
				this.name,
				this.version,
				this.options,
			);
			if (!tracer) return NOOP_TRACER;
			return (this._delegate = tracer), this._delegate;
		}
	}
	exports.ProxyTracer = ProxyTracer;
});
var require_NoopTracerProvider = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NoopTracerProvider = void 0;
	var NoopTracer_1 = require_NoopTracer();
	class NoopTracerProvider {
		getTracer(_name, _version, _options) {
			return new NoopTracer_1.NoopTracer();
		}
	}
	exports.NoopTracerProvider = NoopTracerProvider;
});
var require_ProxyTracerProvider = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.ProxyTracerProvider = void 0;
	var ProxyTracer_1 = require_ProxyTracer(),
		NoopTracerProvider_1 = require_NoopTracerProvider(),
		NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
	class ProxyTracerProvider {
		getTracer(name14, version, options) {
			var _a15;
			return (_a15 = this.getDelegateTracer(name14, version, options)) !==
				null && _a15 !== void 0
				? _a15
				: new ProxyTracer_1.ProxyTracer(this, name14, version, options);
		}
		getDelegate() {
			var _a15;
			return (_a15 = this._delegate) !== null && _a15 !== void 0
				? _a15
				: NOOP_TRACER_PROVIDER;
		}
		setDelegate(delegate) {
			this._delegate = delegate;
		}
		getDelegateTracer(name14, version, options) {
			var _a15;
			return (_a15 = this._delegate) === null || _a15 === void 0
				? void 0
				: _a15.getTracer(name14, version, options);
		}
	}
	exports.ProxyTracerProvider = ProxyTracerProvider;
});
var require_SamplingResult = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.SamplingDecision = void 0;
	var SamplingDecision;
	(function (SamplingDecision2) {
		(SamplingDecision2[(SamplingDecision2.NOT_RECORD = 0)] = "NOT_RECORD"),
			(SamplingDecision2[(SamplingDecision2.RECORD = 1)] = "RECORD"),
			(SamplingDecision2[(SamplingDecision2.RECORD_AND_SAMPLED = 2)] =
				"RECORD_AND_SAMPLED");
	})(
		(SamplingDecision =
			exports.SamplingDecision || (exports.SamplingDecision = {})),
	);
});
var require_span_kind = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.SpanKind = void 0;
	var SpanKind;
	(function (SpanKind2) {
		(SpanKind2[(SpanKind2.INTERNAL = 0)] = "INTERNAL"),
			(SpanKind2[(SpanKind2.SERVER = 1)] = "SERVER"),
			(SpanKind2[(SpanKind2.CLIENT = 2)] = "CLIENT"),
			(SpanKind2[(SpanKind2.PRODUCER = 3)] = "PRODUCER"),
			(SpanKind2[(SpanKind2.CONSUMER = 4)] = "CONSUMER");
	})((SpanKind = exports.SpanKind || (exports.SpanKind = {})));
});
var require_status = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.SpanStatusCode = void 0;
	var SpanStatusCode;
	(function (SpanStatusCode2) {
		(SpanStatusCode2[(SpanStatusCode2.UNSET = 0)] = "UNSET"),
			(SpanStatusCode2[(SpanStatusCode2.OK = 1)] = "OK"),
			(SpanStatusCode2[(SpanStatusCode2.ERROR = 2)] = "ERROR");
	})(
		(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {})),
	);
});
var require_tracestate_validators = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.validateValue = exports.validateKey = void 0;
	var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]",
		VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`,
		VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`,
		VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`),
		VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/,
		INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
	function validateKey(key) {
		return VALID_KEY_REGEX.test(key);
	}
	exports.validateKey = validateKey;
	function validateValue(value) {
		return (
			VALID_VALUE_BASE_REGEX.test(value) &&
			!INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)
		);
	}
	exports.validateValue = validateValue;
});
var require_tracestate_impl = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.TraceStateImpl = void 0;
	var tracestate_validators_1 = require_tracestate_validators(),
		MAX_TRACE_STATE_ITEMS = 32,
		MAX_TRACE_STATE_LEN = 512,
		LIST_MEMBERS_SEPARATOR = ",",
		LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
	class TraceStateImpl {
		constructor(rawTraceState) {
			if (((this._internalState = new Map()), rawTraceState))
				this._parse(rawTraceState);
		}
		set(key, value) {
			let traceState = this._clone();
			if (traceState._internalState.has(key))
				traceState._internalState.delete(key);
			return traceState._internalState.set(key, value), traceState;
		}
		unset(key) {
			let traceState = this._clone();
			return traceState._internalState.delete(key), traceState;
		}
		get(key) {
			return this._internalState.get(key);
		}
		serialize() {
			return this._keys()
				.reduce((agg, key) => {
					return (
						agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg
					);
				}, [])
				.join(LIST_MEMBERS_SEPARATOR);
		}
		_parse(rawTraceState) {
			if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
			if (
				((this._internalState = rawTraceState
					.split(LIST_MEMBERS_SEPARATOR)
					.reverse()
					.reduce((agg, part) => {
						let listMember = part.trim(),
							i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
						if (i !== -1) {
							let key = listMember.slice(0, i),
								value = listMember.slice(i + 1, part.length);
							if (
								tracestate_validators_1.validateKey(key) &&
								tracestate_validators_1.validateValue(value)
							)
								agg.set(key, value);
						}
						return agg;
					}, new Map())),
				this._internalState.size > MAX_TRACE_STATE_ITEMS)
			)
				this._internalState = new Map(
					Array.from(this._internalState.entries())
						.reverse()
						.slice(0, MAX_TRACE_STATE_ITEMS),
				);
		}
		_keys() {
			return Array.from(this._internalState.keys()).reverse();
		}
		_clone() {
			let traceState = new TraceStateImpl();
			return (
				(traceState._internalState = new Map(this._internalState)), traceState
			);
		}
	}
	exports.TraceStateImpl = TraceStateImpl;
});
var require_utils2 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.createTraceState = void 0;
	var tracestate_impl_1 = require_tracestate_impl();
	function createTraceState(rawTraceState) {
		return new tracestate_impl_1.TraceStateImpl(rawTraceState);
	}
	exports.createTraceState = createTraceState;
});
var require_context_api = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.context = void 0;
	var context_1 = require_context2();
	exports.context = context_1.ContextAPI.getInstance();
});
var require_diag_api = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.diag = void 0;
	var diag_1 = require_diag();
	exports.diag = diag_1.DiagAPI.instance();
});
var require_NoopMeterProvider = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
	var NoopMeter_1 = require_NoopMeter();
	class NoopMeterProvider {
		getMeter(_name, _version, _options) {
			return NoopMeter_1.NOOP_METER;
		}
	}
	exports.NoopMeterProvider = NoopMeterProvider;
	exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
});
var require_metrics = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.MetricsAPI = void 0;
	var NoopMeterProvider_1 = require_NoopMeterProvider(),
		global_utils_1 = require_global_utils(),
		diag_1 = require_diag(),
		API_NAME = "metrics";
	class MetricsAPI {
		constructor() {}
		static getInstance() {
			if (!this._instance) this._instance = new MetricsAPI();
			return this._instance;
		}
		setGlobalMeterProvider(provider) {
			return global_utils_1.registerGlobal(
				API_NAME,
				provider,
				diag_1.DiagAPI.instance(),
			);
		}
		getMeterProvider() {
			return (
				global_utils_1.getGlobal(API_NAME) ||
				NoopMeterProvider_1.NOOP_METER_PROVIDER
			);
		}
		getMeter(name14, version, options) {
			return this.getMeterProvider().getMeter(name14, version, options);
		}
		disable() {
			global_utils_1.unregisterGlobal(API_NAME, diag_1.DiagAPI.instance());
		}
	}
	exports.MetricsAPI = MetricsAPI;
});
var require_metrics_api = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.metrics = void 0;
	var metrics_1 = require_metrics();
	exports.metrics = metrics_1.MetricsAPI.getInstance();
});
var require_NoopTextMapPropagator = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.NoopTextMapPropagator = void 0;
	class NoopTextMapPropagator {
		inject(_context, _carrier) {}
		extract(context, _carrier) {
			return context;
		}
		fields() {
			return [];
		}
	}
	exports.NoopTextMapPropagator = NoopTextMapPropagator;
});
var require_context_helpers = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.deleteBaggage =
		exports.setBaggage =
		exports.getActiveBaggage =
		exports.getBaggage =
			void 0;
	var context_1 = require_context2(),
		context_2 = require_context(),
		BAGGAGE_KEY = context_2.createContextKey("OpenTelemetry Baggage Key");
	function getBaggage(context) {
		return context.getValue(BAGGAGE_KEY) || void 0;
	}
	exports.getBaggage = getBaggage;
	function getActiveBaggage() {
		return getBaggage(context_1.ContextAPI.getInstance().active());
	}
	exports.getActiveBaggage = getActiveBaggage;
	function setBaggage(context, baggage) {
		return context.setValue(BAGGAGE_KEY, baggage);
	}
	exports.setBaggage = setBaggage;
	function deleteBaggage(context) {
		return context.deleteValue(BAGGAGE_KEY);
	}
	exports.deleteBaggage = deleteBaggage;
});
var require_propagation = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.PropagationAPI = void 0;
	var global_utils_1 = require_global_utils(),
		NoopTextMapPropagator_1 = require_NoopTextMapPropagator(),
		TextMapPropagator_1 = require_TextMapPropagator(),
		context_helpers_1 = require_context_helpers(),
		utils_1 = require_utils(),
		diag_1 = require_diag(),
		API_NAME = "propagation",
		NOOP_TEXT_MAP_PROPAGATOR =
			new NoopTextMapPropagator_1.NoopTextMapPropagator();
	class PropagationAPI {
		constructor() {
			(this.createBaggage = utils_1.createBaggage),
				(this.getBaggage = context_helpers_1.getBaggage),
				(this.getActiveBaggage = context_helpers_1.getActiveBaggage),
				(this.setBaggage = context_helpers_1.setBaggage),
				(this.deleteBaggage = context_helpers_1.deleteBaggage);
		}
		static getInstance() {
			if (!this._instance) this._instance = new PropagationAPI();
			return this._instance;
		}
		setGlobalPropagator(propagator) {
			return global_utils_1.registerGlobal(
				API_NAME,
				propagator,
				diag_1.DiagAPI.instance(),
			);
		}
		inject(
			context,
			carrier,
			setter = TextMapPropagator_1.defaultTextMapSetter,
		) {
			return this._getGlobalPropagator().inject(context, carrier, setter);
		}
		extract(
			context,
			carrier,
			getter = TextMapPropagator_1.defaultTextMapGetter,
		) {
			return this._getGlobalPropagator().extract(context, carrier, getter);
		}
		fields() {
			return this._getGlobalPropagator().fields();
		}
		disable() {
			global_utils_1.unregisterGlobal(API_NAME, diag_1.DiagAPI.instance());
		}
		_getGlobalPropagator() {
			return global_utils_1.getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
		}
	}
	exports.PropagationAPI = PropagationAPI;
});
var require_propagation_api = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.propagation = void 0;
	var propagation_1 = require_propagation();
	exports.propagation = propagation_1.PropagationAPI.getInstance();
});
var require_trace = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.TraceAPI = void 0;
	var global_utils_1 = require_global_utils(),
		ProxyTracerProvider_1 = require_ProxyTracerProvider(),
		spancontext_utils_1 = require_spancontext_utils(),
		context_utils_1 = require_context_utils(),
		diag_1 = require_diag(),
		API_NAME = "trace";
	class TraceAPI {
		constructor() {
			(this._proxyTracerProvider =
				new ProxyTracerProvider_1.ProxyTracerProvider()),
				(this.wrapSpanContext = spancontext_utils_1.wrapSpanContext),
				(this.isSpanContextValid = spancontext_utils_1.isSpanContextValid),
				(this.deleteSpan = context_utils_1.deleteSpan),
				(this.getSpan = context_utils_1.getSpan),
				(this.getActiveSpan = context_utils_1.getActiveSpan),
				(this.getSpanContext = context_utils_1.getSpanContext),
				(this.setSpan = context_utils_1.setSpan),
				(this.setSpanContext = context_utils_1.setSpanContext);
		}
		static getInstance() {
			if (!this._instance) this._instance = new TraceAPI();
			return this._instance;
		}
		setGlobalTracerProvider(provider) {
			let success = global_utils_1.registerGlobal(
				API_NAME,
				this._proxyTracerProvider,
				diag_1.DiagAPI.instance(),
			);
			if (success) this._proxyTracerProvider.setDelegate(provider);
			return success;
		}
		getTracerProvider() {
			return global_utils_1.getGlobal(API_NAME) || this._proxyTracerProvider;
		}
		getTracer(name14, version) {
			return this.getTracerProvider().getTracer(name14, version);
		}
		disable() {
			global_utils_1.unregisterGlobal(API_NAME, diag_1.DiagAPI.instance()),
				(this._proxyTracerProvider =
					new ProxyTracerProvider_1.ProxyTracerProvider());
		}
	}
	exports.TraceAPI = TraceAPI;
});
var require_trace_api = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.trace = void 0;
	var trace_1 = require_trace();
	exports.trace = trace_1.TraceAPI.getInstance();
});
var require_src = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 });
	exports.trace =
		exports.propagation =
		exports.metrics =
		exports.diag =
		exports.context =
		exports.INVALID_SPAN_CONTEXT =
		exports.INVALID_TRACEID =
		exports.INVALID_SPANID =
		exports.isValidSpanId =
		exports.isValidTraceId =
		exports.isSpanContextValid =
		exports.createTraceState =
		exports.TraceFlags =
		exports.SpanStatusCode =
		exports.SpanKind =
		exports.SamplingDecision =
		exports.ProxyTracerProvider =
		exports.ProxyTracer =
		exports.defaultTextMapSetter =
		exports.defaultTextMapGetter =
		exports.ValueType =
		exports.createNoopMeter =
		exports.DiagLogLevel =
		exports.DiagConsoleLogger =
		exports.ROOT_CONTEXT =
		exports.createContextKey =
		exports.baggageEntryMetadataFromString =
			void 0;
	var utils_1 = require_utils();
	Object.defineProperty(exports, "baggageEntryMetadataFromString", {
		enumerable: !0,
		get: function () {
			return utils_1.baggageEntryMetadataFromString;
		},
	});
	var context_1 = require_context();
	Object.defineProperty(exports, "createContextKey", {
		enumerable: !0,
		get: function () {
			return context_1.createContextKey;
		},
	});
	Object.defineProperty(exports, "ROOT_CONTEXT", {
		enumerable: !0,
		get: function () {
			return context_1.ROOT_CONTEXT;
		},
	});
	var consoleLogger_1 = require_consoleLogger();
	Object.defineProperty(exports, "DiagConsoleLogger", {
		enumerable: !0,
		get: function () {
			return consoleLogger_1.DiagConsoleLogger;
		},
	});
	var types_1 = require_types();
	Object.defineProperty(exports, "DiagLogLevel", {
		enumerable: !0,
		get: function () {
			return types_1.DiagLogLevel;
		},
	});
	var NoopMeter_1 = require_NoopMeter();
	Object.defineProperty(exports, "createNoopMeter", {
		enumerable: !0,
		get: function () {
			return NoopMeter_1.createNoopMeter;
		},
	});
	var Metric_1 = require_Metric();
	Object.defineProperty(exports, "ValueType", {
		enumerable: !0,
		get: function () {
			return Metric_1.ValueType;
		},
	});
	var TextMapPropagator_1 = require_TextMapPropagator();
	Object.defineProperty(exports, "defaultTextMapGetter", {
		enumerable: !0,
		get: function () {
			return TextMapPropagator_1.defaultTextMapGetter;
		},
	});
	Object.defineProperty(exports, "defaultTextMapSetter", {
		enumerable: !0,
		get: function () {
			return TextMapPropagator_1.defaultTextMapSetter;
		},
	});
	var ProxyTracer_1 = require_ProxyTracer();
	Object.defineProperty(exports, "ProxyTracer", {
		enumerable: !0,
		get: function () {
			return ProxyTracer_1.ProxyTracer;
		},
	});
	var ProxyTracerProvider_1 = require_ProxyTracerProvider();
	Object.defineProperty(exports, "ProxyTracerProvider", {
		enumerable: !0,
		get: function () {
			return ProxyTracerProvider_1.ProxyTracerProvider;
		},
	});
	var SamplingResult_1 = require_SamplingResult();
	Object.defineProperty(exports, "SamplingDecision", {
		enumerable: !0,
		get: function () {
			return SamplingResult_1.SamplingDecision;
		},
	});
	var span_kind_1 = require_span_kind();
	Object.defineProperty(exports, "SpanKind", {
		enumerable: !0,
		get: function () {
			return span_kind_1.SpanKind;
		},
	});
	var status_1 = require_status();
	Object.defineProperty(exports, "SpanStatusCode", {
		enumerable: !0,
		get: function () {
			return status_1.SpanStatusCode;
		},
	});
	var trace_flags_1 = require_trace_flags();
	Object.defineProperty(exports, "TraceFlags", {
		enumerable: !0,
		get: function () {
			return trace_flags_1.TraceFlags;
		},
	});
	var utils_2 = require_utils2();
	Object.defineProperty(exports, "createTraceState", {
		enumerable: !0,
		get: function () {
			return utils_2.createTraceState;
		},
	});
	var spancontext_utils_1 = require_spancontext_utils();
	Object.defineProperty(exports, "isSpanContextValid", {
		enumerable: !0,
		get: function () {
			return spancontext_utils_1.isSpanContextValid;
		},
	});
	Object.defineProperty(exports, "isValidTraceId", {
		enumerable: !0,
		get: function () {
			return spancontext_utils_1.isValidTraceId;
		},
	});
	Object.defineProperty(exports, "isValidSpanId", {
		enumerable: !0,
		get: function () {
			return spancontext_utils_1.isValidSpanId;
		},
	});
	var invalid_span_constants_1 = require_invalid_span_constants();
	Object.defineProperty(exports, "INVALID_SPANID", {
		enumerable: !0,
		get: function () {
			return invalid_span_constants_1.INVALID_SPANID;
		},
	});
	Object.defineProperty(exports, "INVALID_TRACEID", {
		enumerable: !0,
		get: function () {
			return invalid_span_constants_1.INVALID_TRACEID;
		},
	});
	Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", {
		enumerable: !0,
		get: function () {
			return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
		},
	});
	var context_api_1 = require_context_api();
	Object.defineProperty(exports, "context", {
		enumerable: !0,
		get: function () {
			return context_api_1.context;
		},
	});
	var diag_api_1 = require_diag_api();
	Object.defineProperty(exports, "diag", {
		enumerable: !0,
		get: function () {
			return diag_api_1.diag;
		},
	});
	var metrics_api_1 = require_metrics_api();
	Object.defineProperty(exports, "metrics", {
		enumerable: !0,
		get: function () {
			return metrics_api_1.metrics;
		},
	});
	var propagation_api_1 = require_propagation_api();
	Object.defineProperty(exports, "propagation", {
		enumerable: !0,
		get: function () {
			return propagation_api_1.propagation;
		},
	});
	var trace_api_1 = require_trace_api();
	Object.defineProperty(exports, "trace", {
		enumerable: !0,
		get: function () {
			return trace_api_1.trace;
		},
	});
	exports.default = {
		context: context_api_1.context,
		diag: diag_api_1.diag,
		metrics: metrics_api_1.metrics,
		propagation: propagation_api_1.propagation,
		trace: trace_api_1.trace,
	};
});
var createNode = (part, inert) => {
		let inertMap = inert?.length ? {} : null;
		if (inertMap)
			for (let child of inert) inertMap[child.part.charCodeAt(0)] = child;
		return {
			part,
			store: null,
			inert: inertMap,
			params: null,
			wildcardStore: null,
		};
	},
	cloneNode = (node, part) => ({ ...node, part }),
	createParamNode = (name) => ({ name, store: null, inert: null }),
	Memoirist = class _Memoirist {
		constructor(config = {}) {
			if (((this.config = config), config.lazy)) this.find = this.lazyFind;
		}
		root = {};
		history = [];
		deferred = [];
		static regex = {
			static: /:.+?(?=\/|$)/,
			params: /:.+?(?=\/|$)/g,
			optionalParams: /:.+?\?(?=\/|$)/g,
		};
		lazyFind = (method, url) => {
			if (!this.config.lazy) return this.find;
			return this.build(), this.find(method, url);
		};
		build() {
			if (!this.config.lazy) return;
			for (let [method, path, store] of this.deferred)
				this.add(method, path, store, { lazy: !1, ignoreHistory: !0 });
			(this.deferred = []),
				(this.find = (method, url) => {
					let root = this.root[method];
					if (!root) return null;
					return matchRoute(url, url.length, root, 0);
				});
		}
		add(
			method,
			path,
			store,
			{ ignoreError = !1, ignoreHistory = !1, lazy = this.config.lazy } = {},
		) {
			if (lazy)
				return (
					(this.find = this.lazyFind),
					this.deferred.push([method, path, store]),
					store
				);
			if (typeof path !== "string")
				throw new TypeError("Route path must be a string");
			if (path === "") path = "/";
			else if (path[0] !== "/") path = `/${path}`;
			let isWildcard = path[path.length - 1] === "*",
				optionalParams = path.match(_Memoirist.regex.optionalParams);
			if (optionalParams) {
				let originalPath = path.replaceAll("?", "");
				this.add(method, originalPath, store, {
					ignoreError,
					ignoreHistory,
					lazy,
				});
				for (let i = 0; i < optionalParams.length; i++) {
					let newPath = path.replace("/" + optionalParams[i], "");
					this.add(method, newPath, store, {
						ignoreError: !0,
						ignoreHistory,
						lazy,
					});
				}
				return store;
			}
			if (optionalParams) path = path.replaceAll("?", "");
			if (this.history.find(([m, p, s]) => m === method && p === path))
				return store;
			if (
				isWildcard ||
				(optionalParams && path.charCodeAt(path.length - 1) === 63)
			)
				path = path.slice(0, -1);
			if (!ignoreHistory) this.history.push([method, path, store]);
			let inertParts = path.split(_Memoirist.regex.static),
				paramParts = path.match(_Memoirist.regex.params) || [];
			if (inertParts[inertParts.length - 1] === "") inertParts.pop();
			let node;
			if (!this.root[method]) node = this.root[method] = createNode("/");
			else node = this.root[method];
			let paramPartsIndex = 0;
			for (let i = 0; i < inertParts.length; ++i) {
				let part = inertParts[i];
				if (i > 0) {
					let param = paramParts[paramPartsIndex++].slice(1);
					if (node.params === null) node.params = createParamNode(param);
					else if (node.params.name !== param)
						if (ignoreError) return store;
						else
							throw new Error(
								`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`,
							);
					let params = node.params;
					if (params.inert === null) {
						node = params.inert = createNode(part);
						continue;
					}
					node = params.inert;
				}
				for (let j = 0; ; ) {
					if (j === part.length) {
						if (j < node.part.length) {
							let childNode = cloneNode(node, node.part.slice(j));
							Object.assign(node, createNode(part, [childNode]));
						}
						break;
					}
					if (j === node.part.length) {
						if (node.inert === null) node.inert = {};
						let inert = node.inert[part.charCodeAt(j)];
						if (inert) {
							(node = inert), (part = part.slice(j)), (j = 0);
							continue;
						}
						let childNode = createNode(part.slice(j));
						(node.inert[part.charCodeAt(j)] = childNode), (node = childNode);
						break;
					}
					if (part[j] !== node.part[j]) {
						let existingChild = cloneNode(node, node.part.slice(j)),
							newChild = createNode(part.slice(j));
						Object.assign(
							node,
							createNode(node.part.slice(0, j), [existingChild, newChild]),
						),
							(node = newChild);
						break;
					}
					++j;
				}
			}
			if (paramPartsIndex < paramParts.length) {
				let name = paramParts[paramPartsIndex].slice(1);
				if (node.params === null) node.params = createParamNode(name);
				else if (node.params.name !== name)
					if (ignoreError) return store;
					else
						throw new Error(
							`Cannot create route "${path}" with parameter "${name}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`,
						);
				if (node.params.store === null) node.params.store = store;
				return node.params.store;
			}
			if (isWildcard) {
				if (node.wildcardStore === null) node.wildcardStore = store;
				return node.wildcardStore;
			}
			if (node.store === null) node.store = store;
			return node.store;
		}
		find(method, url) {
			let root = this.root[method];
			if (!root) return null;
			return matchRoute(url, url.length, root, 0);
		}
	},
	matchRoute = (url, urlLength, node, startIndex) => {
		let part = node.part,
			length = part.length,
			endIndex = startIndex + length;
		if (length > 1) {
			if (endIndex > urlLength) return null;
			if (length < 15) {
				for (let i = 1, j = startIndex + 1; i < length; ++i, ++j)
					if (part.charCodeAt(i) !== url.charCodeAt(j)) return null;
			} else if (url.slice(startIndex, endIndex) !== part) return null;
		}
		if (endIndex === urlLength) {
			if (node.store !== null) return { store: node.store, params: {} };
			if (node.wildcardStore !== null)
				return { store: node.wildcardStore, params: { "*": "" } };
			return null;
		}
		if (node.inert !== null) {
			let inert = node.inert[url.charCodeAt(endIndex)];
			if (inert !== void 0) {
				let route = matchRoute(url, urlLength, inert, endIndex);
				if (route !== null) return route;
			}
		}
		if (node.params !== null) {
			let { store, name, inert } = node.params,
				slashIndex = url.indexOf("/", endIndex);
			if (slashIndex !== endIndex) {
				if (slashIndex === -1 || slashIndex >= urlLength) {
					if (store !== null) {
						let params = {};
						return (
							(params[name] = url.substring(endIndex, urlLength)),
							{ store, params }
						);
					}
				} else if (inert !== null) {
					let route = matchRoute(url, urlLength, inert, slashIndex);
					if (route !== null)
						return (
							(route.params[name] = url.substring(endIndex, slashIndex)), route
						);
				}
			}
		}
		if (node.wildcardStore !== null)
			return {
				store: node.wildcardStore,
				params: { "*": url.substring(endIndex, urlLength) },
			};
		return null;
	};
var exports_value = {};
__export(exports_value, {
	IsUndefined: () => IsUndefined,
	IsUint8Array: () => IsUint8Array,
	IsSymbol: () => IsSymbol,
	IsString: () => IsString,
	IsRegExp: () => IsRegExp,
	IsObject: () => IsObject,
	IsNumber: () => IsNumber,
	IsNull: () => IsNull,
	IsIterator: () => IsIterator,
	IsFunction: () => IsFunction,
	IsDate: () => IsDate,
	IsBoolean: () => IsBoolean,
	IsBigInt: () => IsBigInt,
	IsAsyncIterator: () => IsAsyncIterator,
	IsArray: () => IsArray,
	HasPropertyKey: () => HasPropertyKey,
});
function HasPropertyKey(value, key) {
	return key in value;
}
function IsAsyncIterator(value) {
	return (
		IsObject(value) &&
		!IsArray(value) &&
		!IsUint8Array(value) &&
		Symbol.asyncIterator in value
	);
}
function IsArray(value) {
	return Array.isArray(value);
}
function IsBigInt(value) {
	return typeof value === "bigint";
}
function IsBoolean(value) {
	return typeof value === "boolean";
}
function IsDate(value) {
	return value instanceof globalThis.Date;
}
function IsFunction(value) {
	return typeof value === "function";
}
function IsIterator(value) {
	return (
		IsObject(value) &&
		!IsArray(value) &&
		!IsUint8Array(value) &&
		Symbol.iterator in value
	);
}
function IsNull(value) {
	return value === null;
}
function IsNumber(value) {
	return typeof value === "number";
}
function IsObject(value) {
	return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
	return value instanceof globalThis.RegExp;
}
function IsString(value) {
	return typeof value === "string";
}
function IsSymbol(value) {
	return typeof value === "symbol";
}
function IsUint8Array(value) {
	return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
	return value === void 0;
}
function ArrayType(value) {
	return value.map((value2) => Visit(value2));
}
function DateType(value) {
	return new Date(value.getTime());
}
function Uint8ArrayType(value) {
	return new Uint8Array(value);
}
function RegExpType(value) {
	return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
	let result = {};
	for (let key of Object.getOwnPropertyNames(value))
		result[key] = Visit(value[key]);
	for (let key of Object.getOwnPropertySymbols(value))
		result[key] = Visit(value[key]);
	return result;
}
function Visit(value) {
	return IsArray(value)
		? ArrayType(value)
		: IsDate(value)
			? DateType(value)
			: IsUint8Array(value)
				? Uint8ArrayType(value)
				: IsRegExp(value)
					? RegExpType(value)
					: IsObject(value)
						? ObjectType(value)
						: value;
}
function Clone(value) {
	return Visit(value);
}
function CloneType(schema, options) {
	return options === void 0 ? Clone(schema) : Clone({ ...options, ...schema });
}
function IsAsyncIterator2(value) {
	return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
	return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
	return (
		IsObject2(value) &&
		(globalThis.Object.getPrototypeOf(value) === Object.prototype ||
			globalThis.Object.getPrototypeOf(value) === null)
	);
}
function IsPromise(value) {
	return value instanceof globalThis.Promise;
}
function IsDate2(value) {
	return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
	return value instanceof globalThis.Map;
}
function IsSet(value) {
	return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
	return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
	return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
	return key in value;
}
function IsObject2(value) {
	return value !== null && typeof value === "object";
}
function IsArray2(value) {
	return (
		globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value)
	);
}
function IsUndefined2(value) {
	return value === void 0;
}
function IsNull2(value) {
	return value === null;
}
function IsBoolean2(value) {
	return typeof value === "boolean";
}
function IsNumber2(value) {
	return typeof value === "number";
}
function IsInteger(value) {
	return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
	return typeof value === "bigint";
}
function IsString2(value) {
	return typeof value === "string";
}
function IsFunction2(value) {
	return typeof value === "function";
}
function IsSymbol2(value) {
	return typeof value === "symbol";
}
function IsValueType(value) {
	return (
		IsBigInt2(value) ||
		IsBoolean2(value) ||
		IsNull2(value) ||
		IsNumber2(value) ||
		IsString2(value) ||
		IsSymbol2(value) ||
		IsUndefined2(value)
	);
}
var TypeSystemPolicy;
(function (TypeSystemPolicy2) {
	(TypeSystemPolicy2.InstanceMode = "default"),
		(TypeSystemPolicy2.ExactOptionalPropertyTypes = !1),
		(TypeSystemPolicy2.AllowArrayObject = !1),
		(TypeSystemPolicy2.AllowNaN = !1),
		(TypeSystemPolicy2.AllowNullVoid = !1);
	function IsExactOptionalProperty(value, key) {
		return TypeSystemPolicy2.ExactOptionalPropertyTypes
			? key in value
			: value[key] !== void 0;
	}
	TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
	function IsObjectLike(value) {
		let isObject = IsObject2(value);
		return TypeSystemPolicy2.AllowArrayObject
			? isObject
			: isObject && !IsArray2(value);
	}
	TypeSystemPolicy2.IsObjectLike = IsObjectLike;
	function IsRecordLike(value) {
		return (
			IsObjectLike(value) &&
			!(value instanceof Date) &&
			!(value instanceof Uint8Array)
		);
	}
	TypeSystemPolicy2.IsRecordLike = IsRecordLike;
	function IsNumberLike(value) {
		return TypeSystemPolicy2.AllowNaN
			? IsNumber2(value)
			: Number.isFinite(value);
	}
	TypeSystemPolicy2.IsNumberLike = IsNumberLike;
	function IsVoidLike(value) {
		let isUndefined = IsUndefined2(value);
		return TypeSystemPolicy2.AllowNullVoid
			? isUndefined || value === null
			: isUndefined;
	}
	TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
function ImmutableArray(value) {
	return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
	return value;
}
function ImmutableUint8Array(value) {
	return value;
}
function ImmutableRegExp(value) {
	return value;
}
function ImmutableObject(value) {
	let result = {};
	for (let key of Object.getOwnPropertyNames(value))
		result[key] = Immutable(value[key]);
	for (let key of Object.getOwnPropertySymbols(value))
		result[key] = Immutable(value[key]);
	return globalThis.Object.freeze(result);
}
function Immutable(value) {
	return IsArray(value)
		? ImmutableArray(value)
		: IsDate(value)
			? ImmutableDate(value)
			: IsUint8Array(value)
				? ImmutableUint8Array(value)
				: IsRegExp(value)
					? ImmutableRegExp(value)
					: IsObject(value)
						? ImmutableObject(value)
						: value;
}
function CreateType(schema, options) {
	let result = options !== void 0 ? { ...options, ...schema } : schema;
	switch (TypeSystemPolicy.InstanceMode) {
		case "freeze":
			return Immutable(result);
		case "clone":
			return Clone(result);
		default:
			return result;
	}
}
class TypeBoxError extends Error {
	constructor(message) {
		super(message);
	}
}
var TransformKind = Symbol.for("TypeBox.Transform"),
	ReadonlyKind = Symbol.for("TypeBox.Readonly"),
	OptionalKind = Symbol.for("TypeBox.Optional"),
	Hint = Symbol.for("TypeBox.Hint"),
	Kind = Symbol.for("TypeBox.Kind");
function IsReadonly(value) {
	return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
	return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
	return IsKindOf(value, "Any");
}
function IsArgument(value) {
	return IsKindOf(value, "Argument");
}
function IsArray3(value) {
	return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
	return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
	return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
	return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
	return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
	return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
	return IsKindOf(value, "Date");
}
function IsFunction3(value) {
	return IsKindOf(value, "Function");
}
function IsInteger2(value) {
	return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
	return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
	return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
	return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
	return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
	return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
	return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
	return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
	return IsKindOf(value, "Never");
}
function IsNot(value) {
	return IsKindOf(value, "Not");
}
function IsNull3(value) {
	return IsKindOf(value, "Null");
}
function IsNumber3(value) {
	return IsKindOf(value, "Number");
}
function IsObject3(value) {
	return IsKindOf(value, "Object");
}
function IsPromise2(value) {
	return IsKindOf(value, "Promise");
}
function IsRecord(value) {
	return IsKindOf(value, "Record");
}
function IsRef(value) {
	return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
	return IsKindOf(value, "RegExp");
}
function IsString3(value) {
	return IsKindOf(value, "String");
}
function IsSymbol3(value) {
	return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
	return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
	return IsKindOf(value, "This");
}
function IsTransform(value) {
	return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
	return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
	return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
	return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
	return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
	return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
	return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
	return IsKindOf(value, "Void");
}
function IsKind(value) {
	return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
	return (
		IsAny(value) ||
		IsArgument(value) ||
		IsArray3(value) ||
		IsBoolean3(value) ||
		IsBigInt3(value) ||
		IsAsyncIterator3(value) ||
		IsComputed(value) ||
		IsConstructor(value) ||
		IsDate3(value) ||
		IsFunction3(value) ||
		IsInteger2(value) ||
		IsIntersect(value) ||
		IsIterator3(value) ||
		IsLiteral(value) ||
		IsMappedKey(value) ||
		IsMappedResult(value) ||
		IsNever(value) ||
		IsNot(value) ||
		IsNull3(value) ||
		IsNumber3(value) ||
		IsObject3(value) ||
		IsPromise2(value) ||
		IsRecord(value) ||
		IsRef(value) ||
		IsRegExp2(value) ||
		IsString3(value) ||
		IsSymbol3(value) ||
		IsTemplateLiteral(value) ||
		IsThis(value) ||
		IsTuple(value) ||
		IsUndefined3(value) ||
		IsUnion(value) ||
		IsUint8Array3(value) ||
		IsUnknown(value) ||
		IsUnsafe(value) ||
		IsVoid(value) ||
		IsKind(value)
	);
}
var exports_type = {};
__export(exports_type, {
	TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
	IsVoid: () => IsVoid2,
	IsUnsafe: () => IsUnsafe2,
	IsUnknown: () => IsUnknown2,
	IsUnionLiteral: () => IsUnionLiteral,
	IsUnion: () => IsUnion2,
	IsUndefined: () => IsUndefined4,
	IsUint8Array: () => IsUint8Array4,
	IsTuple: () => IsTuple2,
	IsTransform: () => IsTransform2,
	IsThis: () => IsThis2,
	IsTemplateLiteral: () => IsTemplateLiteral2,
	IsSymbol: () => IsSymbol4,
	IsString: () => IsString4,
	IsSchema: () => IsSchema2,
	IsRegExp: () => IsRegExp3,
	IsRef: () => IsRef2,
	IsRecursive: () => IsRecursive,
	IsRecord: () => IsRecord2,
	IsReadonly: () => IsReadonly2,
	IsProperties: () => IsProperties,
	IsPromise: () => IsPromise3,
	IsOptional: () => IsOptional2,
	IsObject: () => IsObject4,
	IsNumber: () => IsNumber4,
	IsNull: () => IsNull4,
	IsNot: () => IsNot2,
	IsNever: () => IsNever2,
	IsMappedResult: () => IsMappedResult2,
	IsMappedKey: () => IsMappedKey2,
	IsLiteralValue: () => IsLiteralValue2,
	IsLiteralString: () => IsLiteralString,
	IsLiteralNumber: () => IsLiteralNumber,
	IsLiteralBoolean: () => IsLiteralBoolean,
	IsLiteral: () => IsLiteral2,
	IsKindOf: () => IsKindOf2,
	IsKind: () => IsKind2,
	IsIterator: () => IsIterator4,
	IsIntersect: () => IsIntersect2,
	IsInteger: () => IsInteger3,
	IsImport: () => IsImport,
	IsFunction: () => IsFunction4,
	IsDate: () => IsDate4,
	IsConstructor: () => IsConstructor2,
	IsComputed: () => IsComputed2,
	IsBoolean: () => IsBoolean4,
	IsBigInt: () => IsBigInt4,
	IsAsyncIterator: () => IsAsyncIterator4,
	IsArray: () => IsArray4,
	IsArgument: () => IsArgument2,
	IsAny: () => IsAny2,
});
class TypeGuardUnknownTypeError extends TypeBoxError {}
var KnownTypes = [
	"Argument",
	"Any",
	"Array",
	"AsyncIterator",
	"BigInt",
	"Boolean",
	"Computed",
	"Constructor",
	"Date",
	"Enum",
	"Function",
	"Integer",
	"Intersect",
	"Iterator",
	"Literal",
	"MappedKey",
	"MappedResult",
	"Not",
	"Null",
	"Number",
	"Object",
	"Promise",
	"Record",
	"Ref",
	"RegExp",
	"String",
	"Symbol",
	"TemplateLiteral",
	"This",
	"Tuple",
	"Undefined",
	"Union",
	"Uint8Array",
	"Unknown",
	"Void",
];
function IsPattern(value) {
	try {
		return new RegExp(value), !0;
	} catch {
		return !1;
	}
}
function IsControlCharacterFree(value) {
	if (!IsString(value)) return !1;
	for (let i = 0; i < value.length; i++) {
		let code = value.charCodeAt(i);
		if ((code >= 7 && code <= 13) || code === 27 || code === 127) return !1;
	}
	return !0;
}
function IsAdditionalProperties(value) {
	return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
	return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
	return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
	return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
	return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
	return (
		IsUndefined(value) ||
		(IsString(value) && IsControlCharacterFree(value) && IsPattern(value))
	);
}
function IsOptionalFormat(value) {
	return (
		IsUndefined(value) || (IsString(value) && IsControlCharacterFree(value))
	);
}
function IsOptionalSchema(value) {
	return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
	return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
	return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
	return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
	return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
	return (
		IsKindOf2(value, "Array") &&
		value.type === "array" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items) &&
		IsOptionalNumber(value.minItems) &&
		IsOptionalNumber(value.maxItems) &&
		IsOptionalBoolean(value.uniqueItems) &&
		IsOptionalSchema(value.contains) &&
		IsOptionalNumber(value.minContains) &&
		IsOptionalNumber(value.maxContains)
	);
}
function IsAsyncIterator4(value) {
	return (
		IsKindOf2(value, "AsyncIterator") &&
		value.type === "AsyncIterator" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items)
	);
}
function IsBigInt4(value) {
	return (
		IsKindOf2(value, "BigInt") &&
		value.type === "bigint" &&
		IsOptionalString(value.$id) &&
		IsOptionalBigInt(value.exclusiveMaximum) &&
		IsOptionalBigInt(value.exclusiveMinimum) &&
		IsOptionalBigInt(value.maximum) &&
		IsOptionalBigInt(value.minimum) &&
		IsOptionalBigInt(value.multipleOf)
	);
}
function IsBoolean4(value) {
	return (
		IsKindOf2(value, "Boolean") &&
		value.type === "boolean" &&
		IsOptionalString(value.$id)
	);
}
function IsComputed2(value) {
	return (
		IsKindOf2(value, "Computed") &&
		IsString(value.target) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema))
	);
}
function IsConstructor2(value) {
	return (
		IsKindOf2(value, "Constructor") &&
		value.type === "Constructor" &&
		IsOptionalString(value.$id) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema)) &&
		IsSchema2(value.returns)
	);
}
function IsDate4(value) {
	return (
		IsKindOf2(value, "Date") &&
		value.type === "Date" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximumTimestamp) &&
		IsOptionalNumber(value.exclusiveMinimumTimestamp) &&
		IsOptionalNumber(value.maximumTimestamp) &&
		IsOptionalNumber(value.minimumTimestamp) &&
		IsOptionalNumber(value.multipleOfTimestamp)
	);
}
function IsFunction4(value) {
	return (
		IsKindOf2(value, "Function") &&
		value.type === "Function" &&
		IsOptionalString(value.$id) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema)) &&
		IsSchema2(value.returns)
	);
}
function IsImport(value) {
	return (
		IsKindOf2(value, "Import") &&
		HasPropertyKey(value, "$defs") &&
		IsObject(value.$defs) &&
		IsProperties(value.$defs) &&
		HasPropertyKey(value, "$ref") &&
		IsString(value.$ref) &&
		value.$ref in value.$defs
	);
}
function IsInteger3(value) {
	return (
		IsKindOf2(value, "Integer") &&
		value.type === "integer" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximum) &&
		IsOptionalNumber(value.exclusiveMinimum) &&
		IsOptionalNumber(value.maximum) &&
		IsOptionalNumber(value.minimum) &&
		IsOptionalNumber(value.multipleOf)
	);
}
function IsProperties(value) {
	return (
		IsObject(value) &&
		Object.entries(value).every(
			([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema),
		)
	);
}
function IsIntersect2(value) {
	return (
		IsKindOf2(value, "Intersect") &&
		(IsString(value.type) && value.type !== "object" ? !1 : !0) &&
		IsArray(value.allOf) &&
		value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) &&
		IsOptionalString(value.type) &&
		(IsOptionalBoolean(value.unevaluatedProperties) ||
			IsOptionalSchema(value.unevaluatedProperties)) &&
		IsOptionalString(value.$id)
	);
}
function IsIterator4(value) {
	return (
		IsKindOf2(value, "Iterator") &&
		value.type === "Iterator" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items)
	);
}
function IsKindOf2(value, kind) {
	return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
	return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
	return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
	return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
	return (
		IsKindOf2(value, "Literal") &&
		IsOptionalString(value.$id) &&
		IsLiteralValue2(value.const)
	);
}
function IsLiteralValue2(value) {
	return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
	return (
		IsKindOf2(value, "MappedKey") &&
		IsArray(value.keys) &&
		value.keys.every((key) => IsNumber(key) || IsString(key))
	);
}
function IsMappedResult2(value) {
	return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
	return (
		IsKindOf2(value, "Never") &&
		IsObject(value.not) &&
		Object.getOwnPropertyNames(value.not).length === 0
	);
}
function IsNot2(value) {
	return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
	return (
		IsKindOf2(value, "Null") &&
		value.type === "null" &&
		IsOptionalString(value.$id)
	);
}
function IsNumber4(value) {
	return (
		IsKindOf2(value, "Number") &&
		value.type === "number" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximum) &&
		IsOptionalNumber(value.exclusiveMinimum) &&
		IsOptionalNumber(value.maximum) &&
		IsOptionalNumber(value.minimum) &&
		IsOptionalNumber(value.multipleOf)
	);
}
function IsObject4(value) {
	return (
		IsKindOf2(value, "Object") &&
		value.type === "object" &&
		IsOptionalString(value.$id) &&
		IsProperties(value.properties) &&
		IsAdditionalProperties(value.additionalProperties) &&
		IsOptionalNumber(value.minProperties) &&
		IsOptionalNumber(value.maxProperties)
	);
}
function IsPromise3(value) {
	return (
		IsKindOf2(value, "Promise") &&
		value.type === "Promise" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.item)
	);
}
function IsRecord2(value) {
	return (
		IsKindOf2(value, "Record") &&
		value.type === "object" &&
		IsOptionalString(value.$id) &&
		IsAdditionalProperties(value.additionalProperties) &&
		IsObject(value.patternProperties) &&
		((schema) => {
			let keys = Object.getOwnPropertyNames(schema.patternProperties);
			return (
				keys.length === 1 &&
				IsPattern(keys[0]) &&
				IsObject(schema.patternProperties) &&
				IsSchema2(schema.patternProperties[keys[0]])
			);
		})(value)
	);
}
function IsRecursive(value) {
	return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
	return (
		IsKindOf2(value, "Ref") &&
		IsOptionalString(value.$id) &&
		IsString(value.$ref)
	);
}
function IsRegExp3(value) {
	return (
		IsKindOf2(value, "RegExp") &&
		IsOptionalString(value.$id) &&
		IsString(value.source) &&
		IsString(value.flags) &&
		IsOptionalNumber(value.maxLength) &&
		IsOptionalNumber(value.minLength)
	);
}
function IsString4(value) {
	return (
		IsKindOf2(value, "String") &&
		value.type === "string" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.minLength) &&
		IsOptionalNumber(value.maxLength) &&
		IsOptionalPattern(value.pattern) &&
		IsOptionalFormat(value.format)
	);
}
function IsSymbol4(value) {
	return (
		IsKindOf2(value, "Symbol") &&
		value.type === "symbol" &&
		IsOptionalString(value.$id)
	);
}
function IsTemplateLiteral2(value) {
	return (
		IsKindOf2(value, "TemplateLiteral") &&
		value.type === "string" &&
		IsString(value.pattern) &&
		value.pattern[0] === "^" &&
		value.pattern[value.pattern.length - 1] === "$"
	);
}
function IsThis2(value) {
	return (
		IsKindOf2(value, "This") &&
		IsOptionalString(value.$id) &&
		IsString(value.$ref)
	);
}
function IsTransform2(value) {
	return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
	return (
		IsKindOf2(value, "Tuple") &&
		value.type === "array" &&
		IsOptionalString(value.$id) &&
		IsNumber(value.minItems) &&
		IsNumber(value.maxItems) &&
		value.minItems === value.maxItems &&
		((IsUndefined(value.items) &&
			IsUndefined(value.additionalItems) &&
			value.minItems === 0) ||
			(IsArray(value.items) &&
				value.items.every((schema) => IsSchema2(schema))))
	);
}
function IsUndefined4(value) {
	return (
		IsKindOf2(value, "Undefined") &&
		value.type === "undefined" &&
		IsOptionalString(value.$id)
	);
}
function IsUnionLiteral(value) {
	return (
		IsUnion2(value) &&
		value.anyOf.every(
			(schema) => IsLiteralString(schema) || IsLiteralNumber(schema),
		)
	);
}
function IsUnion2(value) {
	return (
		IsKindOf2(value, "Union") &&
		IsOptionalString(value.$id) &&
		IsObject(value) &&
		IsArray(value.anyOf) &&
		value.anyOf.every((schema) => IsSchema2(schema))
	);
}
function IsUint8Array4(value) {
	return (
		IsKindOf2(value, "Uint8Array") &&
		value.type === "Uint8Array" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.minByteLength) &&
		IsOptionalNumber(value.maxByteLength)
	);
}
function IsUnknown2(value) {
	return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
	return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
	return (
		IsKindOf2(value, "Void") &&
		value.type === "void" &&
		IsOptionalString(value.$id)
	);
}
function IsKind2(value) {
	return (
		IsObject(value) &&
		Kind in value &&
		IsString(value[Kind]) &&
		!KnownTypes.includes(value[Kind])
	);
}
function IsSchema2(value) {
	return (
		IsObject(value) &&
		(IsAny2(value) ||
			IsArgument2(value) ||
			IsArray4(value) ||
			IsBoolean4(value) ||
			IsBigInt4(value) ||
			IsAsyncIterator4(value) ||
			IsComputed2(value) ||
			IsConstructor2(value) ||
			IsDate4(value) ||
			IsFunction4(value) ||
			IsInteger3(value) ||
			IsIntersect2(value) ||
			IsIterator4(value) ||
			IsLiteral2(value) ||
			IsMappedKey2(value) ||
			IsMappedResult2(value) ||
			IsNever2(value) ||
			IsNot2(value) ||
			IsNull4(value) ||
			IsNumber4(value) ||
			IsObject4(value) ||
			IsPromise3(value) ||
			IsRecord2(value) ||
			IsRef2(value) ||
			IsRegExp3(value) ||
			IsString4(value) ||
			IsSymbol4(value) ||
			IsTemplateLiteral2(value) ||
			IsThis2(value) ||
			IsTuple2(value) ||
			IsUndefined4(value) ||
			IsUnion2(value) ||
			IsUint8Array4(value) ||
			IsUnknown2(value) ||
			IsUnsafe2(value) ||
			IsVoid2(value) ||
			IsKind2(value))
	);
}
var PatternBoolean = "(true|false)",
	PatternNumber = "(0|[1-9][0-9]*)",
	PatternString = "(.*)";
var PatternNumberExact = "^(0|[1-9][0-9]*)$",
	PatternStringExact = "^(.*)$",
	PatternNeverExact = "^(?!.*)$";
var exports_format = {};
__export(exports_format, {
	Set: () => Set2,
	Has: () => Has,
	Get: () => Get,
	Entries: () => Entries,
	Delete: () => Delete,
	Clear: () => Clear,
});
var map = new Map();
function Entries() {
	return new Map(map);
}
function Clear() {
	return map.clear();
}
function Delete(format) {
	return map.delete(format);
}
function Has(format) {
	return map.has(format);
}
function Set2(format, func) {
	map.set(format, func);
}
function Get(format) {
	return map.get(format);
}
var exports_type2 = {};
__export(exports_type2, {
	Set: () => Set3,
	Has: () => Has2,
	Get: () => Get2,
	Entries: () => Entries2,
	Delete: () => Delete2,
	Clear: () => Clear2,
});
var map2 = new Map();
function Entries2() {
	return new Map(map2);
}
function Clear2() {
	return map2.clear();
}
function Delete2(kind) {
	return map2.delete(kind);
}
function Has2(kind) {
	return map2.has(kind);
}
function Set3(kind, func) {
	map2.set(kind, func);
}
function Get2(kind) {
	return map2.get(kind);
}
function SetIncludes(T, S) {
	return T.includes(S);
}
function SetDistinct(T) {
	return [...new Set(T)];
}
function SetIntersect(T, S) {
	return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
	return T.reduce((Acc, L) => {
		return SetIntersect(Acc, L);
	}, Init);
}
function SetIntersectMany(T) {
	return T.length === 1
		? T[0]
		: T.length > 1
			? SetIntersectManyResolve(T.slice(1), T[0])
			: [];
}
function SetUnionMany(T) {
	let Acc = [];
	for (let L of T) Acc.push(...L);
	return Acc;
}
function Any(options) {
	return CreateType({ [Kind]: "Any" }, options);
}
function Array2(items, options) {
	return CreateType({ [Kind]: "Array", type: "array", items }, options);
}
function Argument(index) {
	return CreateType({ [Kind]: "Argument", index });
}
function AsyncIterator(items, options) {
	return CreateType(
		{ [Kind]: "AsyncIterator", type: "AsyncIterator", items },
		options,
	);
}
function Computed(target, parameters, options) {
	return CreateType({ [Kind]: "Computed", target, parameters }, options);
}
function DiscardKey(value, key) {
	let { [key]: _, ...rest } = value;
	return rest;
}
function Discard(value, keys) {
	return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
function Never(options) {
	return CreateType({ [Kind]: "Never", not: {} }, options);
}
function MappedResult(properties) {
	return CreateType({ [Kind]: "MappedResult", properties });
}
function Constructor(parameters, returns, options) {
	return CreateType(
		{ [Kind]: "Constructor", type: "Constructor", parameters, returns },
		options,
	);
}
function Function2(parameters, returns, options) {
	return CreateType(
		{ [Kind]: "Function", type: "Function", parameters, returns },
		options,
	);
}
function UnionCreate(T, options) {
	return CreateType({ [Kind]: "Union", anyOf: T }, options);
}
function IsUnionOptional(types) {
	return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
	return types.map((left) =>
		IsOptional(left) ? RemoveOptionalFromType(left) : left,
	);
}
function RemoveOptionalFromType(T) {
	return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
	return IsUnionOptional(types)
		? Optional(UnionCreate(RemoveOptionalFromRest(types), options))
		: UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
	return T.length === 1
		? CreateType(T[0], options)
		: T.length === 0
			? Never(options)
			: ResolveUnion(T, options);
}
function Union(types, options) {
	return types.length === 0
		? Never(options)
		: types.length === 1
			? CreateType(types[0], options)
			: UnionCreate(types, options);
}
class TemplateLiteralParserError extends TypeBoxError {}
function Unescape(pattern) {
	return pattern
		.replace(/\\\$/g, "$")
		.replace(/\\\*/g, "*")
		.replace(/\\\^/g, "^")
		.replace(/\\\|/g, "|")
		.replace(/\\\(/g, "(")
		.replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
	return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
	return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
	return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
	return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
	if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
		return !1;
	let count = 0;
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (count === 0 && index !== pattern.length - 1) return !1;
	}
	return !0;
}
function InGroup(pattern) {
	return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
	let count = 0;
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (IsSeparator(pattern, index) && count === 0) return !0;
	}
	return !1;
}
function IsPrecedenceAnd(pattern) {
	for (let index = 0; index < pattern.length; index++)
		if (IsOpenParen(pattern, index)) return !0;
	return !1;
}
function Or(pattern) {
	let [count, start] = [0, 0],
		expressions = [];
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (IsSeparator(pattern, index) && count === 0) {
			let range2 = pattern.slice(start, index);
			if (range2.length > 0) expressions.push(TemplateLiteralParse(range2));
			start = index + 1;
		}
	}
	let range = pattern.slice(start);
	if (range.length > 0) expressions.push(TemplateLiteralParse(range));
	if (expressions.length === 0) return { type: "const", const: "" };
	if (expressions.length === 1) return expressions[0];
	return { type: "or", expr: expressions };
}
function And(pattern) {
	function Group(value, index) {
		if (!IsOpenParen(value, index))
			throw new TemplateLiteralParserError(
				"TemplateLiteralParser: Index must point to open parens",
			);
		let count = 0;
		for (let scan = index; scan < value.length; scan++) {
			if (IsOpenParen(value, scan)) count += 1;
			if (IsCloseParen(value, scan)) count -= 1;
			if (count === 0) return [index, scan];
		}
		throw new TemplateLiteralParserError(
			"TemplateLiteralParser: Unclosed group parens in expression",
		);
	}
	function Range(pattern2, index) {
		for (let scan = index; scan < pattern2.length; scan++)
			if (IsOpenParen(pattern2, scan)) return [index, scan];
		return [index, pattern2.length];
	}
	let expressions = [];
	for (let index = 0; index < pattern.length; index++)
		if (IsOpenParen(pattern, index)) {
			let [start, end] = Group(pattern, index),
				range = pattern.slice(start, end + 1);
			expressions.push(TemplateLiteralParse(range)), (index = end);
		} else {
			let [start, end] = Range(pattern, index),
				range = pattern.slice(start, end);
			if (range.length > 0) expressions.push(TemplateLiteralParse(range));
			index = end - 1;
		}
	return expressions.length === 0
		? { type: "const", const: "" }
		: expressions.length === 1
			? expressions[0]
			: { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
	return IsGroup(pattern)
		? TemplateLiteralParse(InGroup(pattern))
		: IsPrecedenceOr(pattern)
			? Or(pattern)
			: IsPrecedenceAnd(pattern)
				? And(pattern)
				: { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
	return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}
class TemplateLiteralFiniteError extends TypeBoxError {}
function IsNumberExpression(expression) {
	return (
		expression.type === "or" &&
		expression.expr.length === 2 &&
		expression.expr[0].type === "const" &&
		expression.expr[0].const === "0" &&
		expression.expr[1].type === "const" &&
		expression.expr[1].const === "[1-9][0-9]*"
	);
}
function IsBooleanExpression(expression) {
	return (
		expression.type === "or" &&
		expression.expr.length === 2 &&
		expression.expr[0].type === "const" &&
		expression.expr[0].const === "true" &&
		expression.expr[1].type === "const" &&
		expression.expr[1].const === "false"
	);
}
function IsStringExpression(expression) {
	return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
	return IsNumberExpression(expression) || IsStringExpression(expression)
		? !1
		: IsBooleanExpression(expression)
			? !0
			: expression.type === "and"
				? expression.expr.every((expr) =>
						IsTemplateLiteralExpressionFinite(expr),
					)
				: expression.type === "or"
					? expression.expr.every((expr) =>
							IsTemplateLiteralExpressionFinite(expr),
						)
					: expression.type === "const"
						? !0
						: (() => {
								throw new TemplateLiteralFiniteError("Unknown expression type");
							})();
}
function IsTemplateLiteralFinite(schema) {
	let expression = TemplateLiteralParseExact(schema.pattern);
	return IsTemplateLiteralExpressionFinite(expression);
}
class TemplateLiteralGenerateError extends TypeBoxError {}
function* GenerateReduce(buffer) {
	if (buffer.length === 1) return yield* buffer[0];
	for (let left of buffer[0])
		for (let right of GenerateReduce(buffer.slice(1))) yield `${left}${right}`;
}
function* GenerateAnd(expression) {
	return yield* GenerateReduce(
		expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]),
	);
}
function* GenerateOr(expression) {
	for (let expr of expression.expr)
		yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
	return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
	return expression.type === "and"
		? yield* GenerateAnd(expression)
		: expression.type === "or"
			? yield* GenerateOr(expression)
			: expression.type === "const"
				? yield* GenerateConst(expression)
				: (() => {
						throw new TemplateLiteralGenerateError("Unknown expression");
					})();
}
function TemplateLiteralGenerate(schema) {
	let expression = TemplateLiteralParseExact(schema.pattern);
	return IsTemplateLiteralExpressionFinite(expression)
		? [...TemplateLiteralExpressionGenerate(expression)]
		: [];
}
function Literal(value, options) {
	return CreateType(
		{ [Kind]: "Literal", const: value, type: typeof value },
		options,
	);
}
function Boolean2(options) {
	return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}
function BigInt2(options) {
	return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}
function Number2(options) {
	return CreateType({ [Kind]: "Number", type: "number" }, options);
}
function String2(options) {
	return CreateType({ [Kind]: "String", type: "string" }, options);
}
function* FromUnion(syntax) {
	let trim = syntax.trim().replace(/"|'/g, "");
	return trim === "boolean"
		? yield Boolean2()
		: trim === "number"
			? yield Number2()
			: trim === "bigint"
				? yield BigInt2()
				: trim === "string"
					? yield String2()
					: yield (() => {
							let literals = trim
								.split("|")
								.map((literal) => Literal(literal.trim()));
							return literals.length === 0
								? Never()
								: literals.length === 1
									? literals[0]
									: UnionEvaluated(literals);
						})();
}
function* FromTerminal(syntax) {
	if (syntax[1] !== "{") {
		let L = Literal("$"),
			R = FromSyntax(syntax.slice(1));
		return yield* [L, ...R];
	}
	for (let i = 2; i < syntax.length; i++)
		if (syntax[i] === "}") {
			let L = FromUnion(syntax.slice(2, i)),
				R = FromSyntax(syntax.slice(i + 1));
			return yield* [...L, ...R];
		}
	yield Literal(syntax);
}
function* FromSyntax(syntax) {
	for (let i = 0; i < syntax.length; i++)
		if (syntax[i] === "$") {
			let L = Literal(syntax.slice(0, i)),
				R = FromTerminal(syntax.slice(i));
			return yield* [L, ...R];
		}
	yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
	return [...FromSyntax(syntax)];
}
class TemplateLiteralPatternError extends TypeBoxError {}
function Escape(value) {
	return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
	return IsTemplateLiteral(schema)
		? schema.pattern.slice(1, schema.pattern.length - 1)
		: IsUnion(schema)
			? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})`
			: IsNumber3(schema)
				? `${acc}${PatternNumber}`
				: IsInteger2(schema)
					? `${acc}${PatternNumber}`
					: IsBigInt3(schema)
						? `${acc}${PatternNumber}`
						: IsString3(schema)
							? `${acc}${PatternString}`
							: IsLiteral(schema)
								? `${acc}${Escape(schema.const.toString())}`
								: IsBoolean3(schema)
									? `${acc}${PatternBoolean}`
									: (() => {
											throw new TemplateLiteralPatternError(
												`Unexpected Kind '${schema[Kind]}'`,
											);
										})();
}
function TemplateLiteralPattern(kinds) {
	return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
function TemplateLiteralToUnion(schema) {
	let L = TemplateLiteralGenerate(schema).map((S) => Literal(S));
	return UnionEvaluated(L);
}
function TemplateLiteral(unresolved, options) {
	let pattern = IsString(unresolved)
		? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))
		: TemplateLiteralPattern(unresolved);
	return CreateType(
		{ [Kind]: "TemplateLiteral", type: "string", pattern },
		options,
	);
}
function FromTemplateLiteral(templateLiteral) {
	return TemplateLiteralGenerate(templateLiteral).map((key) => key.toString());
}
function FromUnion2(types) {
	let result = [];
	for (let type of types) result.push(...IndexPropertyKeys(type));
	return result;
}
function FromLiteral(literalValue) {
	return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
	return [
		...new Set(
			IsTemplateLiteral(type)
				? FromTemplateLiteral(type)
				: IsUnion(type)
					? FromUnion2(type.anyOf)
					: IsLiteral(type)
						? FromLiteral(type.const)
						: IsNumber3(type)
							? ["[number]"]
							: IsInteger2(type)
								? ["[number]"]
								: [],
		),
	];
}
function FromProperties(type, properties, options) {
	let result = {};
	for (let K2 of Object.getOwnPropertyNames(properties))
		result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
	return result;
}
function FromMappedResult(type, mappedResult, options) {
	return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
	let properties = FromMappedResult(type, mappedResult, options);
	return MappedResult(properties);
}
function FromRest(types, key) {
	return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
	return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
	return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
	return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
	return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
	return key in types
		? types[key]
		: key === "[number]"
			? UnionEvaluated(types)
			: Never();
}
function FromArray(type, key) {
	return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
	return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
	return IsIntersect(type)
		? FromIntersect(type.allOf, propertyKey)
		: IsUnion(type)
			? FromUnion3(type.anyOf, propertyKey)
			: IsTuple(type)
				? FromTuple(type.items ?? [], propertyKey)
				: IsArray3(type)
					? FromArray(type.items, propertyKey)
					: IsObject3(type)
						? FromProperty(type.properties, propertyKey)
						: Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
	return propertyKeys.map((propertyKey) =>
		IndexFromPropertyKey(type, propertyKey),
	);
}
function FromSchema(type, propertyKeys) {
	return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
	if (IsRef(type) || IsRef(key)) {
		if (!IsSchema(type) || !IsSchema(key))
			throw new TypeBoxError(
				"Index types using Ref parameters require both Type and Key to be of TSchema",
			);
		return Computed("Index", [type, key]);
	}
	if (IsMappedResult(key)) return IndexFromMappedResult(type, key, options);
	if (IsMappedKey(key)) return IndexFromMappedKey(type, key, options);
	return CreateType(
		IsSchema(key)
			? FromSchema(type, IndexPropertyKeys(key))
			: FromSchema(type, key),
		options,
	);
}
function MappedIndexPropertyKey(type, key, options) {
	return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
	return propertyKeys.reduce((result, left) => {
		return { ...result, ...MappedIndexPropertyKey(type, left, options) };
	}, {});
}
function MappedIndexProperties(type, mappedKey, options) {
	return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
	let properties = MappedIndexProperties(type, mappedKey, options);
	return MappedResult(properties);
}
function Iterator(items, options) {
	return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}
function RequiredKeys(properties) {
	let keys = [];
	for (let key in properties) if (!IsOptional(properties[key])) keys.push(key);
	return keys;
}
function _Object(properties, options) {
	let required = RequiredKeys(properties),
		schematic =
			required.length > 0
				? { [Kind]: "Object", type: "object", properties, required }
				: { [Kind]: "Object", type: "object", properties };
	return CreateType(schematic, options);
}
var Object2 = _Object;
function Promise2(item, options) {
	return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}
function RemoveReadonly(schema) {
	return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
	return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
	return F === !1 ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
	let F = enable ?? !0;
	return IsMappedResult(schema)
		? ReadonlyFromMappedResult(schema, F)
		: ReadonlyWithFlag(schema, F);
}
function FromProperties2(K, F) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(K))
		Acc[K2] = Readonly(K[K2], F);
	return Acc;
}
function FromMappedResult2(R, F) {
	return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
	let P = FromMappedResult2(R, F);
	return MappedResult(P);
}
function Tuple(types, options) {
	return CreateType(
		types.length > 0
			? {
					[Kind]: "Tuple",
					type: "array",
					items: types,
					additionalItems: !1,
					minItems: types.length,
					maxItems: types.length,
				}
			: {
					[Kind]: "Tuple",
					type: "array",
					minItems: types.length,
					maxItems: types.length,
				},
		options,
	);
}
function FromMappedResult3(K, P) {
	return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
	return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
	let Acc = {};
	for (let L of P) Acc[L] = Literal(L);
	return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
	return SetIncludes(P, K)
		? MappedKeyToKnownMappedResultProperties(K)
		: MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
	let R = MappedKeyToMappedResultProperties(K, P);
	return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
	return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(T))
		Acc[K2] = FromSchemaType(K, T[K2]);
	return Acc;
}
function FromSchemaType(K, T) {
	let options = { ...T };
	return IsOptional(T)
		? Optional(FromSchemaType(K, Discard(T, [OptionalKind])))
		: IsReadonly(T)
			? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind])))
			: IsMappedResult(T)
				? FromMappedResult3(K, T.properties)
				: IsMappedKey(T)
					? FromMappedKey(K, T.keys)
					: IsConstructor(T)
						? Constructor(
								FromRest2(K, T.parameters),
								FromSchemaType(K, T.returns),
								options,
							)
						: IsFunction3(T)
							? Function2(
									FromRest2(K, T.parameters),
									FromSchemaType(K, T.returns),
									options,
								)
							: IsAsyncIterator3(T)
								? AsyncIterator(FromSchemaType(K, T.items), options)
								: IsIterator3(T)
									? Iterator(FromSchemaType(K, T.items), options)
									: IsIntersect(T)
										? Intersect(FromRest2(K, T.allOf), options)
										: IsUnion(T)
											? Union(FromRest2(K, T.anyOf), options)
											: IsTuple(T)
												? Tuple(FromRest2(K, T.items ?? []), options)
												: IsObject3(T)
													? Object2(FromProperties3(K, T.properties), options)
													: IsArray3(T)
														? Array2(FromSchemaType(K, T.items), options)
														: IsPromise2(T)
															? Promise2(FromSchemaType(K, T.item), options)
															: T;
}
function MappedFunctionReturnType(K, T) {
	let Acc = {};
	for (let L of K) Acc[L] = FromSchemaType(L, T);
	return Acc;
}
function Mapped(key, map3, options) {
	let K = IsSchema(key) ? IndexPropertyKeys(key) : key,
		RT = map3({ [Kind]: "MappedKey", keys: K }),
		R = MappedFunctionReturnType(K, RT);
	return Object2(R, options);
}
function RemoveOptional(schema) {
	return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
	return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
	return F === !1 ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
	let F = enable ?? !0;
	return IsMappedResult(schema)
		? OptionalFromMappedResult(schema, F)
		: OptionalWithFlag(schema, F);
}
function FromProperties4(P, F) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Optional(P[K2], F);
	return Acc;
}
function FromMappedResult4(R, F) {
	return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
	let P = FromMappedResult4(R, F);
	return MappedResult(P);
}
function IntersectCreate(T, options = {}) {
	let allObjects = T.every((schema) => IsObject3(schema)),
		clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties)
			? { unevaluatedProperties: options.unevaluatedProperties }
			: {};
	return CreateType(
		options.unevaluatedProperties === !1 ||
			IsSchema(options.unevaluatedProperties) ||
			allObjects
			? {
					...clonedUnevaluatedProperties,
					[Kind]: "Intersect",
					type: "object",
					allOf: T,
				}
			: { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T },
		options,
	);
}
function IsIntersectOptional(types) {
	return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
	return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
	return types.map((left) =>
		IsOptional(left) ? RemoveOptionalFromType2(left) : left,
	);
}
function ResolveIntersect(types, options) {
	return IsIntersectOptional(types)
		? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options))
		: IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
	if (types.length === 1) return CreateType(types[0], options);
	if (types.length === 0) return Never(options);
	if (types.some((schema) => IsTransform(schema)))
		throw new Error("Cannot intersect transform types");
	return ResolveIntersect(types, options);
}
function Intersect(types, options) {
	if (types.length === 1) return CreateType(types[0], options);
	if (types.length === 0) return Never(options);
	if (types.some((schema) => IsTransform(schema)))
		throw new Error("Cannot intersect transform types");
	return IntersectCreate(types, options);
}
function Ref(...args) {
	let [$ref, options] =
		typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
	if (typeof $ref !== "string")
		throw new TypeBoxError("Ref: $ref must be a string");
	return CreateType({ [Kind]: "Ref", $ref }, options);
}
function FromComputed(target, parameters) {
	return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
	return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
	return Intersect(FromRest3(types));
}
function FromUnion4(types) {
	return Union(FromRest3(types));
}
function FromPromise(type) {
	return Awaited(type);
}
function FromRest3(types) {
	return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
	return CreateType(
		IsComputed(type)
			? FromComputed(type.target, type.parameters)
			: IsIntersect(type)
				? FromIntersect2(type.allOf)
				: IsUnion(type)
					? FromUnion4(type.anyOf)
					: IsPromise2(type)
						? FromPromise(type.item)
						: IsRef(type)
							? FromRef(type.$ref)
							: type,
		options,
	);
}
function FromRest4(types) {
	let result = [];
	for (let L of types) result.push(KeyOfPropertyKeys(L));
	return result;
}
function FromIntersect3(types) {
	let propertyKeysArray = FromRest4(types);
	return SetUnionMany(propertyKeysArray);
}
function FromUnion5(types) {
	let propertyKeysArray = FromRest4(types);
	return SetIntersectMany(propertyKeysArray);
}
function FromTuple2(types) {
	return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
	return ["[number]"];
}
function FromProperties5(T) {
	return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
	if (!includePatternProperties) return [];
	return globalThis.Object.getOwnPropertyNames(patternProperties).map((key) => {
		return key[0] === "^" && key[key.length - 1] === "$"
			? key.slice(1, key.length - 1)
			: key;
	});
}
function KeyOfPropertyKeys(type) {
	return IsIntersect(type)
		? FromIntersect3(type.allOf)
		: IsUnion(type)
			? FromUnion5(type.anyOf)
			: IsTuple(type)
				? FromTuple2(type.items ?? [])
				: IsArray3(type)
					? FromArray2(type.items)
					: IsObject3(type)
						? FromProperties5(type.properties)
						: IsRecord(type)
							? FromPatternProperties(type.patternProperties)
							: [];
}
var includePatternProperties = !1;
function KeyOfPattern(schema) {
	includePatternProperties = !0;
	let keys = KeyOfPropertyKeys(schema);
	return (
		(includePatternProperties = !1),
		`^(${keys.map((key) => `(${key})`).join("|")})$`
	);
}
function FromComputed2(target, parameters) {
	return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
	return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
	let propertyKeys = KeyOfPropertyKeys(type),
		propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys),
		result = UnionEvaluated(propertyKeyTypes);
	return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
	return propertyKeys.map((L) => (L === "[number]" ? Number2() : Literal(L)));
}
function KeyOf(type, options) {
	return IsComputed(type)
		? FromComputed2(type.target, type.parameters)
		: IsRef(type)
			? FromRef2(type.$ref)
			: IsMappedResult(type)
				? KeyOfFromMappedResult(type, options)
				: KeyOfFromType(type, options);
}
function FromProperties6(properties, options) {
	let result = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = KeyOf(properties[K2], Clone(options));
	return result;
}
function FromMappedResult5(mappedResult, options) {
	return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
	let properties = FromMappedResult5(mappedResult, options);
	return MappedResult(properties);
}
function KeyOfPropertyEntries(schema) {
	let keys = KeyOfPropertyKeys(schema),
		schemas = IndexFromPropertyKeys(schema, keys);
	return keys.map((_, index) => [keys[index], schemas[index]]);
}
function CompositeKeys(T) {
	let Acc = [];
	for (let L of T) Acc.push(...KeyOfPropertyKeys(L));
	return SetDistinct(Acc);
}
function FilterNever(T) {
	return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
	let Acc = [];
	for (let L of T) Acc.push(...IndexFromPropertyKeys(L, [K]));
	return FilterNever(Acc);
}
function CompositeProperties(T, K) {
	let Acc = {};
	for (let L of K) Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
	return Acc;
}
function Composite(T, options) {
	let K = CompositeKeys(T),
		P = CompositeProperties(T, K);
	return Object2(P, options);
}
function Date2(options) {
	return CreateType({ [Kind]: "Date", type: "Date" }, options);
}
function Null(options) {
	return CreateType({ [Kind]: "Null", type: "null" }, options);
}
function Symbol2(options) {
	return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}
function Undefined(options) {
	return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}
function Uint8Array2(options) {
	return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}
function Unknown(options) {
	return CreateType({ [Kind]: "Unknown" }, options);
}
function FromArray3(T) {
	return T.map((L) => FromValue(L, !1));
}
function FromProperties7(value) {
	let Acc = {};
	for (let K of globalThis.Object.getOwnPropertyNames(value))
		Acc[K] = Readonly(FromValue(value[K], !1));
	return Acc;
}
function ConditionalReadonly(T, root) {
	return root === !0 ? T : Readonly(T);
}
function FromValue(value, root) {
	return IsAsyncIterator(value)
		? ConditionalReadonly(Any(), root)
		: IsIterator(value)
			? ConditionalReadonly(Any(), root)
			: IsArray(value)
				? Readonly(Tuple(FromArray3(value)))
				: IsUint8Array(value)
					? Uint8Array2()
					: IsDate(value)
						? Date2()
						: IsObject(value)
							? ConditionalReadonly(Object2(FromProperties7(value)), root)
							: IsFunction(value)
								? ConditionalReadonly(Function2([], Unknown()), root)
								: IsUndefined(value)
									? Undefined()
									: IsNull(value)
										? Null()
										: IsSymbol(value)
											? Symbol2()
											: IsBigInt(value)
												? BigInt2()
												: IsNumber(value)
													? Literal(value)
													: IsBoolean(value)
														? Literal(value)
														: IsString(value)
															? Literal(value)
															: Object2({});
}
function Const(T, options) {
	return CreateType(FromValue(T, !0), options);
}
function ConstructorParameters(schema, options) {
	return IsConstructor(schema)
		? Tuple(schema.parameters, options)
		: Never(options);
}
function Enum(item, options) {
	if (IsUndefined(item)) throw new Error("Enum undefined or empty");
	let values1 = globalThis.Object.getOwnPropertyNames(item)
			.filter((key) => isNaN(key))
			.map((key) => item[key]),
		anyOf = [...new Set(values1)].map((value) => Literal(value));
	return Union(anyOf, { ...options, [Hint]: "Enum" });
}
class ExtendsResolverError extends TypeBoxError {}
var ExtendsResult;
(function (ExtendsResult2) {
	(ExtendsResult2[(ExtendsResult2.Union = 0)] = "Union"),
		(ExtendsResult2[(ExtendsResult2.True = 1)] = "True"),
		(ExtendsResult2[(ExtendsResult2.False = 2)] = "False");
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
	return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
	throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
	return (
		exports_type.IsNever(right) ||
		exports_type.IsIntersect(right) ||
		exports_type.IsUnion(right) ||
		exports_type.IsUnknown(right) ||
		exports_type.IsAny(right)
	);
}
function StructuralRight(left, right) {
	return exports_type.IsNever(right)
		? FromNeverRight(left, right)
		: exports_type.IsIntersect(right)
			? FromIntersectRight(left, right)
			: exports_type.IsUnion(right)
				? FromUnionRight(left, right)
				: exports_type.IsUnknown(right)
					? FromUnknownRight(left, right)
					: exports_type.IsAny(right)
						? FromAnyRight(left, right)
						: Throw("StructuralRight");
}
function FromAnyRight(left, right) {
	return ExtendsResult.True;
}
function FromAny(left, right) {
	return exports_type.IsIntersect(right)
		? FromIntersectRight(left, right)
		: exports_type.IsUnion(right) &&
				right.anyOf.some(
					(schema) =>
						exports_type.IsAny(schema) || exports_type.IsUnknown(schema),
				)
			? ExtendsResult.True
			: exports_type.IsUnion(right)
				? ExtendsResult.Union
				: exports_type.IsUnknown(right)
					? ExtendsResult.True
					: exports_type.IsAny(right)
						? ExtendsResult.True
						: ExtendsResult.Union;
}
function FromArrayRight(left, right) {
	return exports_type.IsUnknown(left)
		? ExtendsResult.False
		: exports_type.IsAny(left)
			? ExtendsResult.Union
			: exports_type.IsNever(left)
				? ExtendsResult.True
				: ExtendsResult.False;
}
function FromArray4(left, right) {
	return exports_type.IsObject(right) && IsObjectArrayLike(right)
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: !exports_type.IsArray(right)
				? ExtendsResult.False
				: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: !exports_type.IsAsyncIterator(right)
			? ExtendsResult.False
			: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsBigInt(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromBooleanRight(left, right) {
	return exports_type.IsLiteralBoolean(left)
		? ExtendsResult.True
		: exports_type.IsBoolean(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromBoolean(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsBoolean(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromConstructor(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsConstructor(right)
				? ExtendsResult.False
				: left.parameters.length > right.parameters.length
					? ExtendsResult.False
					: !left.parameters.every(
								(schema, index) =>
									IntoBooleanResult(Visit3(right.parameters[index], schema)) ===
									ExtendsResult.True,
							)
						? ExtendsResult.False
						: IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsDate(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromFunction(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsFunction(right)
				? ExtendsResult.False
				: left.parameters.length > right.parameters.length
					? ExtendsResult.False
					: !left.parameters.every(
								(schema, index) =>
									IntoBooleanResult(Visit3(right.parameters[index], schema)) ===
									ExtendsResult.True,
							)
						? ExtendsResult.False
						: IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
	return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const)
		? ExtendsResult.True
		: exports_type.IsNumber(left) || exports_type.IsInteger(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromInteger(left, right) {
	return exports_type.IsInteger(right) || exports_type.IsNumber(right)
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: exports_type.IsObject(right)
				? FromObjectRight(left, right)
				: exports_type.IsRecord(right)
					? FromRecordRight(left, right)
					: ExtendsResult.False;
}
function FromIntersectRight(left, right) {
	return right.allOf.every(
		(schema) => Visit3(left, schema) === ExtendsResult.True,
	)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromIntersect4(left, right) {
	return left.allOf.some(
		(schema) => Visit3(schema, right) === ExtendsResult.True,
	)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromIterator(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: !exports_type.IsIterator(right)
			? ExtendsResult.False
			: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
	return exports_type.IsLiteral(right) && right.const === left.const
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: exports_type.IsObject(right)
				? FromObjectRight(left, right)
				: exports_type.IsRecord(right)
					? FromRecordRight(left, right)
					: exports_type.IsString(right)
						? FromStringRight(left, right)
						: exports_type.IsNumber(right)
							? FromNumberRight(left, right)
							: exports_type.IsInteger(right)
								? FromIntegerRight(left, right)
								: exports_type.IsBoolean(right)
									? FromBooleanRight(left, right)
									: ExtendsResult.False;
}
function FromNeverRight(left, right) {
	return ExtendsResult.False;
}
function FromNever(left, right) {
	return ExtendsResult.True;
}
function UnwrapTNot(schema) {
	let [current, depth] = [schema, 0];
	while (!0) {
		if (!exports_type.IsNot(current)) break;
		(current = current.not), (depth += 1);
	}
	return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
	return exports_type.IsNot(left)
		? Visit3(UnwrapTNot(left), right)
		: exports_type.IsNot(right)
			? Visit3(left, UnwrapTNot(right))
			: Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsNull(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromNumberRight(left, right) {
	return exports_type.IsLiteralNumber(left)
		? ExtendsResult.True
		: exports_type.IsNumber(left) || exports_type.IsInteger(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromNumber(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsInteger(right) || exports_type.IsNumber(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
	return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
	return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"description" in schema.properties &&
			exports_type.IsUnion(schema.properties.description) &&
			schema.properties.description.anyOf.length === 2 &&
			((exports_type.IsString(schema.properties.description.anyOf[0]) &&
				exports_type.IsUndefined(schema.properties.description.anyOf[1])) ||
				(exports_type.IsString(schema.properties.description.anyOf[1]) &&
					exports_type.IsUndefined(schema.properties.description.anyOf[0]))))
	);
}
function IsObjectNumberLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
	return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
	let length = Number2();
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"length" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties.length, length)) ===
				ExtendsResult.True)
	);
}
function IsObjectConstructorLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
	let length = Number2();
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"length" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties.length, length)) ===
				ExtendsResult.True)
	);
}
function IsObjectPromiseLike(schema) {
	let then = Function2([Any()], Any());
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"then" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties.then, then)) ===
				ExtendsResult.True)
	);
}
function Property(left, right) {
	return Visit3(left, right) === ExtendsResult.False
		? ExtendsResult.False
		: exports_type.IsOptional(left) && !exports_type.IsOptional(right)
			? ExtendsResult.False
			: ExtendsResult.True;
}
function FromObjectRight(left, right) {
	return exports_type.IsUnknown(left)
		? ExtendsResult.False
		: exports_type.IsAny(left)
			? ExtendsResult.Union
			: exports_type.IsNever(left) ||
					(exports_type.IsLiteralString(left) && IsObjectStringLike(right)) ||
					(exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||
					(exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
					(exports_type.IsSymbol(left) && IsObjectSymbolLike(right)) ||
					(exports_type.IsBigInt(left) && IsObjectBigIntLike(right)) ||
					(exports_type.IsString(left) && IsObjectStringLike(right)) ||
					(exports_type.IsSymbol(left) && IsObjectSymbolLike(right)) ||
					(exports_type.IsNumber(left) && IsObjectNumberLike(right)) ||
					(exports_type.IsInteger(left) && IsObjectNumberLike(right)) ||
					(exports_type.IsBoolean(left) && IsObjectBooleanLike(right)) ||
					(exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||
					(exports_type.IsDate(left) && IsObjectDateLike(right)) ||
					(exports_type.IsConstructor(left) &&
						IsObjectConstructorLike(right)) ||
					(exports_type.IsFunction(left) && IsObjectFunctionLike(right))
				? ExtendsResult.True
				: exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left))
					? (() => {
							return right[Hint] === "Record"
								? ExtendsResult.True
								: ExtendsResult.False;
						})()
					: exports_type.IsRecord(left) &&
							exports_type.IsNumber(RecordKey(left))
						? (() => {
								return IsObjectPropertyCount(right, 0)
									? ExtendsResult.True
									: ExtendsResult.False;
							})()
						: ExtendsResult.False;
}
function FromObject(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsRecord(right)
			? FromRecordRight(left, right)
			: !exports_type.IsObject(right)
				? ExtendsResult.False
				: (() => {
						for (let key of Object.getOwnPropertyNames(right.properties)) {
							if (
								!(key in left.properties) &&
								!exports_type.IsOptional(right.properties[key])
							)
								return ExtendsResult.False;
							if (exports_type.IsOptional(right.properties[key]))
								return ExtendsResult.True;
							if (
								Property(left.properties[key], right.properties[key]) ===
								ExtendsResult.False
							)
								return ExtendsResult.False;
						}
						return ExtendsResult.True;
					})();
}
function FromPromise2(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right) && IsObjectPromiseLike(right)
			? ExtendsResult.True
			: !exports_type.IsPromise(right)
				? ExtendsResult.False
				: IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
	return PatternNumberExact in schema.patternProperties
		? Number2()
		: PatternStringExact in schema.patternProperties
			? String2()
			: Throw("Unknown record key pattern");
}
function RecordValue(schema) {
	return PatternNumberExact in schema.patternProperties
		? schema.patternProperties[PatternNumberExact]
		: PatternStringExact in schema.patternProperties
			? schema.patternProperties[PatternStringExact]
			: Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
	let [Key, Value] = [RecordKey(right), RecordValue(right)];
	return exports_type.IsLiteralString(left) &&
		exports_type.IsNumber(Key) &&
		IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True
		? ExtendsResult.True
		: exports_type.IsUint8Array(left) && exports_type.IsNumber(Key)
			? Visit3(left, Value)
			: exports_type.IsString(left) && exports_type.IsNumber(Key)
				? Visit3(left, Value)
				: exports_type.IsArray(left) && exports_type.IsNumber(Key)
					? Visit3(left, Value)
					: exports_type.IsObject(left)
						? (() => {
								for (let key of Object.getOwnPropertyNames(left.properties))
									if (
										Property(Value, left.properties[key]) ===
										ExtendsResult.False
									)
										return ExtendsResult.False;
								return ExtendsResult.True;
							})()
						: ExtendsResult.False;
}
function FromRecord(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsRecord(right)
				? ExtendsResult.False
				: Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
	let L = exports_type.IsRegExp(left) ? String2() : left,
		R = exports_type.IsRegExp(right) ? String2() : right;
	return Visit3(L, R);
}
function FromStringRight(left, right) {
	return exports_type.IsLiteral(left) && exports_value.IsString(left.const)
		? ExtendsResult.True
		: exports_type.IsString(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromString(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsString(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromSymbol(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsSymbol(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
	return exports_type.IsTemplateLiteral(left)
		? Visit3(TemplateLiteralToUnion(left), right)
		: exports_type.IsTemplateLiteral(right)
			? Visit3(left, TemplateLiteralToUnion(right))
			: Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
	return (
		exports_type.IsArray(right) &&
		left.items !== void 0 &&
		left.items.every(
			(schema) => Visit3(schema, right.items) === ExtendsResult.True,
		)
	);
}
function FromTupleRight(left, right) {
	return exports_type.IsNever(left)
		? ExtendsResult.True
		: exports_type.IsUnknown(left)
			? ExtendsResult.False
			: exports_type.IsAny(left)
				? ExtendsResult.Union
				: ExtendsResult.False;
}
function FromTuple3(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right) && IsObjectArrayLike(right)
			? ExtendsResult.True
			: exports_type.IsArray(right) && IsArrayOfTuple(left, right)
				? ExtendsResult.True
				: !exports_type.IsTuple(right)
					? ExtendsResult.False
					: (exports_value.IsUndefined(left.items) &&
								!exports_value.IsUndefined(right.items)) ||
							(!exports_value.IsUndefined(left.items) &&
								exports_value.IsUndefined(right.items))
						? ExtendsResult.False
						: exports_value.IsUndefined(left.items) &&
								!exports_value.IsUndefined(right.items)
							? ExtendsResult.True
							: left.items.every(
										(schema, index) =>
											Visit3(schema, right.items[index]) === ExtendsResult.True,
									)
								? ExtendsResult.True
								: ExtendsResult.False;
}
function FromUint8Array(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsUint8Array(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromUndefined(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsVoid(right)
					? FromVoidRight(left, right)
					: exports_type.IsUndefined(right)
						? ExtendsResult.True
						: ExtendsResult.False;
}
function FromUnionRight(left, right) {
	return right.anyOf.some(
		(schema) => Visit3(left, schema) === ExtendsResult.True,
	)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromUnion6(left, right) {
	return left.anyOf.every(
		(schema) => Visit3(schema, right) === ExtendsResult.True,
	)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromUnknownRight(left, right) {
	return ExtendsResult.True;
}
function FromUnknown(left, right) {
	return exports_type.IsNever(right)
		? FromNeverRight(left, right)
		: exports_type.IsIntersect(right)
			? FromIntersectRight(left, right)
			: exports_type.IsUnion(right)
				? FromUnionRight(left, right)
				: exports_type.IsAny(right)
					? FromAnyRight(left, right)
					: exports_type.IsString(right)
						? FromStringRight(left, right)
						: exports_type.IsNumber(right)
							? FromNumberRight(left, right)
							: exports_type.IsInteger(right)
								? FromIntegerRight(left, right)
								: exports_type.IsBoolean(right)
									? FromBooleanRight(left, right)
									: exports_type.IsArray(right)
										? FromArrayRight(left, right)
										: exports_type.IsTuple(right)
											? FromTupleRight(left, right)
											: exports_type.IsObject(right)
												? FromObjectRight(left, right)
												: exports_type.IsUnknown(right)
													? ExtendsResult.True
													: ExtendsResult.False;
}
function FromVoidRight(left, right) {
	return exports_type.IsUndefined(left)
		? ExtendsResult.True
		: exports_type.IsUndefined(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromVoid(left, right) {
	return exports_type.IsIntersect(right)
		? FromIntersectRight(left, right)
		: exports_type.IsUnion(right)
			? FromUnionRight(left, right)
			: exports_type.IsUnknown(right)
				? FromUnknownRight(left, right)
				: exports_type.IsAny(right)
					? FromAnyRight(left, right)
					: exports_type.IsObject(right)
						? FromObjectRight(left, right)
						: exports_type.IsVoid(right)
							? ExtendsResult.True
							: ExtendsResult.False;
}
function Visit3(left, right) {
	return exports_type.IsTemplateLiteral(left) ||
		exports_type.IsTemplateLiteral(right)
		? FromTemplateLiteral2(left, right)
		: exports_type.IsRegExp(left) || exports_type.IsRegExp(right)
			? FromRegExp(left, right)
			: exports_type.IsNot(left) || exports_type.IsNot(right)
				? FromNot(left, right)
				: exports_type.IsAny(left)
					? FromAny(left, right)
					: exports_type.IsArray(left)
						? FromArray4(left, right)
						: exports_type.IsBigInt(left)
							? FromBigInt(left, right)
							: exports_type.IsBoolean(left)
								? FromBoolean(left, right)
								: exports_type.IsAsyncIterator(left)
									? FromAsyncIterator(left, right)
									: exports_type.IsConstructor(left)
										? FromConstructor(left, right)
										: exports_type.IsDate(left)
											? FromDate(left, right)
											: exports_type.IsFunction(left)
												? FromFunction(left, right)
												: exports_type.IsInteger(left)
													? FromInteger(left, right)
													: exports_type.IsIntersect(left)
														? FromIntersect4(left, right)
														: exports_type.IsIterator(left)
															? FromIterator(left, right)
															: exports_type.IsLiteral(left)
																? FromLiteral2(left, right)
																: exports_type.IsNever(left)
																	? FromNever(left, right)
																	: exports_type.IsNull(left)
																		? FromNull(left, right)
																		: exports_type.IsNumber(left)
																			? FromNumber(left, right)
																			: exports_type.IsObject(left)
																				? FromObject(left, right)
																				: exports_type.IsRecord(left)
																					? FromRecord(left, right)
																					: exports_type.IsString(left)
																						? FromString(left, right)
																						: exports_type.IsSymbol(left)
																							? FromSymbol(left, right)
																							: exports_type.IsTuple(left)
																								? FromTuple3(left, right)
																								: exports_type.IsPromise(left)
																									? FromPromise2(left, right)
																									: exports_type.IsUint8Array(
																												left,
																											)
																										? FromUint8Array(
																												left,
																												right,
																											)
																										: exports_type.IsUndefined(
																													left,
																												)
																											? FromUndefined(
																													left,
																													right,
																												)
																											: exports_type.IsUnion(
																														left,
																													)
																												? FromUnion6(
																														left,
																														right,
																													)
																												: exports_type.IsUnknown(
																															left,
																														)
																													? FromUnknown(
																															left,
																															right,
																														)
																													: exports_type.IsVoid(
																																left,
																															)
																														? FromVoid(
																																left,
																																right,
																															)
																														: Throw(
																																`Unknown left type operand '${left[Kind]}'`,
																															);
}
function ExtendsCheck(left, right) {
	return Visit3(left, right);
}
function FromProperties8(P, Right, True, False, options) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
	return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
	return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
	let P = FromMappedResult6(Left, Right, True, False, options);
	return MappedResult(P);
}
function ExtendsResolve(left, right, trueType, falseType) {
	let R = ExtendsCheck(left, right);
	return R === ExtendsResult.Union
		? Union([trueType, falseType])
		: R === ExtendsResult.True
			? trueType
			: falseType;
}
function Extends(L, R, T, F, options) {
	return IsMappedResult(L)
		? ExtendsFromMappedResult(L, R, T, F, options)
		: IsMappedKey(L)
			? CreateType(ExtendsFromMappedKey(L, R, T, F, options))
			: CreateType(ExtendsResolve(L, R, T, F), options);
}
function FromPropertyKey(K, U, L, R, options) {
	return { [K]: Extends(Literal(K), U, L, R, Clone(options)) };
}
function FromPropertyKeys(K, U, L, R, options) {
	return K.reduce((Acc, LK) => {
		return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
	}, {});
}
function FromMappedKey2(K, U, L, R, options) {
	return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
	let P = FromMappedKey2(T, U, L, R, options);
	return MappedResult(P);
}
function Intersect2(schema) {
	return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
	return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
	return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
	return schema[Kind] === "Intersect"
		? Intersect2(schema)
		: schema[Kind] === "Union"
			? Union2(schema)
			: schema[Kind] === "Not"
				? Not(schema)
				: schema[Kind] === "Undefined"
					? !0
					: !1;
}
function ExcludeFromTemplateLiteral(L, R) {
	return Exclude(TemplateLiteralToUnion(L), R);
}
function ExcludeRest(L, R) {
	let excluded = L.filter(
		(inner) => ExtendsCheck(inner, R) === ExtendsResult.False,
	);
	return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
	if (IsTemplateLiteral(L))
		return CreateType(ExcludeFromTemplateLiteral(L, R), options);
	if (IsMappedResult(L))
		return CreateType(ExcludeFromMappedResult(L, R), options);
	return CreateType(
		IsUnion(L)
			? ExcludeRest(L.anyOf, R)
			: ExtendsCheck(L, R) !== ExtendsResult.False
				? Never()
				: L,
		options,
	);
}
function FromProperties9(P, U) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Exclude(P[K2], U);
	return Acc;
}
function FromMappedResult7(R, T) {
	return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
	let P = FromMappedResult7(R, T);
	return MappedResult(P);
}
function ExtractFromTemplateLiteral(L, R) {
	return Extract(TemplateLiteralToUnion(L), R);
}
function ExtractRest(L, R) {
	let extracted = L.filter(
		(inner) => ExtendsCheck(inner, R) !== ExtendsResult.False,
	);
	return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
	if (IsTemplateLiteral(L))
		return CreateType(ExtractFromTemplateLiteral(L, R), options);
	if (IsMappedResult(L))
		return CreateType(ExtractFromMappedResult(L, R), options);
	return CreateType(
		IsUnion(L)
			? ExtractRest(L.anyOf, R)
			: ExtendsCheck(L, R) !== ExtendsResult.False
				? L
				: Never(),
		options,
	);
}
function FromProperties10(P, T) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Extract(P[K2], T);
	return Acc;
}
function FromMappedResult8(R, T) {
	return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
	let P = FromMappedResult8(R, T);
	return MappedResult(P);
}
function InstanceType(schema, options) {
	return IsConstructor(schema)
		? CreateType(schema.returns, options)
		: Never(options);
}
function ReadonlyOptional(schema) {
	return Readonly(Optional(schema));
}
function RecordCreateFromPattern(pattern, T, options) {
	return CreateType(
		{ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } },
		options,
	);
}
function RecordCreateFromKeys(K, T, options) {
	let result = {};
	for (let K2 of K) result[K2] = T;
	return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
	return IsTemplateLiteralFinite(K)
		? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)
		: RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
	return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
	return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
	return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
	let pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
	return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
	return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
	return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
	return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
	return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
	return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
	return IsUnion(key)
		? FromUnionKey(key.anyOf, type, options)
		: IsTemplateLiteral(key)
			? FromTemplateLiteralKey(key, type, options)
			: IsLiteral(key)
				? FromLiteralKey(key.const, type, options)
				: IsBoolean3(key)
					? FromBooleanKey(key, type, options)
					: IsInteger2(key)
						? FromIntegerKey(key, type, options)
						: IsNumber3(key)
							? FromNumberKey(key, type, options)
							: IsRegExp2(key)
								? FromRegExpKey(key, type, options)
								: IsString3(key)
									? FromStringKey(key, type, options)
									: IsAny(key)
										? FromAnyKey(key, type, options)
										: IsNever(key)
											? FromNeverKey(key, type, options)
											: Never(options);
}
function RecordPattern(record) {
	return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
	let pattern = RecordPattern(type);
	return pattern === PatternStringExact
		? String2()
		: pattern === PatternNumberExact
			? Number2()
			: String2({ pattern });
}
function RecordValue2(type) {
	return type.patternProperties[RecordPattern(type)];
}
function FromConstructor2(args, type) {
	return (
		(type.parameters = FromTypes(args, type.parameters)),
		(type.returns = FromType(args, type.returns)),
		type
	);
}
function FromFunction2(args, type) {
	return (
		(type.parameters = FromTypes(args, type.parameters)),
		(type.returns = FromType(args, type.returns)),
		type
	);
}
function FromIntersect5(args, type) {
	return (type.allOf = FromTypes(args, type.allOf)), type;
}
function FromUnion7(args, type) {
	return (type.anyOf = FromTypes(args, type.anyOf)), type;
}
function FromTuple4(args, type) {
	if (IsUndefined(type.items)) return type;
	return (type.items = FromTypes(args, type.items)), type;
}
function FromArray5(args, type) {
	return (type.items = FromType(args, type.items)), type;
}
function FromAsyncIterator2(args, type) {
	return (type.items = FromType(args, type.items)), type;
}
function FromIterator2(args, type) {
	return (type.items = FromType(args, type.items)), type;
}
function FromPromise3(args, type) {
	return (type.item = FromType(args, type.item)), type;
}
function FromObject2(args, type) {
	let mappedProperties = FromProperties11(args, type.properties);
	return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
	let mappedKey = FromType(args, RecordKey2(type)),
		mappedValue = FromType(args, RecordValue2(type)),
		result = Record(mappedKey, mappedValue);
	return { ...type, ...result };
}
function FromArgument(args, argument) {
	return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
	let isReadonly = IsReadonly(type),
		isOptional = IsOptional(type),
		mapped = FromType(args, type);
	return isReadonly && isOptional
		? ReadonlyOptional(mapped)
		: isReadonly && !isOptional
			? Readonly(mapped)
			: !isReadonly && isOptional
				? Optional(mapped)
				: mapped;
}
function FromProperties11(args, properties) {
	return globalThis.Object.getOwnPropertyNames(properties).reduce(
		(result, key) => {
			return { ...result, [key]: FromProperty2(args, properties[key]) };
		},
		{},
	);
}
function FromTypes(args, types) {
	return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
	return IsConstructor(type)
		? FromConstructor2(args, type)
		: IsFunction3(type)
			? FromFunction2(args, type)
			: IsIntersect(type)
				? FromIntersect5(args, type)
				: IsUnion(type)
					? FromUnion7(args, type)
					: IsTuple(type)
						? FromTuple4(args, type)
						: IsArray3(type)
							? FromArray5(args, type)
							: IsAsyncIterator3(type)
								? FromAsyncIterator2(args, type)
								: IsIterator3(type)
									? FromIterator2(args, type)
									: IsPromise2(type)
										? FromPromise3(args, type)
										: IsObject3(type)
											? FromObject2(args, type)
											: IsRecord(type)
												? FromRecord2(args, type)
												: IsArgument(type)
													? FromArgument(args, type)
													: type;
}
function Instantiate(type, args) {
	return FromType(args, CloneType(type));
}
function Integer(options) {
	return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}
function MappedIntrinsicPropertyKey(K, M, options) {
	return { [K]: Intrinsic(Literal(K), M, Clone(options)) };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
	return K.reduce((Acc, L) => {
		return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
	}, {});
}
function MappedIntrinsicProperties(T, M, options) {
	return MappedIntrinsicPropertyKeys(T.keys, M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
	let P = MappedIntrinsicProperties(T, M, options);
	return MappedResult(P);
}
function ApplyUncapitalize(value) {
	let [first, rest] = [value.slice(0, 1), value.slice(1)];
	return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
	let [first, rest] = [value.slice(0, 1), value.slice(1)];
	return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
	return value.toUpperCase();
}
function ApplyLowercase(value) {
	return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
	let expression = TemplateLiteralParseExact(schema.pattern);
	if (!IsTemplateLiteralExpressionFinite(expression))
		return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
	let literals = [...TemplateLiteralExpressionGenerate(expression)].map(
			(value) => Literal(value),
		),
		mapped = FromRest5(literals, mode),
		union = Union(mapped);
	return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
	return typeof value === "string"
		? mode === "Uncapitalize"
			? ApplyUncapitalize(value)
			: mode === "Capitalize"
				? ApplyCapitalize(value)
				: mode === "Uppercase"
					? ApplyUppercase(value)
					: mode === "Lowercase"
						? ApplyLowercase(value)
						: value
		: value.toString();
}
function FromRest5(T, M) {
	return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
	return IsMappedKey(schema)
		? IntrinsicFromMappedKey(schema, mode, options)
		: IsTemplateLiteral(schema)
			? FromTemplateLiteral3(schema, mode, options)
			: IsUnion(schema)
				? Union(FromRest5(schema.anyOf, mode), options)
				: IsLiteral(schema)
					? Literal(FromLiteralValue(schema.const, mode), options)
					: CreateType(schema, options);
}
function Capitalize(T, options = {}) {
	return Intrinsic(T, "Capitalize", options);
}
function Lowercase(T, options = {}) {
	return Intrinsic(T, "Lowercase", options);
}
function Uncapitalize(T, options = {}) {
	return Intrinsic(T, "Uncapitalize", options);
}
function Uppercase(T, options = {}) {
	return Intrinsic(T, "Uppercase", options);
}
function FromProperties12(properties, propertyKeys, options) {
	let result = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
	return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
	return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
	let properties = FromMappedResult9(mappedResult, propertyKeys, options);
	return MappedResult(properties);
}
function FromIntersect6(types, propertyKeys) {
	return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
	return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
	let { [key]: _, ...R } = properties;
	return R;
}
function FromProperties13(properties, propertyKeys) {
	return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
	let options = Discard(properties, [
			TransformKind,
			"$id",
			"required",
			"properties",
		]),
		omittedProperties = FromProperties13(properties.properties, propertyKeys);
	return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
	let result = propertyKeys.reduce(
		(result2, key) =>
			IsLiteralValue(key) ? [...result2, Literal(key)] : result2,
		[],
	);
	return Union(result);
}
function OmitResolve(properties, propertyKeys) {
	return IsIntersect(properties)
		? Intersect(FromIntersect6(properties.allOf, propertyKeys))
		: IsUnion(properties)
			? Union(FromUnion8(properties.anyOf, propertyKeys))
			: IsObject3(properties)
				? FromObject3(properties, propertyKeys)
				: Object2({});
}
function Omit(type, key, options) {
	let typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key,
		propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key,
		isTypeRef = IsRef(type),
		isKeyRef = IsRef(key);
	return IsMappedResult(type)
		? OmitFromMappedResult(type, propertyKeys, options)
		: IsMappedKey(key)
			? OmitFromMappedKey(type, key, options)
			: isTypeRef && isKeyRef
				? Computed("Omit", [type, typeKey], options)
				: !isTypeRef && isKeyRef
					? Computed("Omit", [type, typeKey], options)
					: isTypeRef && !isKeyRef
						? Computed("Omit", [type, typeKey], options)
						: CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}
function FromPropertyKey2(type, key, options) {
	return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
	return propertyKeys.reduce((Acc, LK) => {
		return { ...Acc, ...FromPropertyKey2(type, LK, options) };
	}, {});
}
function FromMappedKey3(type, mappedKey, options) {
	return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
	let properties = FromMappedKey3(type, mappedKey, options);
	return MappedResult(properties);
}
function FromProperties14(properties, propertyKeys, options) {
	let result = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
	return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
	return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
	let properties = FromMappedResult10(mappedResult, propertyKeys, options);
	return MappedResult(properties);
}
function FromIntersect7(types, propertyKeys) {
	return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
	return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
	let result = {};
	for (let K2 of propertyKeys)
		if (K2 in properties) result[K2] = properties[K2];
	return result;
}
function FromObject4(T, K) {
	let options = Discard(T, [TransformKind, "$id", "required", "properties"]),
		properties = FromProperties15(T.properties, K);
	return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
	let result = propertyKeys.reduce(
		(result2, key) =>
			IsLiteralValue(key) ? [...result2, Literal(key)] : result2,
		[],
	);
	return Union(result);
}
function PickResolve(properties, propertyKeys) {
	return IsIntersect(properties)
		? Intersect(FromIntersect7(properties.allOf, propertyKeys))
		: IsUnion(properties)
			? Union(FromUnion9(properties.anyOf, propertyKeys))
			: IsObject3(properties)
				? FromObject4(properties, propertyKeys)
				: Object2({});
}
function Pick(type, key, options) {
	let typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key,
		propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key,
		isTypeRef = IsRef(type),
		isKeyRef = IsRef(key);
	return IsMappedResult(type)
		? PickFromMappedResult(type, propertyKeys, options)
		: IsMappedKey(key)
			? PickFromMappedKey(type, key, options)
			: isTypeRef && isKeyRef
				? Computed("Pick", [type, typeKey], options)
				: !isTypeRef && isKeyRef
					? Computed("Pick", [type, typeKey], options)
					: isTypeRef && !isKeyRef
						? Computed("Pick", [type, typeKey], options)
						: CreateType({ ...PickResolve(type, propertyKeys), ...options });
}
function FromPropertyKey3(type, key, options) {
	return { [key]: Pick(type, [key], Clone(options)) };
}
function FromPropertyKeys3(type, propertyKeys, options) {
	return propertyKeys.reduce((result, leftKey) => {
		return { ...result, ...FromPropertyKey3(type, leftKey, options) };
	}, {});
}
function FromMappedKey4(type, mappedKey, options) {
	return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
	let properties = FromMappedKey4(type, mappedKey, options);
	return MappedResult(properties);
}
function FromComputed3(target, parameters) {
	return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
	return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
	let partialProperties = {};
	for (let K of globalThis.Object.getOwnPropertyNames(properties))
		partialProperties[K] = Optional(properties[K]);
	return partialProperties;
}
function FromObject5(type) {
	let options = Discard(type, [TransformKind, "$id", "required", "properties"]),
		properties = FromProperties16(type.properties);
	return Object2(properties, options);
}
function FromRest6(types) {
	return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
	return IsComputed(type)
		? FromComputed3(type.target, type.parameters)
		: IsRef(type)
			? FromRef3(type.$ref)
			: IsIntersect(type)
				? Intersect(FromRest6(type.allOf))
				: IsUnion(type)
					? Union(FromRest6(type.anyOf))
					: IsObject3(type)
						? FromObject5(type)
						: IsBigInt3(type)
							? type
							: IsBoolean3(type)
								? type
								: IsInteger2(type)
									? type
									: IsLiteral(type)
										? type
										: IsNull3(type)
											? type
											: IsNumber3(type)
												? type
												: IsString3(type)
													? type
													: IsSymbol3(type)
														? type
														: IsUndefined3(type)
															? type
															: Object2({});
}
function Partial(type, options) {
	if (IsMappedResult(type)) return PartialFromMappedResult(type, options);
	else return CreateType({ ...PartialResolve(type), ...options });
}
function FromProperties17(K, options) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(K))
		Acc[K2] = Partial(K[K2], Clone(options));
	return Acc;
}
function FromMappedResult11(R, options) {
	return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
	let P = FromMappedResult11(R, options);
	return MappedResult(P);
}
function FromComputed4(target, parameters) {
	return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
	return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
	let requiredProperties = {};
	for (let K of globalThis.Object.getOwnPropertyNames(properties))
		requiredProperties[K] = Discard(properties[K], [OptionalKind]);
	return requiredProperties;
}
function FromObject6(type) {
	let options = Discard(type, [TransformKind, "$id", "required", "properties"]),
		properties = FromProperties18(type.properties);
	return Object2(properties, options);
}
function FromRest7(types) {
	return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
	return IsComputed(type)
		? FromComputed4(type.target, type.parameters)
		: IsRef(type)
			? FromRef4(type.$ref)
			: IsIntersect(type)
				? Intersect(FromRest7(type.allOf))
				: IsUnion(type)
					? Union(FromRest7(type.anyOf))
					: IsObject3(type)
						? FromObject6(type)
						: IsBigInt3(type)
							? type
							: IsBoolean3(type)
								? type
								: IsInteger2(type)
									? type
									: IsLiteral(type)
										? type
										: IsNull3(type)
											? type
											: IsNumber3(type)
												? type
												: IsString3(type)
													? type
													: IsSymbol3(type)
														? type
														: IsUndefined3(type)
															? type
															: Object2({});
}
function Required(type, options) {
	if (IsMappedResult(type)) return RequiredFromMappedResult(type, options);
	else return CreateType({ ...RequiredResolve(type), ...options });
}
function FromProperties19(P, options) {
	let Acc = {};
	for (let K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Required(P[K2], options);
	return Acc;
}
function FromMappedResult12(R, options) {
	return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
	let P = FromMappedResult12(R, options);
	return MappedResult(P);
}
function DereferenceParameters(moduleProperties, types) {
	return types.map((type) => {
		return IsRef(type)
			? Dereference(moduleProperties, type.$ref)
			: FromType2(moduleProperties, type);
	});
}
function Dereference(moduleProperties, ref) {
	return ref in moduleProperties
		? IsRef(moduleProperties[ref])
			? Dereference(moduleProperties, moduleProperties[ref].$ref)
			: FromType2(moduleProperties, moduleProperties[ref])
		: Never();
}
function FromAwaited(parameters) {
	return Awaited(parameters[0]);
}
function FromIndex(parameters) {
	return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
	return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
	return Partial(parameters[0]);
}
function FromOmit(parameters) {
	return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
	return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
	return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
	let dereferenced = DereferenceParameters(moduleProperties, parameters);
	return target === "Awaited"
		? FromAwaited(dereferenced)
		: target === "Index"
			? FromIndex(dereferenced)
			: target === "KeyOf"
				? FromKeyOf(dereferenced)
				: target === "Partial"
					? FromPartial(dereferenced)
					: target === "Omit"
						? FromOmit(dereferenced)
						: target === "Pick"
							? FromPick(dereferenced)
							: target === "Required"
								? FromRequired(dereferenced)
								: Never();
}
function FromArray6(moduleProperties, type) {
	return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
	return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
	return Constructor(
		FromTypes2(moduleProperties, parameters),
		FromType2(moduleProperties, instanceType),
	);
}
function FromFunction3(moduleProperties, parameters, returnType) {
	return Function2(
		FromTypes2(moduleProperties, parameters),
		FromType2(moduleProperties, returnType),
	);
}
function FromIntersect8(moduleProperties, types) {
	return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
	return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
	return Object2(
		globalThis.Object.keys(properties).reduce((result, key) => {
			return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
		}, {}),
	);
}
function FromRecord3(moduleProperties, type) {
	let [value, pattern] = [
			FromType2(moduleProperties, RecordValue2(type)),
			RecordPattern(type),
		],
		result = CloneType(type);
	return (result.patternProperties[pattern] = value), result;
}
function FromTransform(moduleProperties, transform) {
	return IsRef(transform)
		? {
				...Dereference(moduleProperties, transform.$ref),
				[TransformKind]: transform[TransformKind],
			}
		: transform;
}
function FromTuple5(moduleProperties, types) {
	return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
	return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
	return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
	return IsOptional(type)
		? CreateType(
				FromType2(moduleProperties, Discard(type, [OptionalKind])),
				type,
			)
		: IsReadonly(type)
			? CreateType(
					FromType2(moduleProperties, Discard(type, [ReadonlyKind])),
					type,
				)
			: IsTransform(type)
				? CreateType(FromTransform(moduleProperties, type), type)
				: IsArray3(type)
					? CreateType(FromArray6(moduleProperties, type.items), type)
					: IsAsyncIterator3(type)
						? CreateType(FromAsyncIterator3(moduleProperties, type.items), type)
						: IsComputed(type)
							? CreateType(
									FromComputed5(moduleProperties, type.target, type.parameters),
								)
							: IsConstructor(type)
								? CreateType(
										FromConstructor3(
											moduleProperties,
											type.parameters,
											type.returns,
										),
										type,
									)
								: IsFunction3(type)
									? CreateType(
											FromFunction3(
												moduleProperties,
												type.parameters,
												type.returns,
											),
											type,
										)
									: IsIntersect(type)
										? CreateType(
												FromIntersect8(moduleProperties, type.allOf),
												type,
											)
										: IsIterator3(type)
											? CreateType(
													FromIterator3(moduleProperties, type.items),
													type,
												)
											: IsObject3(type)
												? CreateType(
														FromObject7(moduleProperties, type.properties),
														type,
													)
												: IsRecord(type)
													? CreateType(FromRecord3(moduleProperties, type))
													: IsTuple(type)
														? CreateType(
																FromTuple5(moduleProperties, type.items || []),
																type,
															)
														: IsUnion(type)
															? CreateType(
																	FromUnion10(moduleProperties, type.anyOf),
																	type,
																)
															: type;
}
function ComputeType(moduleProperties, key) {
	return key in moduleProperties
		? FromType2(moduleProperties, moduleProperties[key])
		: Never();
}
function ComputeModuleProperties(moduleProperties) {
	return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce(
		(result, key) => {
			return { ...result, [key]: ComputeType(moduleProperties, key) };
		},
		{},
	);
}
class TModule {
	constructor($defs) {
		let computed = ComputeModuleProperties($defs),
			identified = this.WithIdentifiers(computed);
		this.$defs = identified;
	}
	Import(key, options) {
		let $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
		return CreateType({ [Kind]: "Import", $defs, $ref: key });
	}
	WithIdentifiers($defs) {
		return globalThis.Object.getOwnPropertyNames($defs).reduce(
			(result, key) => {
				return { ...result, [key]: { ...$defs[key], $id: key } };
			},
			{},
		);
	}
}
function Module(properties) {
	return new TModule(properties);
}
function Not2(type, options) {
	return CreateType({ [Kind]: "Not", not: type }, options);
}
function Parameters(schema, options) {
	return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}
var Ordinal = 0;
function Recursive(callback, options = {}) {
	if (IsUndefined(options.$id)) options.$id = `T${Ordinal++}`;
	let thisType = CloneType(
		callback({ [Kind]: "This", $ref: `${options.$id}` }),
	);
	return (
		(thisType.$id = options.$id),
		CreateType({ [Hint]: "Recursive", ...thisType }, options)
	);
}
function RegExp2(unresolved, options) {
	let expr = IsString(unresolved)
		? new globalThis.RegExp(unresolved)
		: unresolved;
	return CreateType(
		{
			[Kind]: "RegExp",
			type: "RegExp",
			source: expr.source,
			flags: expr.flags,
		},
		options,
	);
}
function RestResolve(T) {
	return IsIntersect(T)
		? T.allOf
		: IsUnion(T)
			? T.anyOf
			: IsTuple(T)
				? (T.items ?? [])
				: [];
}
function Rest(T) {
	return RestResolve(T);
}
function ReturnType(schema, options) {
	return IsFunction3(schema)
		? CreateType(schema.returns, options)
		: Never(options);
}
class TransformDecodeBuilder {
	constructor(schema) {
		this.schema = schema;
	}
	Decode(decode) {
		return new TransformEncodeBuilder(this.schema, decode);
	}
}
class TransformEncodeBuilder {
	constructor(schema, decode) {
		(this.schema = schema), (this.decode = decode);
	}
	EncodeTransform(encode, schema) {
		let Codec = {
			Encode: (value) => schema[TransformKind].Encode(encode(value)),
			Decode: (value) => this.decode(schema[TransformKind].Decode(value)),
		};
		return { ...schema, [TransformKind]: Codec };
	}
	EncodeSchema(encode, schema) {
		let Codec = { Decode: this.decode, Encode: encode };
		return { ...schema, [TransformKind]: Codec };
	}
	Encode(encode) {
		return IsTransform(this.schema)
			? this.EncodeTransform(encode, this.schema)
			: this.EncodeSchema(encode, this.schema);
	}
}
function Transform(schema) {
	return new TransformDecodeBuilder(schema);
}
function Unsafe(options = {}) {
	return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}
function Void(options) {
	return CreateType({ [Kind]: "Void", type: "void" }, options);
}
var exports_type3 = {};
__export(exports_type3, {
	Void: () => Void,
	Uppercase: () => Uppercase,
	Unsafe: () => Unsafe,
	Unknown: () => Unknown,
	Union: () => Union,
	Undefined: () => Undefined,
	Uncapitalize: () => Uncapitalize,
	Uint8Array: () => Uint8Array2,
	Tuple: () => Tuple,
	Transform: () => Transform,
	TemplateLiteral: () => TemplateLiteral,
	Symbol: () => Symbol2,
	String: () => String2,
	ReturnType: () => ReturnType,
	Rest: () => Rest,
	Required: () => Required,
	RegExp: () => RegExp2,
	Ref: () => Ref,
	Recursive: () => Recursive,
	Record: () => Record,
	ReadonlyOptional: () => ReadonlyOptional,
	Readonly: () => Readonly,
	Promise: () => Promise2,
	Pick: () => Pick,
	Partial: () => Partial,
	Parameters: () => Parameters,
	Optional: () => Optional,
	Omit: () => Omit,
	Object: () => Object2,
	Number: () => Number2,
	Null: () => Null,
	Not: () => Not2,
	Never: () => Never,
	Module: () => Module,
	Mapped: () => Mapped,
	Lowercase: () => Lowercase,
	Literal: () => Literal,
	KeyOf: () => KeyOf,
	Iterator: () => Iterator,
	Intersect: () => Intersect,
	Integer: () => Integer,
	Instantiate: () => Instantiate,
	InstanceType: () => InstanceType,
	Index: () => Index,
	Function: () => Function2,
	Extract: () => Extract,
	Extends: () => Extends,
	Exclude: () => Exclude,
	Enum: () => Enum,
	Date: () => Date2,
	ConstructorParameters: () => ConstructorParameters,
	Constructor: () => Constructor,
	Const: () => Const,
	Composite: () => Composite,
	Capitalize: () => Capitalize,
	Boolean: () => Boolean2,
	BigInt: () => BigInt2,
	Awaited: () => Awaited,
	AsyncIterator: () => AsyncIterator,
	Array: () => Array2,
	Argument: () => Argument,
	Any: () => Any,
});
var Type = exports_type3;
function DefaultErrorFunction(error) {
	switch (error.errorType) {
		case ValueErrorType.ArrayContains:
			return "Expected array to contain at least one matching value";
		case ValueErrorType.ArrayMaxContains:
			return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
		case ValueErrorType.ArrayMinContains:
			return `Expected array to contain at least ${error.schema.minContains} matching values`;
		case ValueErrorType.ArrayMaxItems:
			return `Expected array length to be less or equal to ${error.schema.maxItems}`;
		case ValueErrorType.ArrayMinItems:
			return `Expected array length to be greater or equal to ${error.schema.minItems}`;
		case ValueErrorType.ArrayUniqueItems:
			return "Expected array elements to be unique";
		case ValueErrorType.Array:
			return "Expected array";
		case ValueErrorType.AsyncIterator:
			return "Expected AsyncIterator";
		case ValueErrorType.BigIntExclusiveMaximum:
			return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.BigIntExclusiveMinimum:
			return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.BigIntMaximum:
			return `Expected bigint to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.BigIntMinimum:
			return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.BigIntMultipleOf:
			return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.BigInt:
			return "Expected bigint";
		case ValueErrorType.Boolean:
			return "Expected boolean";
		case ValueErrorType.DateExclusiveMinimumTimestamp:
			return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
		case ValueErrorType.DateExclusiveMaximumTimestamp:
			return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
		case ValueErrorType.DateMinimumTimestamp:
			return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
		case ValueErrorType.DateMaximumTimestamp:
			return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
		case ValueErrorType.DateMultipleOfTimestamp:
			return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
		case ValueErrorType.Date:
			return "Expected Date";
		case ValueErrorType.Function:
			return "Expected function";
		case ValueErrorType.IntegerExclusiveMaximum:
			return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.IntegerExclusiveMinimum:
			return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.IntegerMaximum:
			return `Expected integer to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.IntegerMinimum:
			return `Expected integer to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.IntegerMultipleOf:
			return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.Integer:
			return "Expected integer";
		case ValueErrorType.IntersectUnevaluatedProperties:
			return "Unexpected property";
		case ValueErrorType.Intersect:
			return "Expected all values to match";
		case ValueErrorType.Iterator:
			return "Expected Iterator";
		case ValueErrorType.Literal:
			return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
		case ValueErrorType.Never:
			return "Never";
		case ValueErrorType.Not:
			return "Value should not match";
		case ValueErrorType.Null:
			return "Expected null";
		case ValueErrorType.NumberExclusiveMaximum:
			return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.NumberExclusiveMinimum:
			return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.NumberMaximum:
			return `Expected number to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.NumberMinimum:
			return `Expected number to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.NumberMultipleOf:
			return `Expected number to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.Number:
			return "Expected number";
		case ValueErrorType.Object:
			return "Expected object";
		case ValueErrorType.ObjectAdditionalProperties:
			return "Unexpected property";
		case ValueErrorType.ObjectMaxProperties:
			return `Expected object to have no more than ${error.schema.maxProperties} properties`;
		case ValueErrorType.ObjectMinProperties:
			return `Expected object to have at least ${error.schema.minProperties} properties`;
		case ValueErrorType.ObjectRequiredProperty:
			return "Expected required property";
		case ValueErrorType.Promise:
			return "Expected Promise";
		case ValueErrorType.RegExp:
			return "Expected string to match regular expression";
		case ValueErrorType.StringFormatUnknown:
			return `Unknown format '${error.schema.format}'`;
		case ValueErrorType.StringFormat:
			return `Expected string to match '${error.schema.format}' format`;
		case ValueErrorType.StringMaxLength:
			return `Expected string length less or equal to ${error.schema.maxLength}`;
		case ValueErrorType.StringMinLength:
			return `Expected string length greater or equal to ${error.schema.minLength}`;
		case ValueErrorType.StringPattern:
			return `Expected string to match '${error.schema.pattern}'`;
		case ValueErrorType.String:
			return "Expected string";
		case ValueErrorType.Symbol:
			return "Expected symbol";
		case ValueErrorType.TupleLength:
			return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
		case ValueErrorType.Tuple:
			return "Expected tuple";
		case ValueErrorType.Uint8ArrayMaxByteLength:
			return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
		case ValueErrorType.Uint8ArrayMinByteLength:
			return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
		case ValueErrorType.Uint8Array:
			return "Expected Uint8Array";
		case ValueErrorType.Undefined:
			return "Expected undefined";
		case ValueErrorType.Union:
			return "Expected union value";
		case ValueErrorType.Void:
			return "Expected void";
		case ValueErrorType.Kind:
			return `Expected kind '${error.schema[Kind]}'`;
		default:
			return "Unknown error type";
	}
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
	return errorFunction;
}
class TypeDereferenceError extends TypeBoxError {
	constructor(schema) {
		super(`Unable to dereference schema with $id '${schema.$ref}'`);
		this.schema = schema;
	}
}
function Resolve(schema, references) {
	let target = references.find((target2) => target2.$id === schema.$ref);
	if (target === void 0) throw new TypeDereferenceError(schema);
	return Deref(target, references);
}
function Pushref(schema, references) {
	if (
		!IsString2(schema.$id) ||
		references.some((target) => target.$id === schema.$id)
	)
		return references;
	return references.push(schema), references;
}
function Deref(schema, references) {
	return schema[Kind] === "This" || schema[Kind] === "Ref"
		? Resolve(schema, references)
		: schema;
}
class ValueHashError extends TypeBoxError {
	constructor(value) {
		super("Unable to hash value");
		this.value = value;
	}
}
var ByteMarker;
(function (ByteMarker2) {
	(ByteMarker2[(ByteMarker2.Undefined = 0)] = "Undefined"),
		(ByteMarker2[(ByteMarker2.Null = 1)] = "Null"),
		(ByteMarker2[(ByteMarker2.Boolean = 2)] = "Boolean"),
		(ByteMarker2[(ByteMarker2.Number = 3)] = "Number"),
		(ByteMarker2[(ByteMarker2.String = 4)] = "String"),
		(ByteMarker2[(ByteMarker2.Object = 5)] = "Object"),
		(ByteMarker2[(ByteMarker2.Array = 6)] = "Array"),
		(ByteMarker2[(ByteMarker2.Date = 7)] = "Date"),
		(ByteMarker2[(ByteMarker2.Uint8Array = 8)] = "Uint8Array"),
		(ByteMarker2[(ByteMarker2.Symbol = 9)] = "Symbol"),
		(ByteMarker2[(ByteMarker2.BigInt = 10)] = "BigInt");
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037"),
	[Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")],
	Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i)),
	F64 = new Float64Array(1),
	F64In = new DataView(F64.buffer),
	F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
	let byteCount =
		value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
	for (let i = 0; i < byteCount; i++)
		yield (value >> (8 * (byteCount - 1 - i))) & 255;
}
function ArrayType2(value) {
	FNV1A64(ByteMarker.Array);
	for (let item of value) Visit4(item);
}
function BooleanType(value) {
	FNV1A64(ByteMarker.Boolean), FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
	FNV1A64(ByteMarker.BigInt), F64In.setBigInt64(0, value);
	for (let byte of F64Out) FNV1A64(byte);
}
function DateType2(value) {
	FNV1A64(ByteMarker.Date), Visit4(value.getTime());
}
function NullType(value) {
	FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
	FNV1A64(ByteMarker.Number), F64In.setFloat64(0, value);
	for (let byte of F64Out) FNV1A64(byte);
}
function ObjectType2(value) {
	FNV1A64(ByteMarker.Object);
	for (let key of globalThis.Object.getOwnPropertyNames(value).sort())
		Visit4(key), Visit4(value[key]);
}
function StringType(value) {
	FNV1A64(ByteMarker.String);
	for (let i = 0; i < value.length; i++)
		for (let byte of NumberToBytes(value.charCodeAt(i))) FNV1A64(byte);
}
function SymbolType(value) {
	FNV1A64(ByteMarker.Symbol), Visit4(value.description);
}
function Uint8ArrayType2(value) {
	FNV1A64(ByteMarker.Uint8Array);
	for (let i = 0; i < value.length; i++) FNV1A64(value[i]);
}
function UndefinedType(value) {
	return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
	if (IsArray2(value)) return ArrayType2(value);
	if (IsBoolean2(value)) return BooleanType(value);
	if (IsBigInt2(value)) return BigIntType(value);
	if (IsDate2(value)) return DateType2(value);
	if (IsNull2(value)) return NullType(value);
	if (IsNumber2(value)) return NumberType(value);
	if (IsObject2(value)) return ObjectType2(value);
	if (IsString2(value)) return StringType(value);
	if (IsSymbol2(value)) return SymbolType(value);
	if (IsUint8Array2(value)) return Uint8ArrayType2(value);
	if (IsUndefined2(value)) return UndefinedType(value);
	throw new ValueHashError(value);
}
function FNV1A64(byte) {
	(Accumulator = Accumulator ^ Bytes[byte]),
		(Accumulator = (Accumulator * Prime) % Size);
}
function Hash(value) {
	return (
		(Accumulator = BigInt("14695981039346656037")), Visit4(value), Accumulator
	);
}
class ValueCheckUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}
function IsAnyOrUnknown(schema) {
	return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
	return value !== void 0;
}
function FromAny2(schema, references, value) {
	return !0;
}
function FromArgument2(schema, references, value) {
	return !0;
}
function FromArray7(schema, references, value) {
	if (!IsArray2(value)) return !1;
	if (IsDefined(schema.minItems) && !(value.length >= schema.minItems))
		return !1;
	if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems))
		return !1;
	if (!value.every((value2) => Visit5(schema.items, references, value2)))
		return !1;
	if (
		schema.uniqueItems === !0 &&
		!(function () {
			let set2 = new Set();
			for (let element of value) {
				let hashed = Hash(element);
				if (set2.has(hashed)) return !1;
				else set2.add(hashed);
			}
			return !0;
		})()
	)
		return !1;
	if (
		!(
			IsDefined(schema.contains) ||
			IsNumber2(schema.minContains) ||
			IsNumber2(schema.maxContains)
		)
	)
		return !0;
	let containsSchema = IsDefined(schema.contains) ? schema.contains : Never(),
		containsCount = value.reduce(
			(acc, value2) =>
				Visit5(containsSchema, references, value2) ? acc + 1 : acc,
			0,
		);
	if (containsCount === 0) return !1;
	if (IsNumber2(schema.minContains) && containsCount < schema.minContains)
		return !1;
	if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains)
		return !1;
	return !0;
}
function FromAsyncIterator4(schema, references, value) {
	return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
	if (!IsBigInt2(value)) return !1;
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		return !1;
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		return !1;
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) return !1;
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) return !1;
	if (IsDefined(schema.multipleOf) && value % schema.multipleOf !== BigInt(0))
		return !1;
	return !0;
}
function FromBoolean2(schema, references, value) {
	return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
	return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
	if (!IsDate2(value)) return !1;
	if (
		IsDefined(schema.exclusiveMaximumTimestamp) &&
		!(value.getTime() < schema.exclusiveMaximumTimestamp)
	)
		return !1;
	if (
		IsDefined(schema.exclusiveMinimumTimestamp) &&
		!(value.getTime() > schema.exclusiveMinimumTimestamp)
	)
		return !1;
	if (
		IsDefined(schema.maximumTimestamp) &&
		!(value.getTime() <= schema.maximumTimestamp)
	)
		return !1;
	if (
		IsDefined(schema.minimumTimestamp) &&
		!(value.getTime() >= schema.minimumTimestamp)
	)
		return !1;
	if (
		IsDefined(schema.multipleOfTimestamp) &&
		value.getTime() % schema.multipleOfTimestamp !== 0
	)
		return !1;
	return !0;
}
function FromFunction4(schema, references, value) {
	return IsFunction2(value);
}
function FromImport(schema, references, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
	if (!IsInteger(value)) return !1;
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		return !1;
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		return !1;
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) return !1;
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) return !1;
	if (IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0)
		return !1;
	return !0;
}
function FromIntersect9(schema, references, value) {
	let check1 = schema.allOf.every((schema2) =>
		Visit5(schema2, references, value),
	);
	if (schema.unevaluatedProperties === !1) {
		let keyPattern = new RegExp(KeyOfPattern(schema)),
			check2 = Object.getOwnPropertyNames(value).every((key) =>
				keyPattern.test(key),
			);
		return check1 && check2;
	} else if (IsSchema(schema.unevaluatedProperties)) {
		let keyCheck = new RegExp(KeyOfPattern(schema)),
			check2 = Object.getOwnPropertyNames(value).every(
				(key) =>
					keyCheck.test(key) ||
					Visit5(schema.unevaluatedProperties, references, value[key]),
			);
		return check1 && check2;
	} else return check1;
}
function FromIterator4(schema, references, value) {
	return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
	return value === schema.const;
}
function FromNever2(schema, references, value) {
	return !1;
}
function FromNot2(schema, references, value) {
	return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
	return IsNull2(value);
}
function FromNumber2(schema, references, value) {
	if (!TypeSystemPolicy.IsNumberLike(value)) return !1;
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		return !1;
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		return !1;
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) return !1;
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) return !1;
	if (IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0)
		return !1;
	return !0;
}
function FromObject8(schema, references, value) {
	if (!TypeSystemPolicy.IsObjectLike(value)) return !1;
	if (
		IsDefined(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	)
		return !1;
	if (
		IsDefined(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	)
		return !1;
	let knownKeys = Object.getOwnPropertyNames(schema.properties);
	for (let knownKey of knownKeys) {
		let property = schema.properties[knownKey];
		if (schema.required && schema.required.includes(knownKey)) {
			if (!Visit5(property, references, value[knownKey])) return !1;
			if (
				(ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) &&
				!(knownKey in value)
			)
				return !1;
		} else if (
			TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) &&
			!Visit5(property, references, value[knownKey])
		)
			return !1;
	}
	if (schema.additionalProperties === !1) {
		let valueKeys = Object.getOwnPropertyNames(value);
		if (
			schema.required &&
			schema.required.length === knownKeys.length &&
			valueKeys.length === knownKeys.length
		)
			return !0;
		else return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
	} else if (typeof schema.additionalProperties === "object")
		return Object.getOwnPropertyNames(value).every(
			(key) =>
				knownKeys.includes(key) ||
				Visit5(schema.additionalProperties, references, value[key]),
		);
	else return !0;
}
function FromPromise4(schema, references, value) {
	return IsPromise(value);
}
function FromRecord4(schema, references, value) {
	if (!TypeSystemPolicy.IsRecordLike(value)) return !1;
	if (
		IsDefined(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	)
		return !1;
	if (
		IsDefined(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	)
		return !1;
	let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
		regex = new RegExp(patternKey),
		check1 = Object.entries(value).every(([key, value2]) => {
			return regex.test(key) ? Visit5(patternSchema, references, value2) : !0;
		}),
		check2 =
			typeof schema.additionalProperties === "object"
				? Object.entries(value).every(([key, value2]) => {
						return !regex.test(key)
							? Visit5(schema.additionalProperties, references, value2)
							: !0;
					})
				: !0,
		check3 =
			schema.additionalProperties === !1
				? Object.getOwnPropertyNames(value).every((key) => {
						return regex.test(key);
					})
				: !0;
	return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
	return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
	let regex = new RegExp(schema.source, schema.flags);
	if (IsDefined(schema.minLength)) {
		if (!(value.length >= schema.minLength)) return !1;
	}
	if (IsDefined(schema.maxLength)) {
		if (!(value.length <= schema.maxLength)) return !1;
	}
	return regex.test(value);
}
function FromString2(schema, references, value) {
	if (!IsString2(value)) return !1;
	if (IsDefined(schema.minLength)) {
		if (!(value.length >= schema.minLength)) return !1;
	}
	if (IsDefined(schema.maxLength)) {
		if (!(value.length <= schema.maxLength)) return !1;
	}
	if (IsDefined(schema.pattern)) {
		if (!new RegExp(schema.pattern).test(value)) return !1;
	}
	if (IsDefined(schema.format)) {
		if (!exports_format.Has(schema.format)) return !1;
		return exports_format.Get(schema.format)(value);
	}
	return !0;
}
function FromSymbol2(schema, references, value) {
	return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
	return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
	return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
	if (!IsArray2(value)) return !1;
	if (schema.items === void 0 && value.length !== 0) return !1;
	if (value.length !== schema.maxItems) return !1;
	if (!schema.items) return !0;
	for (let i = 0; i < schema.items.length; i++)
		if (!Visit5(schema.items[i], references, value[i])) return !1;
	return !0;
}
function FromUndefined2(schema, references, value) {
	return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
	return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
	if (!IsUint8Array2(value)) return !1;
	if (
		IsDefined(schema.maxByteLength) &&
		!(value.length <= schema.maxByteLength)
	)
		return !1;
	if (
		IsDefined(schema.minByteLength) &&
		!(value.length >= schema.minByteLength)
	)
		return !1;
	return !0;
}
function FromUnknown2(schema, references, value) {
	return !0;
}
function FromVoid2(schema, references, value) {
	return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
	if (!exports_type2.Has(schema[Kind])) return !1;
	return exports_type2.Get(schema[Kind])(schema, value);
}
function Visit5(schema, references, value) {
	let references_ = IsDefined(schema.$id)
			? Pushref(schema, references)
			: references,
		schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return FromAny2(schema_, references_, value);
		case "Argument":
			return FromArgument2(schema_, references_, value);
		case "Array":
			return FromArray7(schema_, references_, value);
		case "AsyncIterator":
			return FromAsyncIterator4(schema_, references_, value);
		case "BigInt":
			return FromBigInt2(schema_, references_, value);
		case "Boolean":
			return FromBoolean2(schema_, references_, value);
		case "Constructor":
			return FromConstructor4(schema_, references_, value);
		case "Date":
			return FromDate2(schema_, references_, value);
		case "Function":
			return FromFunction4(schema_, references_, value);
		case "Import":
			return FromImport(schema_, references_, value);
		case "Integer":
			return FromInteger2(schema_, references_, value);
		case "Intersect":
			return FromIntersect9(schema_, references_, value);
		case "Iterator":
			return FromIterator4(schema_, references_, value);
		case "Literal":
			return FromLiteral3(schema_, references_, value);
		case "Never":
			return FromNever2(schema_, references_, value);
		case "Not":
			return FromNot2(schema_, references_, value);
		case "Null":
			return FromNull2(schema_, references_, value);
		case "Number":
			return FromNumber2(schema_, references_, value);
		case "Object":
			return FromObject8(schema_, references_, value);
		case "Promise":
			return FromPromise4(schema_, references_, value);
		case "Record":
			return FromRecord4(schema_, references_, value);
		case "Ref":
			return FromRef5(schema_, references_, value);
		case "RegExp":
			return FromRegExp2(schema_, references_, value);
		case "String":
			return FromString2(schema_, references_, value);
		case "Symbol":
			return FromSymbol2(schema_, references_, value);
		case "TemplateLiteral":
			return FromTemplateLiteral4(schema_, references_, value);
		case "This":
			return FromThis(schema_, references_, value);
		case "Tuple":
			return FromTuple6(schema_, references_, value);
		case "Undefined":
			return FromUndefined2(schema_, references_, value);
		case "Union":
			return FromUnion11(schema_, references_, value);
		case "Uint8Array":
			return FromUint8Array2(schema_, references_, value);
		case "Unknown":
			return FromUnknown2(schema_, references_, value);
		case "Void":
			return FromVoid2(schema_, references_, value);
		default:
			if (!exports_type2.Has(schema_[Kind]))
				throw new ValueCheckUnknownTypeError(schema_);
			return FromKind(schema_, references_, value);
	}
}
function Check(...args) {
	return args.length === 3
		? Visit5(args[0], args[1], args[2])
		: Visit5(args[0], [], args[1]);
}
var ValueErrorType;
(function (ValueErrorType2) {
	(ValueErrorType2[(ValueErrorType2.ArrayContains = 0)] = "ArrayContains"),
		(ValueErrorType2[(ValueErrorType2.ArrayMaxContains = 1)] =
			"ArrayMaxContains"),
		(ValueErrorType2[(ValueErrorType2.ArrayMaxItems = 2)] = "ArrayMaxItems"),
		(ValueErrorType2[(ValueErrorType2.ArrayMinContains = 3)] =
			"ArrayMinContains"),
		(ValueErrorType2[(ValueErrorType2.ArrayMinItems = 4)] = "ArrayMinItems"),
		(ValueErrorType2[(ValueErrorType2.ArrayUniqueItems = 5)] =
			"ArrayUniqueItems"),
		(ValueErrorType2[(ValueErrorType2.Array = 6)] = "Array"),
		(ValueErrorType2[(ValueErrorType2.AsyncIterator = 7)] = "AsyncIterator"),
		(ValueErrorType2[(ValueErrorType2.BigIntExclusiveMaximum = 8)] =
			"BigIntExclusiveMaximum"),
		(ValueErrorType2[(ValueErrorType2.BigIntExclusiveMinimum = 9)] =
			"BigIntExclusiveMinimum"),
		(ValueErrorType2[(ValueErrorType2.BigIntMaximum = 10)] = "BigIntMaximum"),
		(ValueErrorType2[(ValueErrorType2.BigIntMinimum = 11)] = "BigIntMinimum"),
		(ValueErrorType2[(ValueErrorType2.BigIntMultipleOf = 12)] =
			"BigIntMultipleOf"),
		(ValueErrorType2[(ValueErrorType2.BigInt = 13)] = "BigInt"),
		(ValueErrorType2[(ValueErrorType2.Boolean = 14)] = "Boolean"),
		(ValueErrorType2[(ValueErrorType2.DateExclusiveMaximumTimestamp = 15)] =
			"DateExclusiveMaximumTimestamp"),
		(ValueErrorType2[(ValueErrorType2.DateExclusiveMinimumTimestamp = 16)] =
			"DateExclusiveMinimumTimestamp"),
		(ValueErrorType2[(ValueErrorType2.DateMaximumTimestamp = 17)] =
			"DateMaximumTimestamp"),
		(ValueErrorType2[(ValueErrorType2.DateMinimumTimestamp = 18)] =
			"DateMinimumTimestamp"),
		(ValueErrorType2[(ValueErrorType2.DateMultipleOfTimestamp = 19)] =
			"DateMultipleOfTimestamp"),
		(ValueErrorType2[(ValueErrorType2.Date = 20)] = "Date"),
		(ValueErrorType2[(ValueErrorType2.Function = 21)] = "Function"),
		(ValueErrorType2[(ValueErrorType2.IntegerExclusiveMaximum = 22)] =
			"IntegerExclusiveMaximum"),
		(ValueErrorType2[(ValueErrorType2.IntegerExclusiveMinimum = 23)] =
			"IntegerExclusiveMinimum"),
		(ValueErrorType2[(ValueErrorType2.IntegerMaximum = 24)] = "IntegerMaximum"),
		(ValueErrorType2[(ValueErrorType2.IntegerMinimum = 25)] = "IntegerMinimum"),
		(ValueErrorType2[(ValueErrorType2.IntegerMultipleOf = 26)] =
			"IntegerMultipleOf"),
		(ValueErrorType2[(ValueErrorType2.Integer = 27)] = "Integer"),
		(ValueErrorType2[(ValueErrorType2.IntersectUnevaluatedProperties = 28)] =
			"IntersectUnevaluatedProperties"),
		(ValueErrorType2[(ValueErrorType2.Intersect = 29)] = "Intersect"),
		(ValueErrorType2[(ValueErrorType2.Iterator = 30)] = "Iterator"),
		(ValueErrorType2[(ValueErrorType2.Kind = 31)] = "Kind"),
		(ValueErrorType2[(ValueErrorType2.Literal = 32)] = "Literal"),
		(ValueErrorType2[(ValueErrorType2.Never = 33)] = "Never"),
		(ValueErrorType2[(ValueErrorType2.Not = 34)] = "Not"),
		(ValueErrorType2[(ValueErrorType2.Null = 35)] = "Null"),
		(ValueErrorType2[(ValueErrorType2.NumberExclusiveMaximum = 36)] =
			"NumberExclusiveMaximum"),
		(ValueErrorType2[(ValueErrorType2.NumberExclusiveMinimum = 37)] =
			"NumberExclusiveMinimum"),
		(ValueErrorType2[(ValueErrorType2.NumberMaximum = 38)] = "NumberMaximum"),
		(ValueErrorType2[(ValueErrorType2.NumberMinimum = 39)] = "NumberMinimum"),
		(ValueErrorType2[(ValueErrorType2.NumberMultipleOf = 40)] =
			"NumberMultipleOf"),
		(ValueErrorType2[(ValueErrorType2.Number = 41)] = "Number"),
		(ValueErrorType2[(ValueErrorType2.ObjectAdditionalProperties = 42)] =
			"ObjectAdditionalProperties"),
		(ValueErrorType2[(ValueErrorType2.ObjectMaxProperties = 43)] =
			"ObjectMaxProperties"),
		(ValueErrorType2[(ValueErrorType2.ObjectMinProperties = 44)] =
			"ObjectMinProperties"),
		(ValueErrorType2[(ValueErrorType2.ObjectRequiredProperty = 45)] =
			"ObjectRequiredProperty"),
		(ValueErrorType2[(ValueErrorType2.Object = 46)] = "Object"),
		(ValueErrorType2[(ValueErrorType2.Promise = 47)] = "Promise"),
		(ValueErrorType2[(ValueErrorType2.RegExp = 48)] = "RegExp"),
		(ValueErrorType2[(ValueErrorType2.StringFormatUnknown = 49)] =
			"StringFormatUnknown"),
		(ValueErrorType2[(ValueErrorType2.StringFormat = 50)] = "StringFormat"),
		(ValueErrorType2[(ValueErrorType2.StringMaxLength = 51)] =
			"StringMaxLength"),
		(ValueErrorType2[(ValueErrorType2.StringMinLength = 52)] =
			"StringMinLength"),
		(ValueErrorType2[(ValueErrorType2.StringPattern = 53)] = "StringPattern"),
		(ValueErrorType2[(ValueErrorType2.String = 54)] = "String"),
		(ValueErrorType2[(ValueErrorType2.Symbol = 55)] = "Symbol"),
		(ValueErrorType2[(ValueErrorType2.TupleLength = 56)] = "TupleLength"),
		(ValueErrorType2[(ValueErrorType2.Tuple = 57)] = "Tuple"),
		(ValueErrorType2[(ValueErrorType2.Uint8ArrayMaxByteLength = 58)] =
			"Uint8ArrayMaxByteLength"),
		(ValueErrorType2[(ValueErrorType2.Uint8ArrayMinByteLength = 59)] =
			"Uint8ArrayMinByteLength"),
		(ValueErrorType2[(ValueErrorType2.Uint8Array = 60)] = "Uint8Array"),
		(ValueErrorType2[(ValueErrorType2.Undefined = 61)] = "Undefined"),
		(ValueErrorType2[(ValueErrorType2.Union = 62)] = "Union"),
		(ValueErrorType2[(ValueErrorType2.Void = 63)] = "Void");
})(ValueErrorType || (ValueErrorType = {}));
class ValueErrorsUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}
function EscapeKey(key) {
	return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
	return value !== void 0;
}
class ValueErrorIterator {
	constructor(iterator) {
		this.iterator = iterator;
	}
	[Symbol.iterator]() {
		return this.iterator;
	}
	First() {
		let next = this.iterator.next();
		return next.done ? void 0 : next.value;
	}
}
function Create(errorType, schema, path, value, errors = []) {
	return {
		type: errorType,
		schema,
		path,
		value,
		message: GetErrorFunction()({ errorType, path, schema, value, errors }),
		errors,
	};
}
function* FromAny3(schema, references, path, value) {}
function* FromArgument3(schema, references, path, value) {}
function* FromArray8(schema, references, path, value) {
	if (!IsArray2(value))
		return yield Create(ValueErrorType.Array, schema, path, value);
	if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems))
		yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
	if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems))
		yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
	for (let i = 0; i < value.length; i++)
		yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
	if (
		schema.uniqueItems === !0 &&
		!(function () {
			let set2 = new Set();
			for (let element of value) {
				let hashed = Hash(element);
				if (set2.has(hashed)) return !1;
				else set2.add(hashed);
			}
			return !0;
		})()
	)
		yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
	if (
		!(
			IsDefined2(schema.contains) ||
			IsDefined2(schema.minContains) ||
			IsDefined2(schema.maxContains)
		)
	)
		return;
	let containsSchema = IsDefined2(schema.contains) ? schema.contains : Never(),
		containsCount = value.reduce(
			(acc, value2, index) =>
				Visit6(containsSchema, references, `${path}${index}`, value2).next()
					.done === !0
					? acc + 1
					: acc,
			0,
		);
	if (containsCount === 0)
		yield Create(ValueErrorType.ArrayContains, schema, path, value);
	if (IsNumber2(schema.minContains) && containsCount < schema.minContains)
		yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
	if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains)
		yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
}
function* FromAsyncIterator5(schema, references, path, value) {
	if (!IsAsyncIterator2(value))
		yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
	if (!IsBigInt2(value))
		return yield Create(ValueErrorType.BigInt, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum))
		yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum))
		yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
	if (IsDefined2(schema.multipleOf) && value % schema.multipleOf !== BigInt(0))
		yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
}
function* FromBoolean3(schema, references, path, value) {
	if (!IsBoolean2(value))
		yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
	yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
	if (!IsDate2(value))
		return yield Create(ValueErrorType.Date, schema, path, value);
	if (
		IsDefined2(schema.exclusiveMaximumTimestamp) &&
		!(value.getTime() < schema.exclusiveMaximumTimestamp)
	)
		yield Create(
			ValueErrorType.DateExclusiveMaximumTimestamp,
			schema,
			path,
			value,
		);
	if (
		IsDefined2(schema.exclusiveMinimumTimestamp) &&
		!(value.getTime() > schema.exclusiveMinimumTimestamp)
	)
		yield Create(
			ValueErrorType.DateExclusiveMinimumTimestamp,
			schema,
			path,
			value,
		);
	if (
		IsDefined2(schema.maximumTimestamp) &&
		!(value.getTime() <= schema.maximumTimestamp)
	)
		yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
	if (
		IsDefined2(schema.minimumTimestamp) &&
		!(value.getTime() >= schema.minimumTimestamp)
	)
		yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
	if (
		IsDefined2(schema.multipleOfTimestamp) &&
		value.getTime() % schema.multipleOfTimestamp !== 0
	)
		yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
}
function* FromFunction5(schema, references, path, value) {
	if (!IsFunction2(value))
		yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
	if (!IsInteger(value))
		return yield Create(ValueErrorType.Integer, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum))
		yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum))
		yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
	if (IsDefined2(schema.multipleOf) && value % schema.multipleOf !== 0)
		yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
}
function* FromIntersect10(schema, references, path, value) {
	let hasError = !1;
	for (let inner of schema.allOf)
		for (let error of Visit6(inner, references, path, value))
			(hasError = !0), yield error;
	if (hasError)
		return yield Create(ValueErrorType.Intersect, schema, path, value);
	if (schema.unevaluatedProperties === !1) {
		let keyCheck = new RegExp(KeyOfPattern(schema));
		for (let valueKey of Object.getOwnPropertyNames(value))
			if (!keyCheck.test(valueKey))
				yield Create(
					ValueErrorType.IntersectUnevaluatedProperties,
					schema,
					`${path}/${valueKey}`,
					value,
				);
	}
	if (typeof schema.unevaluatedProperties === "object") {
		let keyCheck = new RegExp(KeyOfPattern(schema));
		for (let valueKey of Object.getOwnPropertyNames(value))
			if (!keyCheck.test(valueKey)) {
				let next = Visit6(
					schema.unevaluatedProperties,
					references,
					`${path}/${valueKey}`,
					value[valueKey],
				).next();
				if (!next.done) yield next.value;
			}
	}
}
function* FromIterator5(schema, references, path, value) {
	if (!IsIterator2(value))
		yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
	if (value !== schema.const)
		yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
	yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
	if (Visit6(schema.not, references, path, value).next().done === !0)
		yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
	if (!IsNull2(value)) yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
	if (!TypeSystemPolicy.IsNumberLike(value))
		return yield Create(ValueErrorType.Number, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum))
		yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum))
		yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum))
		yield Create(ValueErrorType.NumberMaximum, schema, path, value);
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum))
		yield Create(ValueErrorType.NumberMinimum, schema, path, value);
	if (IsDefined2(schema.multipleOf) && value % schema.multipleOf !== 0)
		yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
}
function* FromObject9(schema, references, path, value) {
	if (!TypeSystemPolicy.IsObjectLike(value))
		return yield Create(ValueErrorType.Object, schema, path, value);
	if (
		IsDefined2(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	)
		yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
	if (
		IsDefined2(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	)
		yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
	let requiredKeys = Array.isArray(schema.required) ? schema.required : [],
		knownKeys = Object.getOwnPropertyNames(schema.properties),
		unknownKeys = Object.getOwnPropertyNames(value);
	for (let requiredKey of requiredKeys) {
		if (unknownKeys.includes(requiredKey)) continue;
		yield Create(
			ValueErrorType.ObjectRequiredProperty,
			schema.properties[requiredKey],
			`${path}/${EscapeKey(requiredKey)}`,
			void 0,
		);
	}
	if (schema.additionalProperties === !1) {
		for (let valueKey of unknownKeys)
			if (!knownKeys.includes(valueKey))
				yield Create(
					ValueErrorType.ObjectAdditionalProperties,
					schema,
					`${path}/${EscapeKey(valueKey)}`,
					value[valueKey],
				);
	}
	if (typeof schema.additionalProperties === "object")
		for (let valueKey of unknownKeys) {
			if (knownKeys.includes(valueKey)) continue;
			yield* Visit6(
				schema.additionalProperties,
				references,
				`${path}/${EscapeKey(valueKey)}`,
				value[valueKey],
			);
		}
	for (let knownKey of knownKeys) {
		let property = schema.properties[knownKey];
		if (schema.required && schema.required.includes(knownKey)) {
			if (
				(yield* Visit6(
					property,
					references,
					`${path}/${EscapeKey(knownKey)}`,
					value[knownKey],
				),
				ExtendsUndefinedCheck(schema) && !(knownKey in value))
			)
				yield Create(
					ValueErrorType.ObjectRequiredProperty,
					property,
					`${path}/${EscapeKey(knownKey)}`,
					void 0,
				);
		} else if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey))
			yield* Visit6(
				property,
				references,
				`${path}/${EscapeKey(knownKey)}`,
				value[knownKey],
			);
	}
}
function* FromPromise5(schema, references, path, value) {
	if (!IsPromise(value))
		yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
	if (!TypeSystemPolicy.IsRecordLike(value))
		return yield Create(ValueErrorType.Object, schema, path, value);
	if (
		IsDefined2(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	)
		yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
	if (
		IsDefined2(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	)
		yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
	let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
		regex = new RegExp(patternKey);
	for (let [propertyKey, propertyValue] of Object.entries(value))
		if (regex.test(propertyKey))
			yield* Visit6(
				patternSchema,
				references,
				`${path}/${EscapeKey(propertyKey)}`,
				propertyValue,
			);
	if (typeof schema.additionalProperties === "object") {
		for (let [propertyKey, propertyValue] of Object.entries(value))
			if (!regex.test(propertyKey))
				yield* Visit6(
					schema.additionalProperties,
					references,
					`${path}/${EscapeKey(propertyKey)}`,
					propertyValue,
				);
	}
	if (schema.additionalProperties === !1)
		for (let [propertyKey, propertyValue] of Object.entries(value)) {
			if (regex.test(propertyKey)) continue;
			return yield Create(
				ValueErrorType.ObjectAdditionalProperties,
				schema,
				`${path}/${EscapeKey(propertyKey)}`,
				propertyValue,
			);
		}
}
function* FromRef6(schema, references, path, value) {
	yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
	if (!IsString2(value))
		return yield Create(ValueErrorType.String, schema, path, value);
	if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength))
		yield Create(ValueErrorType.StringMinLength, schema, path, value);
	if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength))
		yield Create(ValueErrorType.StringMaxLength, schema, path, value);
	if (!new RegExp(schema.source, schema.flags).test(value))
		return yield Create(ValueErrorType.RegExp, schema, path, value);
}
function* FromString3(schema, references, path, value) {
	if (!IsString2(value))
		return yield Create(ValueErrorType.String, schema, path, value);
	if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength))
		yield Create(ValueErrorType.StringMinLength, schema, path, value);
	if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength))
		yield Create(ValueErrorType.StringMaxLength, schema, path, value);
	if (IsString2(schema.pattern)) {
		if (!new RegExp(schema.pattern).test(value))
			yield Create(ValueErrorType.StringPattern, schema, path, value);
	}
	if (IsString2(schema.format)) {
		if (!exports_format.Has(schema.format))
			yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
		else if (!exports_format.Get(schema.format)(value))
			yield Create(ValueErrorType.StringFormat, schema, path, value);
	}
}
function* FromSymbol3(schema, references, path, value) {
	if (!IsSymbol2(value))
		yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
	if (!IsString2(value))
		return yield Create(ValueErrorType.String, schema, path, value);
	if (!new RegExp(schema.pattern).test(value))
		yield Create(ValueErrorType.StringPattern, schema, path, value);
}
function* FromThis2(schema, references, path, value) {
	yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
	if (!IsArray2(value))
		return yield Create(ValueErrorType.Tuple, schema, path, value);
	if (schema.items === void 0 && value.length !== 0)
		return yield Create(ValueErrorType.TupleLength, schema, path, value);
	if (value.length !== schema.maxItems)
		return yield Create(ValueErrorType.TupleLength, schema, path, value);
	if (!schema.items) return;
	for (let i = 0; i < schema.items.length; i++)
		yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
}
function* FromUndefined3(schema, references, path, value) {
	if (!IsUndefined2(value))
		yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
	if (Check(schema, references, value)) return;
	let errors = schema.anyOf.map(
		(variant) =>
			new ValueErrorIterator(Visit6(variant, references, path, value)),
	);
	yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
	if (!IsUint8Array2(value))
		return yield Create(ValueErrorType.Uint8Array, schema, path, value);
	if (
		IsDefined2(schema.maxByteLength) &&
		!(value.length <= schema.maxByteLength)
	)
		yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
	if (
		IsDefined2(schema.minByteLength) &&
		!(value.length >= schema.minByteLength)
	)
		yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
}
function* FromUnknown3(schema, references, path, value) {}
function* FromVoid3(schema, references, path, value) {
	if (!TypeSystemPolicy.IsVoidLike(value))
		yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
	if (!exports_type2.Get(schema[Kind])(schema, value))
		yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
	let references_ = IsDefined2(schema.$id)
			? [...references, schema]
			: references,
		schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return yield* FromAny3(schema_, references_, path, value);
		case "Argument":
			return yield* FromArgument3(schema_, references_, path, value);
		case "Array":
			return yield* FromArray8(schema_, references_, path, value);
		case "AsyncIterator":
			return yield* FromAsyncIterator5(schema_, references_, path, value);
		case "BigInt":
			return yield* FromBigInt3(schema_, references_, path, value);
		case "Boolean":
			return yield* FromBoolean3(schema_, references_, path, value);
		case "Constructor":
			return yield* FromConstructor5(schema_, references_, path, value);
		case "Date":
			return yield* FromDate3(schema_, references_, path, value);
		case "Function":
			return yield* FromFunction5(schema_, references_, path, value);
		case "Import":
			return yield* FromImport2(schema_, references_, path, value);
		case "Integer":
			return yield* FromInteger3(schema_, references_, path, value);
		case "Intersect":
			return yield* FromIntersect10(schema_, references_, path, value);
		case "Iterator":
			return yield* FromIterator5(schema_, references_, path, value);
		case "Literal":
			return yield* FromLiteral4(schema_, references_, path, value);
		case "Never":
			return yield* FromNever3(schema_, references_, path, value);
		case "Not":
			return yield* FromNot3(schema_, references_, path, value);
		case "Null":
			return yield* FromNull3(schema_, references_, path, value);
		case "Number":
			return yield* FromNumber3(schema_, references_, path, value);
		case "Object":
			return yield* FromObject9(schema_, references_, path, value);
		case "Promise":
			return yield* FromPromise5(schema_, references_, path, value);
		case "Record":
			return yield* FromRecord5(schema_, references_, path, value);
		case "Ref":
			return yield* FromRef6(schema_, references_, path, value);
		case "RegExp":
			return yield* FromRegExp3(schema_, references_, path, value);
		case "String":
			return yield* FromString3(schema_, references_, path, value);
		case "Symbol":
			return yield* FromSymbol3(schema_, references_, path, value);
		case "TemplateLiteral":
			return yield* FromTemplateLiteral5(schema_, references_, path, value);
		case "This":
			return yield* FromThis2(schema_, references_, path, value);
		case "Tuple":
			return yield* FromTuple7(schema_, references_, path, value);
		case "Undefined":
			return yield* FromUndefined3(schema_, references_, path, value);
		case "Union":
			return yield* FromUnion12(schema_, references_, path, value);
		case "Uint8Array":
			return yield* FromUint8Array3(schema_, references_, path, value);
		case "Unknown":
			return yield* FromUnknown3(schema_, references_, path, value);
		case "Void":
			return yield* FromVoid3(schema_, references_, path, value);
		default:
			if (!exports_type2.Has(schema_[Kind]))
				throw new ValueErrorsUnknownTypeError(schema);
			return yield* FromKind2(schema_, references_, path, value);
	}
}
function Errors(...args) {
	let iterator =
		args.length === 3
			? Visit6(args[0], args[1], "", args[2])
			: Visit6(args[0], [], "", args[1]);
	return new ValueErrorIterator(iterator);
}
class TransformDecodeCheckError extends TypeBoxError {
	constructor(schema, value, error) {
		super("Unable to decode value as it does not match the expected schema");
		(this.schema = schema), (this.value = value), (this.error = error);
	}
}
class TransformDecodeError extends TypeBoxError {
	constructor(schema, path, value, error) {
		super(error instanceof Error ? error.message : "Unknown error");
		(this.schema = schema),
			(this.path = path),
			(this.value = value),
			(this.error = error);
	}
}
function Default(schema, path, value) {
	try {
		return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
	} catch (error) {
		throw new TransformDecodeError(schema, path, value, error);
	}
}
function FromArray9(schema, references, path, value) {
	return IsArray2(value)
		? Default(
				schema,
				path,
				value.map((value2, index) =>
					Visit7(schema.items, references, `${path}/${index}`, value2),
				),
			)
		: Default(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
	if (!IsObject2(value) || IsValueType(value))
		return Default(schema, path, value);
	let knownEntries = KeyOfPropertyEntries(schema),
		knownKeys = knownEntries.map((entry) => entry[0]),
		knownProperties = { ...value };
	for (let [knownKey, knownSchema] of knownEntries)
		if (knownKey in knownProperties)
			knownProperties[knownKey] = Visit7(
				knownSchema,
				references,
				`${path}/${knownKey}`,
				knownProperties[knownKey],
			);
	if (!IsTransform(schema.unevaluatedProperties))
		return Default(schema, path, knownProperties);
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		unevaluatedProperties = schema.unevaluatedProperties,
		unknownProperties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.includes(key))
			unknownProperties[key] = Default(
				unevaluatedProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
	return Default(schema, path, unknownProperties);
}
function FromImport3(schema, references, path, value) {
	let additional = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref],
		result = Visit7(target, [...references, ...additional], path, value);
	return Default(schema, path, result);
}
function FromNot4(schema, references, path, value) {
	return Default(schema, path, Visit7(schema.not, references, path, value));
}
function FromObject10(schema, references, path, value) {
	if (!IsObject2(value)) return Default(schema, path, value);
	let knownKeys = KeyOfPropertyKeys(schema),
		knownProperties = { ...value };
	for (let key of knownKeys) {
		if (!HasPropertyKey2(knownProperties, key)) continue;
		if (
			IsUndefined2(knownProperties[key]) &&
			(!IsUndefined3(schema.properties[key]) ||
				TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key))
		)
			continue;
		knownProperties[key] = Visit7(
			schema.properties[key],
			references,
			`${path}/${key}`,
			knownProperties[key],
		);
	}
	if (!IsSchema(schema.additionalProperties))
		return Default(schema, path, knownProperties);
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		additionalProperties = schema.additionalProperties,
		unknownProperties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.includes(key))
			unknownProperties[key] = Default(
				additionalProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
	return Default(schema, path, unknownProperties);
}
function FromRecord6(schema, references, path, value) {
	if (!IsObject2(value)) return Default(schema, path, value);
	let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
		knownKeys = new RegExp(pattern),
		knownProperties = { ...value };
	for (let key of Object.getOwnPropertyNames(value))
		if (knownKeys.test(key))
			knownProperties[key] = Visit7(
				schema.patternProperties[pattern],
				references,
				`${path}/${key}`,
				knownProperties[key],
			);
	if (!IsSchema(schema.additionalProperties))
		return Default(schema, path, knownProperties);
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		additionalProperties = schema.additionalProperties,
		unknownProperties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.test(key))
			unknownProperties[key] = Default(
				additionalProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
	return Default(schema, path, unknownProperties);
}
function FromRef7(schema, references, path, value) {
	let target = Deref(schema, references);
	return Default(schema, path, Visit7(target, references, path, value));
}
function FromThis3(schema, references, path, value) {
	let target = Deref(schema, references);
	return Default(schema, path, Visit7(target, references, path, value));
}
function FromTuple8(schema, references, path, value) {
	return IsArray2(value) && IsArray2(schema.items)
		? Default(
				schema,
				path,
				schema.items.map((schema2, index) =>
					Visit7(schema2, references, `${path}/${index}`, value[index]),
				),
			)
		: Default(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
	for (let subschema of schema.anyOf) {
		if (!Check(subschema, references, value)) continue;
		let decoded = Visit7(subschema, references, path, value);
		return Default(schema, path, decoded);
	}
	return Default(schema, path, value);
}
function Visit7(schema, references, path, value) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray9(schema_, references_, path, value);
		case "Import":
			return FromImport3(schema_, references_, path, value);
		case "Intersect":
			return FromIntersect11(schema_, references_, path, value);
		case "Not":
			return FromNot4(schema_, references_, path, value);
		case "Object":
			return FromObject10(schema_, references_, path, value);
		case "Record":
			return FromRecord6(schema_, references_, path, value);
		case "Ref":
			return FromRef7(schema_, references_, path, value);
		case "Symbol":
			return Default(schema_, path, value);
		case "This":
			return FromThis3(schema_, references_, path, value);
		case "Tuple":
			return FromTuple8(schema_, references_, path, value);
		case "Union":
			return FromUnion13(schema_, references_, path, value);
		default:
			return Default(schema_, path, value);
	}
}
function TransformDecode(schema, references, value) {
	return Visit7(schema, references, "", value);
}
class TransformEncodeCheckError extends TypeBoxError {
	constructor(schema, value, error) {
		super("The encoded value does not match the expected schema");
		(this.schema = schema), (this.value = value), (this.error = error);
	}
}
class TransformEncodeError extends TypeBoxError {
	constructor(schema, path, value, error) {
		super(`${error instanceof Error ? error.message : "Unknown error"}`);
		(this.schema = schema),
			(this.path = path),
			(this.value = value),
			(this.error = error);
	}
}
function Default2(schema, path, value) {
	try {
		return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
	} catch (error) {
		throw new TransformEncodeError(schema, path, value, error);
	}
}
function FromArray10(schema, references, path, value) {
	let defaulted = Default2(schema, path, value);
	return IsArray2(defaulted)
		? defaulted.map((value2, index) =>
				Visit8(schema.items, references, `${path}/${index}`, value2),
			)
		: defaulted;
}
function FromImport4(schema, references, path, value) {
	let additional = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref],
		result = Default2(schema, path, value);
	return Visit8(target, [...references, ...additional], path, result);
}
function FromIntersect12(schema, references, path, value) {
	let defaulted = Default2(schema, path, value);
	if (!IsObject2(value) || IsValueType(value)) return defaulted;
	let knownEntries = KeyOfPropertyEntries(schema),
		knownKeys = knownEntries.map((entry) => entry[0]),
		knownProperties = { ...defaulted };
	for (let [knownKey, knownSchema] of knownEntries)
		if (knownKey in knownProperties)
			knownProperties[knownKey] = Visit8(
				knownSchema,
				references,
				`${path}/${knownKey}`,
				knownProperties[knownKey],
			);
	if (!IsTransform(schema.unevaluatedProperties)) return knownProperties;
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		unevaluatedProperties = schema.unevaluatedProperties,
		properties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.includes(key))
			properties[key] = Default2(
				unevaluatedProperties,
				`${path}/${key}`,
				properties[key],
			);
	return properties;
}
function FromNot5(schema, references, path, value) {
	return Default2(schema.not, path, Default2(schema, path, value));
}
function FromObject11(schema, references, path, value) {
	let defaulted = Default2(schema, path, value);
	if (!IsObject2(defaulted)) return defaulted;
	let knownKeys = KeyOfPropertyKeys(schema),
		knownProperties = { ...defaulted };
	for (let key of knownKeys) {
		if (!HasPropertyKey2(knownProperties, key)) continue;
		if (
			IsUndefined2(knownProperties[key]) &&
			(!IsUndefined3(schema.properties[key]) ||
				TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key))
		)
			continue;
		knownProperties[key] = Visit8(
			schema.properties[key],
			references,
			`${path}/${key}`,
			knownProperties[key],
		);
	}
	if (!IsSchema(schema.additionalProperties)) return knownProperties;
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		additionalProperties = schema.additionalProperties,
		properties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.includes(key))
			properties[key] = Default2(
				additionalProperties,
				`${path}/${key}`,
				properties[key],
			);
	return properties;
}
function FromRecord7(schema, references, path, value) {
	let defaulted = Default2(schema, path, value);
	if (!IsObject2(value)) return defaulted;
	let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
		knownKeys = new RegExp(pattern),
		knownProperties = { ...defaulted };
	for (let key of Object.getOwnPropertyNames(value))
		if (knownKeys.test(key))
			knownProperties[key] = Visit8(
				schema.patternProperties[pattern],
				references,
				`${path}/${key}`,
				knownProperties[key],
			);
	if (!IsSchema(schema.additionalProperties)) return knownProperties;
	let unknownKeys = Object.getOwnPropertyNames(knownProperties),
		additionalProperties = schema.additionalProperties,
		properties = { ...knownProperties };
	for (let key of unknownKeys)
		if (!knownKeys.test(key))
			properties[key] = Default2(
				additionalProperties,
				`${path}/${key}`,
				properties[key],
			);
	return properties;
}
function FromRef8(schema, references, path, value) {
	let target = Deref(schema, references),
		resolved = Visit8(target, references, path, value);
	return Default2(schema, path, resolved);
}
function FromThis4(schema, references, path, value) {
	let target = Deref(schema, references),
		resolved = Visit8(target, references, path, value);
	return Default2(schema, path, resolved);
}
function FromTuple9(schema, references, path, value) {
	let value1 = Default2(schema, path, value);
	return IsArray2(schema.items)
		? schema.items.map((schema2, index) =>
				Visit8(schema2, references, `${path}/${index}`, value1[index]),
			)
		: [];
}
function FromUnion14(schema, references, path, value) {
	for (let subschema of schema.anyOf) {
		if (!Check(subschema, references, value)) continue;
		let value1 = Visit8(subschema, references, path, value);
		return Default2(schema, path, value1);
	}
	for (let subschema of schema.anyOf) {
		let value1 = Visit8(subschema, references, path, value);
		if (!Check(schema, references, value1)) continue;
		return Default2(schema, path, value1);
	}
	return Default2(schema, path, value);
}
function Visit8(schema, references, path, value) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray10(schema_, references_, path, value);
		case "Import":
			return FromImport4(schema_, references_, path, value);
		case "Intersect":
			return FromIntersect12(schema_, references_, path, value);
		case "Not":
			return FromNot5(schema_, references_, path, value);
		case "Object":
			return FromObject11(schema_, references_, path, value);
		case "Record":
			return FromRecord7(schema_, references_, path, value);
		case "Ref":
			return FromRef8(schema_, references_, path, value);
		case "This":
			return FromThis4(schema_, references_, path, value);
		case "Tuple":
			return FromTuple9(schema_, references_, path, value);
		case "Union":
			return FromUnion14(schema_, references_, path, value);
		default:
			return Default2(schema_, path, value);
	}
}
function TransformEncode(schema, references, value) {
	return Visit8(schema, references, "", value);
}
function FromArray11(schema, references) {
	return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator6(schema, references) {
	return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor6(schema, references) {
	return (
		IsTransform(schema) ||
		Visit9(schema.returns, references) ||
		schema.parameters.some((schema2) => Visit9(schema2, references))
	);
}
function FromFunction6(schema, references) {
	return (
		IsTransform(schema) ||
		Visit9(schema.returns, references) ||
		schema.parameters.some((schema2) => Visit9(schema2, references))
	);
}
function FromIntersect13(schema, references) {
	return (
		IsTransform(schema) ||
		IsTransform(schema.unevaluatedProperties) ||
		schema.allOf.some((schema2) => Visit9(schema2, references))
	);
}
function FromImport5(schema, references) {
	let additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce(
			(result, key) => [...result, schema.$defs[key]],
			[],
		),
		target = schema.$defs[schema.$ref];
	return IsTransform(schema) || Visit9(target, [...additional, ...references]);
}
function FromIterator6(schema, references) {
	return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
	return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject12(schema, references) {
	return (
		IsTransform(schema) ||
		Object.values(schema.properties).some((schema2) =>
			Visit9(schema2, references),
		) ||
		(IsSchema(schema.additionalProperties) &&
			Visit9(schema.additionalProperties, references))
	);
}
function FromPromise6(schema, references) {
	return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord8(schema, references) {
	let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
		property = schema.patternProperties[pattern];
	return (
		IsTransform(schema) ||
		Visit9(property, references) ||
		(IsSchema(schema.additionalProperties) &&
			IsTransform(schema.additionalProperties))
	);
}
function FromRef9(schema, references) {
	if (IsTransform(schema)) return !0;
	return Visit9(Deref(schema, references), references);
}
function FromThis5(schema, references) {
	if (IsTransform(schema)) return !0;
	return Visit9(Deref(schema, references), references);
}
function FromTuple10(schema, references) {
	return (
		IsTransform(schema) ||
		(!IsUndefined2(schema.items) &&
			schema.items.some((schema2) => Visit9(schema2, references)))
	);
}
function FromUnion15(schema, references) {
	return (
		IsTransform(schema) ||
		schema.anyOf.some((schema2) => Visit9(schema2, references))
	);
}
function Visit9(schema, references) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	if (schema.$id && visited.has(schema.$id)) return !1;
	if (schema.$id) visited.add(schema.$id);
	switch (schema[Kind]) {
		case "Array":
			return FromArray11(schema_, references_);
		case "AsyncIterator":
			return FromAsyncIterator6(schema_, references_);
		case "Constructor":
			return FromConstructor6(schema_, references_);
		case "Function":
			return FromFunction6(schema_, references_);
		case "Import":
			return FromImport5(schema_, references_);
		case "Intersect":
			return FromIntersect13(schema_, references_);
		case "Iterator":
			return FromIterator6(schema_, references_);
		case "Not":
			return FromNot6(schema_, references_);
		case "Object":
			return FromObject12(schema_, references_);
		case "Promise":
			return FromPromise6(schema_, references_);
		case "Record":
			return FromRecord8(schema_, references_);
		case "Ref":
			return FromRef9(schema_, references_);
		case "This":
			return FromThis5(schema_, references_);
		case "Tuple":
			return FromTuple10(schema_, references_);
		case "Union":
			return FromUnion15(schema_, references_);
		default:
			return IsTransform(schema);
	}
}
var visited = new Set();
function HasTransform(schema, references) {
	return visited.clear(), Visit9(schema, references);
}
class TypeCheck {
	constructor(schema, references, checkFunc, code) {
		(this.schema = schema),
			(this.references = references),
			(this.checkFunc = checkFunc),
			(this.code = code),
			(this.hasTransform = HasTransform(schema, references));
	}
	Code() {
		return this.code;
	}
	Schema() {
		return this.schema;
	}
	References() {
		return this.references;
	}
	Errors(value) {
		return Errors(this.schema, this.references, value);
	}
	Check(value) {
		return this.checkFunc(value);
	}
	Decode(value) {
		if (!this.checkFunc(value))
			throw new TransformDecodeCheckError(
				this.schema,
				value,
				this.Errors(value).First(),
			);
		return this.hasTransform
			? TransformDecode(this.schema, this.references, value)
			: value;
	}
	Encode(value) {
		let encoded = this.hasTransform
			? TransformEncode(this.schema, this.references, value)
			: value;
		if (!this.checkFunc(encoded))
			throw new TransformEncodeCheckError(
				this.schema,
				value,
				this.Errors(value).First(),
			);
		return encoded;
	}
}
var Character;
(function (Character2) {
	function DollarSign(code) {
		return code === 36;
	}
	Character2.DollarSign = DollarSign;
	function IsUnderscore(code) {
		return code === 95;
	}
	Character2.IsUnderscore = IsUnderscore;
	function IsAlpha(code) {
		return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
	}
	Character2.IsAlpha = IsAlpha;
	function IsNumeric(code) {
		return code >= 48 && code <= 57;
	}
	Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function (MemberExpression2) {
	function IsFirstCharacterNumeric(value) {
		if (value.length === 0) return !1;
		return Character.IsNumeric(value.charCodeAt(0));
	}
	function IsAccessor(value) {
		if (IsFirstCharacterNumeric(value)) return !1;
		for (let i = 0; i < value.length; i++) {
			let code = value.charCodeAt(i);
			if (
				!(
					Character.IsAlpha(code) ||
					Character.IsNumeric(code) ||
					Character.DollarSign(code) ||
					Character.IsUnderscore(code)
				)
			)
				return !1;
		}
		return !0;
	}
	function EscapeHyphen(key) {
		return key.replace(/'/g, "\\'");
	}
	function Encode(object, key) {
		return IsAccessor(key)
			? `${object}.${key}`
			: `${object}['${EscapeHyphen(key)}']`;
	}
	MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function (Identifier2) {
	function Encode($id) {
		let buffer = [];
		for (let i = 0; i < $id.length; i++) {
			let code = $id.charCodeAt(i);
			if (Character.IsNumeric(code) || Character.IsAlpha(code))
				buffer.push($id.charAt(i));
			else buffer.push(`_${code}_`);
		}
		return buffer.join("").replace(/__/g, "_");
	}
	Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function (LiteralString2) {
	function Escape2(content) {
		return content.replace(/'/g, "\\'");
	}
	LiteralString2.Escape = Escape2;
})(LiteralString || (LiteralString = {}));
class TypeCompilerUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}
class TypeCompilerTypeGuardError extends TypeBoxError {
	constructor(schema) {
		super("Preflight validation check failed to guard for the given schema");
		this.schema = schema;
	}
}
var Policy;
(function (Policy2) {
	function IsExactOptionalProperty(value, key, expression) {
		return TypeSystemPolicy.ExactOptionalPropertyTypes
			? `('${key}' in ${value} ? ${expression} : true)`
			: `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
	}
	Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
	function IsObjectLike(value) {
		return !TypeSystemPolicy.AllowArrayObject
			? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))`
			: `(typeof ${value} === 'object' && ${value} !== null)`;
	}
	Policy2.IsObjectLike = IsObjectLike;
	function IsRecordLike(value) {
		return !TypeSystemPolicy.AllowArrayObject
			? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`
			: `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
	}
	Policy2.IsRecordLike = IsRecordLike;
	function IsNumberLike(value) {
		return TypeSystemPolicy.AllowNaN
			? `typeof ${value} === 'number'`
			: `Number.isFinite(${value})`;
	}
	Policy2.IsNumberLike = IsNumberLike;
	function IsVoidLike(value) {
		return TypeSystemPolicy.AllowNullVoid
			? `(${value} === undefined || ${value} === null)`
			: `${value} === undefined`;
	}
	Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function (TypeCompiler2) {
	function IsAnyOrUnknown2(schema) {
		return schema[Kind] === "Any" || schema[Kind] === "Unknown";
	}
	function* FromAny4(schema, references, value) {
		yield "true";
	}
	function* FromArgument4(schema, references, value) {
		yield "true";
	}
	function* FromArray12(schema, references, value) {
		yield `Array.isArray(${value})`;
		let [parameter, accumulator] = [
			CreateParameter("value", "any"),
			CreateParameter("acc", "number"),
		];
		if (IsNumber2(schema.maxItems))
			yield `${value}.length <= ${schema.maxItems}`;
		if (IsNumber2(schema.minItems))
			yield `${value}.length >= ${schema.minItems}`;
		let elementExpression = CreateExpression(schema.items, references, "value");
		if (
			(yield `${value}.every((${parameter}) => ${elementExpression})`,
			IsSchema2(schema.contains) ||
				IsNumber2(schema.minContains) ||
				IsNumber2(schema.maxContains))
		) {
			let containsSchema = IsSchema2(schema.contains)
					? schema.contains
					: Never(),
				checkExpression = CreateExpression(containsSchema, references, "value"),
				checkMinContains = IsNumber2(schema.minContains)
					? [`(count >= ${schema.minContains})`]
					: [],
				checkMaxContains = IsNumber2(schema.maxContains)
					? [`(count <= ${schema.maxContains})`]
					: [],
				checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`,
				check = ["(count > 0)", ...checkMinContains, ...checkMaxContains].join(
					" && ",
				);
			yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
		}
		if (schema.uniqueItems === !0)
			yield `((${parameter}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${value})`;
	}
	function* FromAsyncIterator7(schema, references, value) {
		yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
	}
	function* FromBigInt4(schema, references, value) {
		if (
			(yield `(typeof ${value} === 'bigint')`,
			IsBigInt2(schema.exclusiveMaximum))
		)
			yield `${value} < BigInt(${schema.exclusiveMaximum})`;
		if (IsBigInt2(schema.exclusiveMinimum))
			yield `${value} > BigInt(${schema.exclusiveMinimum})`;
		if (IsBigInt2(schema.maximum))
			yield `${value} <= BigInt(${schema.maximum})`;
		if (IsBigInt2(schema.minimum))
			yield `${value} >= BigInt(${schema.minimum})`;
		if (IsBigInt2(schema.multipleOf))
			yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
	}
	function* FromBoolean4(schema, references, value) {
		yield `(typeof ${value} === 'boolean')`;
	}
	function* FromConstructor7(schema, references, value) {
		yield* Visit10(schema.returns, references, `${value}.prototype`);
	}
	function* FromDate4(schema, references, value) {
		if (
			(yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`,
			IsNumber2(schema.exclusiveMaximumTimestamp))
		)
			yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
		if (IsNumber2(schema.exclusiveMinimumTimestamp))
			yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
		if (IsNumber2(schema.maximumTimestamp))
			yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
		if (IsNumber2(schema.minimumTimestamp))
			yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
		if (IsNumber2(schema.multipleOfTimestamp))
			yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
	}
	function* FromFunction7(schema, references, value) {
		yield `(typeof ${value} === 'function')`;
	}
	function* FromImport6(schema, references, value) {
		let members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce(
			(result, key) => {
				return [...result, schema.$defs[key]];
			},
			[],
		);
		yield* Visit10(Ref(schema.$ref), [...references, ...members], value);
	}
	function* FromInteger4(schema, references, value) {
		if (
			(yield `Number.isInteger(${value})`, IsNumber2(schema.exclusiveMaximum))
		)
			yield `${value} < ${schema.exclusiveMaximum}`;
		if (IsNumber2(schema.exclusiveMinimum))
			yield `${value} > ${schema.exclusiveMinimum}`;
		if (IsNumber2(schema.maximum)) yield `${value} <= ${schema.maximum}`;
		if (IsNumber2(schema.minimum)) yield `${value} >= ${schema.minimum}`;
		if (IsNumber2(schema.multipleOf))
			yield `(${value} % ${schema.multipleOf}) === 0`;
	}
	function* FromIntersect14(schema, references, value) {
		let check1 = schema.allOf
			.map((schema2) => CreateExpression(schema2, references, value))
			.join(" && ");
		if (schema.unevaluatedProperties === !1) {
			let keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`),
				check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
			yield `(${check1} && ${check2})`;
		} else if (IsSchema2(schema.unevaluatedProperties)) {
			let keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`),
				check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
			yield `(${check1} && ${check2})`;
		} else yield `(${check1})`;
	}
	function* FromIterator7(schema, references, value) {
		yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
	}
	function* FromLiteral5(schema, references, value) {
		if (typeof schema.const === "number" || typeof schema.const === "boolean")
			yield `(${value} === ${schema.const})`;
		else yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
	}
	function* FromNever4(schema, references, value) {
		yield "false";
	}
	function* FromNot7(schema, references, value) {
		yield `(!${CreateExpression(schema.not, references, value)})`;
	}
	function* FromNull4(schema, references, value) {
		yield `(${value} === null)`;
	}
	function* FromNumber4(schema, references, value) {
		if ((yield Policy.IsNumberLike(value), IsNumber2(schema.exclusiveMaximum)))
			yield `${value} < ${schema.exclusiveMaximum}`;
		if (IsNumber2(schema.exclusiveMinimum))
			yield `${value} > ${schema.exclusiveMinimum}`;
		if (IsNumber2(schema.maximum)) yield `${value} <= ${schema.maximum}`;
		if (IsNumber2(schema.minimum)) yield `${value} >= ${schema.minimum}`;
		if (IsNumber2(schema.multipleOf))
			yield `(${value} % ${schema.multipleOf}) === 0`;
	}
	function* FromObject13(schema, references, value) {
		if ((yield Policy.IsObjectLike(value), IsNumber2(schema.minProperties)))
			yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
		if (IsNumber2(schema.maxProperties))
			yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
		let knownKeys = Object.getOwnPropertyNames(schema.properties);
		for (let knownKey of knownKeys) {
			let memberExpression = MemberExpression.Encode(value, knownKey),
				property = schema.properties[knownKey];
			if (schema.required && schema.required.includes(knownKey)) {
				if (
					(yield* Visit10(property, references, memberExpression),
					ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
				)
					yield `('${knownKey}' in ${value})`;
			} else {
				let expression = CreateExpression(
					property,
					references,
					memberExpression,
				);
				yield Policy.IsExactOptionalProperty(value, knownKey, expression);
			}
		}
		if (schema.additionalProperties === !1)
			if (schema.required && schema.required.length === knownKeys.length)
				yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
			else {
				let keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
				yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
			}
		if (typeof schema.additionalProperties === "object") {
			let expression = CreateExpression(
					schema.additionalProperties,
					references,
					`${value}[key]`,
				),
				keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
			yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
		}
	}
	function* FromPromise7(schema, references, value) {
		yield `${value} instanceof Promise`;
	}
	function* FromRecord9(schema, references, value) {
		if ((yield Policy.IsRecordLike(value), IsNumber2(schema.minProperties)))
			yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
		if (IsNumber2(schema.maxProperties))
			yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
		let [patternKey, patternSchema] = Object.entries(
				schema.patternProperties,
			)[0],
			variable = CreateVariable(`${new RegExp(patternKey)}`),
			check1 = CreateExpression(patternSchema, references, "value"),
			check2 = IsSchema2(schema.additionalProperties)
				? CreateExpression(schema.additionalProperties, references, value)
				: schema.additionalProperties === !1
					? "false"
					: "true",
			expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
		yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
	}
	function* FromRef10(schema, references, value) {
		let target = Deref(schema, references);
		if (state.functions.has(schema.$ref))
			return yield `${CreateFunctionName(schema.$ref)}(${value})`;
		yield* Visit10(target, references, value);
	}
	function* FromRegExp4(schema, references, value) {
		let variable = CreateVariable(
			`${new RegExp(schema.source, schema.flags)};`,
		);
		if ((yield `(typeof ${value} === 'string')`, IsNumber2(schema.maxLength)))
			yield `${value}.length <= ${schema.maxLength}`;
		if (IsNumber2(schema.minLength))
			yield `${value}.length >= ${schema.minLength}`;
		yield `${variable}.test(${value})`;
	}
	function* FromString4(schema, references, value) {
		if ((yield `(typeof ${value} === 'string')`, IsNumber2(schema.maxLength)))
			yield `${value}.length <= ${schema.maxLength}`;
		if (IsNumber2(schema.minLength))
			yield `${value}.length >= ${schema.minLength}`;
		if (schema.pattern !== void 0)
			yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`;
		if (schema.format !== void 0) yield `format('${schema.format}', ${value})`;
	}
	function* FromSymbol4(schema, references, value) {
		yield `(typeof ${value} === 'symbol')`;
	}
	function* FromTemplateLiteral6(schema, references, value) {
		yield `(typeof ${value} === 'string')`,
			yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`;
	}
	function* FromThis6(schema, references, value) {
		yield `${CreateFunctionName(schema.$ref)}(${value})`;
	}
	function* FromTuple11(schema, references, value) {
		if ((yield `Array.isArray(${value})`, schema.items === void 0))
			return yield `${value}.length === 0`;
		yield `(${value}.length === ${schema.maxItems})`;
		for (let i = 0; i < schema.items.length; i++)
			yield `${CreateExpression(schema.items[i], references, `${value}[${i}]`)}`;
	}
	function* FromUndefined4(schema, references, value) {
		yield `${value} === undefined`;
	}
	function* FromUnion16(schema, references, value) {
		yield `(${schema.anyOf.map((schema2) => CreateExpression(schema2, references, value)).join(" || ")})`;
	}
	function* FromUint8Array4(schema, references, value) {
		if (
			(yield `${value} instanceof Uint8Array`, IsNumber2(schema.maxByteLength))
		)
			yield `(${value}.length <= ${schema.maxByteLength})`;
		if (IsNumber2(schema.minByteLength))
			yield `(${value}.length >= ${schema.minByteLength})`;
	}
	function* FromUnknown4(schema, references, value) {
		yield "true";
	}
	function* FromVoid4(schema, references, value) {
		yield Policy.IsVoidLike(value);
	}
	function* FromKind3(schema, references, value) {
		let instance = state.instances.size;
		state.instances.set(instance, schema),
			yield `kind('${schema[Kind]}', ${instance}, ${value})`;
	}
	function* Visit10(schema, references, value, useHoisting = !0) {
		let references_ = IsString2(schema.$id)
				? [...references, schema]
				: references,
			schema_ = schema;
		if (useHoisting && IsString2(schema.$id)) {
			let functionName = CreateFunctionName(schema.$id);
			if (state.functions.has(functionName))
				return yield `${functionName}(${value})`;
			else {
				state.functions.set(functionName, "<deferred>");
				let functionCode = CreateFunction(
					functionName,
					schema,
					references,
					"value",
					!1,
				);
				return (
					state.functions.set(functionName, functionCode),
					yield `${functionName}(${value})`
				);
			}
		}
		switch (schema_[Kind]) {
			case "Any":
				return yield* FromAny4(schema_, references_, value);
			case "Argument":
				return yield* FromArgument4(schema_, references_, value);
			case "Array":
				return yield* FromArray12(schema_, references_, value);
			case "AsyncIterator":
				return yield* FromAsyncIterator7(schema_, references_, value);
			case "BigInt":
				return yield* FromBigInt4(schema_, references_, value);
			case "Boolean":
				return yield* FromBoolean4(schema_, references_, value);
			case "Constructor":
				return yield* FromConstructor7(schema_, references_, value);
			case "Date":
				return yield* FromDate4(schema_, references_, value);
			case "Function":
				return yield* FromFunction7(schema_, references_, value);
			case "Import":
				return yield* FromImport6(schema_, references_, value);
			case "Integer":
				return yield* FromInteger4(schema_, references_, value);
			case "Intersect":
				return yield* FromIntersect14(schema_, references_, value);
			case "Iterator":
				return yield* FromIterator7(schema_, references_, value);
			case "Literal":
				return yield* FromLiteral5(schema_, references_, value);
			case "Never":
				return yield* FromNever4(schema_, references_, value);
			case "Not":
				return yield* FromNot7(schema_, references_, value);
			case "Null":
				return yield* FromNull4(schema_, references_, value);
			case "Number":
				return yield* FromNumber4(schema_, references_, value);
			case "Object":
				return yield* FromObject13(schema_, references_, value);
			case "Promise":
				return yield* FromPromise7(schema_, references_, value);
			case "Record":
				return yield* FromRecord9(schema_, references_, value);
			case "Ref":
				return yield* FromRef10(schema_, references_, value);
			case "RegExp":
				return yield* FromRegExp4(schema_, references_, value);
			case "String":
				return yield* FromString4(schema_, references_, value);
			case "Symbol":
				return yield* FromSymbol4(schema_, references_, value);
			case "TemplateLiteral":
				return yield* FromTemplateLiteral6(schema_, references_, value);
			case "This":
				return yield* FromThis6(schema_, references_, value);
			case "Tuple":
				return yield* FromTuple11(schema_, references_, value);
			case "Undefined":
				return yield* FromUndefined4(schema_, references_, value);
			case "Union":
				return yield* FromUnion16(schema_, references_, value);
			case "Uint8Array":
				return yield* FromUint8Array4(schema_, references_, value);
			case "Unknown":
				return yield* FromUnknown4(schema_, references_, value);
			case "Void":
				return yield* FromVoid4(schema_, references_, value);
			default:
				if (!exports_type2.Has(schema_[Kind]))
					throw new TypeCompilerUnknownTypeError(schema);
				return yield* FromKind3(schema_, references_, value);
		}
	}
	let state = {
		language: "javascript",
		functions: new Map(),
		variables: new Map(),
		instances: new Map(),
	};
	function CreateExpression(schema, references, value, useHoisting = !0) {
		return `(${[...Visit10(schema, references, value, useHoisting)].join(" && ")})`;
	}
	function CreateFunctionName($id) {
		return `check_${Identifier.Encode($id)}`;
	}
	function CreateVariable(expression) {
		let variableName = `local_${state.variables.size}`;
		return (
			state.variables.set(
				variableName,
				`const ${variableName} = ${expression}`,
			),
			variableName
		);
	}
	function CreateFunction(name, schema, references, value, useHoisting = !0) {
		let [newline, pad] = [
				`
`,
				(length) => "".padStart(length, " "),
			],
			parameter = CreateParameter("value", "any"),
			returns = CreateReturns("boolean"),
			expression = [...Visit10(schema, references, value, useHoisting)]
				.map((expression2) => `${pad(4)}${expression2}`)
				.join(` &&${newline}`);
		return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
	}
	function CreateParameter(name, type) {
		let annotation = state.language === "typescript" ? `: ${type}` : "";
		return `${name}${annotation}`;
	}
	function CreateReturns(type) {
		return state.language === "typescript" ? `: ${type}` : "";
	}
	function Build(schema, references, options) {
		let functionCode = CreateFunction("check", schema, references, "value"),
			parameter = CreateParameter("value", "any"),
			returns = CreateReturns("boolean"),
			functions = [...state.functions.values()],
			variables = [...state.variables.values()],
			checkFunction = IsString2(schema.$id)
				? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}`
				: `return ${functionCode}`;
		return [...variables, ...functions, checkFunction].join(`
`);
	}
	function Code(...args) {
		let defaults = { language: "javascript" },
			[schema, references, options] =
				args.length === 2 && IsArray2(args[1])
					? [args[0], args[1], defaults]
					: args.length === 2 && !IsArray2(args[1])
						? [args[0], [], args[1]]
						: args.length === 3
							? [args[0], args[1], args[2]]
							: args.length === 1
								? [args[0], [], defaults]
								: [null, [], defaults];
		if (
			((state.language = options.language),
			state.variables.clear(),
			state.functions.clear(),
			state.instances.clear(),
			!IsSchema2(schema))
		)
			throw new TypeCompilerTypeGuardError(schema);
		for (let schema2 of references)
			if (!IsSchema2(schema2)) throw new TypeCompilerTypeGuardError(schema2);
		return Build(schema, references, options);
	}
	TypeCompiler2.Code = Code;
	function Compile(schema, references = []) {
		let generatedCode = Code(schema, references, { language: "javascript" }),
			compiledFunction = globalThis.Function(
				"kind",
				"format",
				"hash",
				generatedCode,
			),
			instances = new Map(state.instances);
		function typeRegistryFunction(kind, instance, value) {
			if (!exports_type2.Has(kind) || !instances.has(instance)) return !1;
			let checkFunc = exports_type2.Get(kind),
				schema2 = instances.get(instance);
			return checkFunc(schema2, value);
		}
		function formatRegistryFunction(format, value) {
			if (!exports_format.Has(format)) return !1;
			return exports_format.Get(format)(value);
		}
		function hashFunction(value) {
			return Hash(value);
		}
		let checkFunction = compiledFunction(
			typeRegistryFunction,
			formatRegistryFunction,
			hashFunction,
		);
		return new TypeCheck(schema, references, checkFunction, generatedCode);
	}
	TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
var __classPrivateFieldSet = function (receiver, state, value, kind, f) {
		if (kind === "m") throw new TypeError("Private method is not writable");
		if (kind === "a" && !f)
			throw new TypeError("Private accessor was defined without a setter");
		if (
			typeof state === "function"
				? receiver !== state || !f
				: !state.has(receiver)
		)
			throw new TypeError(
				"Cannot write private member to an object whose class did not declare it",
			);
		return (
			kind === "a"
				? f.call(receiver, value)
				: f
					? (f.value = value)
					: state.set(receiver, value),
			value
		);
	},
	__classPrivateFieldGet = function (receiver, state, kind, f) {
		if (kind === "a" && !f)
			throw new TypeError("Private accessor was defined without a getter");
		if (
			typeof state === "function"
				? receiver !== state || !f
				: !state.has(receiver)
		)
			throw new TypeError(
				"Cannot read private member from an object whose class did not declare it",
			);
		return kind === "m"
			? f
			: kind === "a"
				? f.call(receiver)
				: f
					? f.value
					: state.get(receiver);
	},
	_AssertError_instances,
	_AssertError_iterator,
	_AssertError_Iterator;
class AssertError extends TypeBoxError {
	constructor(iterator) {
		let error = iterator.First();
		super(error === void 0 ? "Invalid Value" : error.message);
		_AssertError_instances.add(this),
			_AssertError_iterator.set(this, void 0),
			__classPrivateFieldSet(this, _AssertError_iterator, iterator, "f"),
			(this.error = error);
	}
	Errors() {
		return new ValueErrorIterator(
			__classPrivateFieldGet(
				this,
				_AssertError_instances,
				"m",
				_AssertError_Iterator,
			).call(this),
		);
	}
}
(_AssertError_iterator = new WeakMap()),
	(_AssertError_instances = new WeakSet()),
	(_AssertError_Iterator = function* _AssertError_Iterator2() {
		if (this.error) yield this.error;
		yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
	});
function AssertValue(schema, references, value) {
	if (Check(schema, references, value)) return;
	throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
	return args.length === 3
		? AssertValue(args[0], args[1], args[2])
		: AssertValue(args[0], [], args[1]);
}
function FromObject13(value) {
	let Acc = {};
	for (let key of Object.getOwnPropertyNames(value))
		Acc[key] = Clone2(value[key]);
	for (let key of Object.getOwnPropertySymbols(value))
		Acc[key] = Clone2(value[key]);
	return Acc;
}
function FromArray12(value) {
	return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
	return value.slice();
}
function FromMap(value) {
	return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
	return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
	return new Date(value.toISOString());
}
function FromValue2(value) {
	return value;
}
function Clone2(value) {
	if (IsArray2(value)) return FromArray12(value);
	if (IsDate2(value)) return FromDate4(value);
	if (IsTypedArray(value)) return FromTypedArray(value);
	if (IsMap(value)) return FromMap(value);
	if (IsSet(value)) return FromSet(value);
	if (IsObject2(value)) return FromObject13(value);
	if (IsValueType(value)) return FromValue2(value);
	throw new Error("ValueClone: Unable to clone value");
}
class ValueCreateError extends TypeBoxError {
	constructor(schema, message) {
		super(message);
		this.schema = schema;
	}
}
function FromDefault(value) {
	return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return {};
}
function FromArgument4(schema, references) {
	return {};
}
function FromArray13(schema, references) {
	if (schema.uniqueItems === !0 && !HasPropertyKey2(schema, "default"))
		throw new ValueCreateError(
			schema,
			"Array with the uniqueItems constraint requires a default value",
		);
	else if ("contains" in schema && !HasPropertyKey2(schema, "default"))
		throw new ValueCreateError(
			schema,
			"Array with the contains constraint requires a default value",
		);
	else if ("default" in schema) return FromDefault(schema.default);
	else if (schema.minItems !== void 0)
		return Array.from({ length: schema.minItems }).map((item) => {
			return Visit10(schema.items, references);
		});
	else return [];
}
function FromAsyncIterator7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return (async function* () {})();
}
function FromBigInt4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return BigInt(0);
}
function FromBoolean4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return !1;
}
function FromConstructor7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else {
		let value = Visit10(schema.returns, references);
		if (typeof value === "object" && !Array.isArray(value))
			return class {
				constructor() {
					for (let [key, val] of Object.entries(value)) {
						let self = this;
						self[key] = val;
					}
				}
			};
		else return class {};
	}
}
function FromDate5(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (schema.minimumTimestamp !== void 0)
		return new Date(schema.minimumTimestamp);
	else return new Date();
}
function FromFunction7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return () => Visit10(schema.returns, references);
}
function FromImport6(schema, references) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit10(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (schema.minimum !== void 0) return schema.minimum;
	else return 0;
}
function FromIntersect14(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else {
		let value = schema.allOf.reduce((acc, schema2) => {
			let next = Visit10(schema2, references);
			return typeof next === "object" ? { ...acc, ...next } : next;
		}, {});
		if (!Check(schema, references, value))
			throw new ValueCreateError(
				schema,
				"Intersect produced invalid value. Consider using a default value.",
			);
		return value;
	}
}
function FromIterator7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return (function* () {})();
}
function FromLiteral5(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return schema.const;
}
function FromNever4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else
		throw new ValueCreateError(
			schema,
			"Never types cannot be created. Consider using a default value.",
		);
}
function FromNot7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else
		throw new ValueCreateError(schema, "Not types must have a default value");
}
function FromNull4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return null;
}
function FromNumber4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (schema.minimum !== void 0) return schema.minimum;
	else return 0;
}
function FromObject14(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else {
		let required = new Set(schema.required),
			Acc = {};
		for (let [key, subschema] of Object.entries(schema.properties)) {
			if (!required.has(key)) continue;
			Acc[key] = Visit10(subschema, references);
		}
		return Acc;
	}
}
function FromPromise7(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return Promise.resolve(Visit10(schema.item, references));
}
function FromRecord9(schema, references) {
	let [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (
		!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)
	) {
		let propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|"),
			Acc = {};
		for (let key of propertyKeys) Acc[key] = Visit10(valueSchema, references);
		return Acc;
	} else return {};
}
function FromRef10(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return Visit10(Deref(schema, references), references);
}
function FromRegExp4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else
		throw new ValueCreateError(
			schema,
			"RegExp types cannot be created. Consider using a default value.",
		);
}
function FromString4(schema, references) {
	if (schema.pattern !== void 0)
		if (!HasPropertyKey2(schema, "default"))
			throw new ValueCreateError(
				schema,
				"String types with patterns must specify a default value",
			);
		else return FromDefault(schema.default);
	else if (schema.format !== void 0)
		if (!HasPropertyKey2(schema, "default"))
			throw new ValueCreateError(
				schema,
				"String types with formats must specify a default value",
			);
		else return FromDefault(schema.default);
	else if (HasPropertyKey2(schema, "default"))
		return FromDefault(schema.default);
	else if (schema.minLength !== void 0)
		return Array.from({ length: schema.minLength })
			.map(() => " ")
			.join("");
	else return "";
}
function FromSymbol4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if ("value" in schema) return Symbol.for(schema.value);
	else return Symbol();
}
function FromTemplateLiteral6(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	if (!IsTemplateLiteralFinite(schema))
		throw new ValueCreateError(
			schema,
			"Can only create template literals that produce a finite variants. Consider using a default value.",
		);
	return TemplateLiteralGenerate(schema)[0];
}
function FromThis6(schema, references) {
	if (recursiveDepth++ > recursiveMaxDepth)
		throw new ValueCreateError(
			schema,
			"Cannot create recursive type as it appears possibly infinite. Consider using a default.",
		);
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return Visit10(Deref(schema, references), references);
}
function FromTuple11(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	if (schema.items === void 0) return [];
	else
		return Array.from({ length: schema.minItems }).map((_, index) =>
			Visit10(schema.items[index], references),
		);
}
function FromUndefined4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return;
}
function FromUnion16(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (schema.anyOf.length === 0)
		throw new Error(
			"ValueCreate.Union: Cannot create Union with zero variants",
		);
	else return Visit10(schema.anyOf[0], references);
}
function FromUint8Array4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else if (schema.minByteLength !== void 0)
		return new Uint8Array(schema.minByteLength);
	else return new Uint8Array(0);
}
function FromUnknown4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return {};
}
function FromVoid4(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else return;
}
function FromKind3(schema, references) {
	if (HasPropertyKey2(schema, "default")) return FromDefault(schema.default);
	else throw new Error("User defined types must specify a default value");
}
function Visit10(schema, references) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return FromAny4(schema_, references_);
		case "Argument":
			return FromArgument4(schema_, references_);
		case "Array":
			return FromArray13(schema_, references_);
		case "AsyncIterator":
			return FromAsyncIterator7(schema_, references_);
		case "BigInt":
			return FromBigInt4(schema_, references_);
		case "Boolean":
			return FromBoolean4(schema_, references_);
		case "Constructor":
			return FromConstructor7(schema_, references_);
		case "Date":
			return FromDate5(schema_, references_);
		case "Function":
			return FromFunction7(schema_, references_);
		case "Import":
			return FromImport6(schema_, references_);
		case "Integer":
			return FromInteger4(schema_, references_);
		case "Intersect":
			return FromIntersect14(schema_, references_);
		case "Iterator":
			return FromIterator7(schema_, references_);
		case "Literal":
			return FromLiteral5(schema_, references_);
		case "Never":
			return FromNever4(schema_, references_);
		case "Not":
			return FromNot7(schema_, references_);
		case "Null":
			return FromNull4(schema_, references_);
		case "Number":
			return FromNumber4(schema_, references_);
		case "Object":
			return FromObject14(schema_, references_);
		case "Promise":
			return FromPromise7(schema_, references_);
		case "Record":
			return FromRecord9(schema_, references_);
		case "Ref":
			return FromRef10(schema_, references_);
		case "RegExp":
			return FromRegExp4(schema_, references_);
		case "String":
			return FromString4(schema_, references_);
		case "Symbol":
			return FromSymbol4(schema_, references_);
		case "TemplateLiteral":
			return FromTemplateLiteral6(schema_, references_);
		case "This":
			return FromThis6(schema_, references_);
		case "Tuple":
			return FromTuple11(schema_, references_);
		case "Undefined":
			return FromUndefined4(schema_, references_);
		case "Union":
			return FromUnion16(schema_, references_);
		case "Uint8Array":
			return FromUint8Array4(schema_, references_);
		case "Unknown":
			return FromUnknown4(schema_, references_);
		case "Void":
			return FromVoid4(schema_, references_);
		default:
			if (!exports_type2.Has(schema_[Kind]))
				throw new ValueCreateError(schema_, "Unknown type");
			return FromKind3(schema_, references_);
	}
}
var recursiveMaxDepth = 512,
	recursiveDepth = 0;
function Create2(...args) {
	return (
		(recursiveDepth = 0),
		args.length === 2 ? Visit10(args[0], args[1]) : Visit10(args[0], [])
	);
}
class ValueCastError extends TypeBoxError {
	constructor(schema, message) {
		super(message);
		this.schema = schema;
	}
}
function ScoreUnion(schema, references, value) {
	if (
		schema[Kind] === "Object" &&
		typeof value === "object" &&
		!IsNull2(value)
	) {
		let object = schema,
			keys = Object.getOwnPropertyNames(value),
			entries = Object.entries(object.properties),
			[point, max] = [1 / entries.length, entries.length];
		return entries.reduce((acc, [key, schema2]) => {
			let literal =
					schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0,
				checks = Check(schema2, references, value[key]) ? point : 0,
				exists = keys.includes(key) ? point : 0;
			return acc + (literal + checks + exists);
		}, 0);
	} else return Check(schema, references, value) ? 1 : 0;
}
function SelectUnion(union, references, value) {
	let schemas = union.anyOf.map((schema) => Deref(schema, references)),
		[select, best] = [schemas[0], 0];
	for (let schema of schemas) {
		let score = ScoreUnion(schema, references, value);
		if (score > best) (select = schema), (best = score);
	}
	return select;
}
function CastUnion(union, references, value) {
	if ("default" in union)
		return typeof value === "function" ? union.default : Clone2(union.default);
	else {
		let schema = SelectUnion(union, references, value);
		return Cast(schema, references, value);
	}
}
function DefaultClone(schema, references, value) {
	return Check(schema, references, value)
		? Clone2(value)
		: Create2(schema, references);
}
function Default3(schema, references, value) {
	return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray14(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	let created = IsArray2(value) ? Clone2(value) : Create2(schema, references),
		minimum =
			IsNumber2(schema.minItems) && created.length < schema.minItems
				? [
						...created,
						...Array.from(
							{ length: schema.minItems - created.length },
							() => null,
						),
					]
				: created,
		casted = (
			IsNumber2(schema.maxItems) && minimum.length > schema.maxItems
				? minimum.slice(0, schema.maxItems)
				: minimum
		).map((value2) => Visit11(schema.items, references, value2));
	if (schema.uniqueItems !== !0) return casted;
	let unique = [...new Set(casted)];
	if (!Check(schema, references, unique))
		throw new ValueCastError(
			schema,
			"Array cast produced invalid data due to uniqueItems constraint",
		);
	return unique;
}
function FromConstructor8(schema, references, value) {
	if (Check(schema, references, value)) return Create2(schema, references);
	let required = new Set(schema.returns.required || []),
		result = function () {};
	for (let [key, property] of Object.entries(schema.returns.properties)) {
		if (!required.has(key) && value.prototype[key] === void 0) continue;
		result.prototype[key] = Visit11(property, references, value.prototype[key]);
	}
	return result;
}
function FromImport7(schema, references, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit11(target, [...references, ...definitions], value);
}
function FromIntersect15(schema, references, value) {
	let created = Create2(schema, references),
		mapped =
			IsObject2(created) && IsObject2(value) ? { ...created, ...value } : value;
	return Check(schema, references, mapped)
		? mapped
		: Create2(schema, references);
}
function FromNever5(schema, references, value) {
	throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject15(schema, references, value) {
	if (Check(schema, references, value)) return value;
	if (value === null || typeof value !== "object")
		return Create2(schema, references);
	let required = new Set(schema.required || []),
		result = {};
	for (let [key, property] of Object.entries(schema.properties)) {
		if (!required.has(key) && value[key] === void 0) continue;
		result[key] = Visit11(property, references, value[key]);
	}
	if (typeof schema.additionalProperties === "object") {
		let propertyNames = Object.getOwnPropertyNames(schema.properties);
		for (let propertyName of Object.getOwnPropertyNames(value)) {
			if (propertyNames.includes(propertyName)) continue;
			result[propertyName] = Visit11(
				schema.additionalProperties,
				references,
				value[propertyName],
			);
		}
	}
	return result;
}
function FromRecord10(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	if (
		value === null ||
		typeof value !== "object" ||
		Array.isArray(value) ||
		value instanceof Date
	)
		return Create2(schema, references);
	let subschemaPropertyName = Object.getOwnPropertyNames(
			schema.patternProperties,
		)[0],
		subschema = schema.patternProperties[subschemaPropertyName],
		result = {};
	for (let [propKey, propValue] of Object.entries(value))
		result[propKey] = Visit11(subschema, references, propValue);
	return result;
}
function FromRef11(schema, references, value) {
	return Visit11(Deref(schema, references), references, value);
}
function FromThis7(schema, references, value) {
	return Visit11(Deref(schema, references), references, value);
}
function FromTuple12(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	if (!IsArray2(value)) return Create2(schema, references);
	if (schema.items === void 0) return [];
	return schema.items.map((schema2, index) =>
		Visit11(schema2, references, value[index]),
	);
}
function FromUnion17(schema, references, value) {
	return Check(schema, references, value)
		? Clone2(value)
		: CastUnion(schema, references, value);
}
function Visit11(schema, references, value) {
	let references_ = IsString2(schema.$id)
			? Pushref(schema, references)
			: references,
		schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray14(schema_, references_, value);
		case "Constructor":
			return FromConstructor8(schema_, references_, value);
		case "Import":
			return FromImport7(schema_, references_, value);
		case "Intersect":
			return FromIntersect15(schema_, references_, value);
		case "Never":
			return FromNever5(schema_, references_, value);
		case "Object":
			return FromObject15(schema_, references_, value);
		case "Record":
			return FromRecord10(schema_, references_, value);
		case "Ref":
			return FromRef11(schema_, references_, value);
		case "This":
			return FromThis7(schema_, references_, value);
		case "Tuple":
			return FromTuple12(schema_, references_, value);
		case "Union":
			return FromUnion17(schema_, references_, value);
		case "Date":
		case "Symbol":
		case "Uint8Array":
			return DefaultClone(schema, references, value);
		default:
			return Default3(schema_, references_, value);
	}
}
function Cast(...args) {
	return args.length === 3
		? Visit11(args[0], args[1], args[2])
		: Visit11(args[0], [], args[1]);
}
function IsCheckable(schema) {
	return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray15(schema, references, value) {
	if (!IsArray2(value)) return value;
	return value.map((value2) => Visit12(schema.items, references, value2));
}
function FromImport8(schema, references, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit12(target, [...references, ...definitions], value);
}
function FromIntersect16(schema, references, value) {
	let unevaluatedProperties = schema.unevaluatedProperties,
		composite = schema.allOf
			.map((schema2) => Visit12(schema2, references, Clone2(value)))
			.reduce(
				(acc, value2) => (IsObject2(value2) ? { ...acc, ...value2 } : value2),
				{},
			);
	if (
		!IsObject2(value) ||
		!IsObject2(composite) ||
		!IsKind(unevaluatedProperties)
	)
		return composite;
	let knownkeys = KeyOfPropertyKeys(schema);
	for (let key of Object.getOwnPropertyNames(value)) {
		if (knownkeys.includes(key)) continue;
		if (Check(unevaluatedProperties, references, value[key]))
			composite[key] = Visit12(unevaluatedProperties, references, value[key]);
	}
	return composite;
}
function FromObject16(schema, references, value) {
	if (!IsObject2(value) || IsArray2(value)) return value;
	let additionalProperties = schema.additionalProperties;
	for (let key of Object.getOwnPropertyNames(value)) {
		if (HasPropertyKey2(schema.properties, key)) {
			value[key] = Visit12(schema.properties[key], references, value[key]);
			continue;
		}
		if (
			IsKind(additionalProperties) &&
			Check(additionalProperties, references, value[key])
		) {
			value[key] = Visit12(additionalProperties, references, value[key]);
			continue;
		}
		delete value[key];
	}
	return value;
}
function FromRecord11(schema, references, value) {
	if (!IsObject2(value)) return value;
	let additionalProperties = schema.additionalProperties,
		propertyKeys = Object.getOwnPropertyNames(value),
		[propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0],
		propertyKeyTest = new RegExp(propertyKey);
	for (let key of propertyKeys) {
		if (propertyKeyTest.test(key)) {
			value[key] = Visit12(propertySchema, references, value[key]);
			continue;
		}
		if (
			IsKind(additionalProperties) &&
			Check(additionalProperties, references, value[key])
		) {
			value[key] = Visit12(additionalProperties, references, value[key]);
			continue;
		}
		delete value[key];
	}
	return value;
}
function FromRef12(schema, references, value) {
	return Visit12(Deref(schema, references), references, value);
}
function FromThis8(schema, references, value) {
	return Visit12(Deref(schema, references), references, value);
}
function FromTuple13(schema, references, value) {
	if (!IsArray2(value)) return value;
	if (IsUndefined2(schema.items)) return [];
	let length = Math.min(value.length, schema.items.length);
	for (let i = 0; i < length; i++)
		value[i] = Visit12(schema.items[i], references, value[i]);
	return value.length > length ? value.slice(0, length) : value;
}
function FromUnion18(schema, references, value) {
	for (let inner of schema.anyOf)
		if (IsCheckable(inner) && Check(inner, references, value))
			return Visit12(inner, references, value);
	return value;
}
function Visit12(schema, references, value) {
	let references_ = IsString2(schema.$id)
			? Pushref(schema, references)
			: references,
		schema_ = schema;
	switch (schema_[Kind]) {
		case "Array":
			return FromArray15(schema_, references_, value);
		case "Import":
			return FromImport8(schema_, references_, value);
		case "Intersect":
			return FromIntersect16(schema_, references_, value);
		case "Object":
			return FromObject16(schema_, references_, value);
		case "Record":
			return FromRecord11(schema_, references_, value);
		case "Ref":
			return FromRef12(schema_, references_, value);
		case "This":
			return FromThis8(schema_, references_, value);
		case "Tuple":
			return FromTuple13(schema_, references_, value);
		case "Union":
			return FromUnion18(schema_, references_, value);
		default:
			return value;
	}
}
function Clean(...args) {
	return args.length === 3
		? Visit12(args[0], args[1], args[2])
		: Visit12(args[0], [], args[1]);
}
function IsStringNumeric(value) {
	return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
	return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
	return (
		value === !0 ||
		(IsNumber2(value) && value === 1) ||
		(IsBigInt2(value) && value === BigInt("1")) ||
		(IsString2(value) && (value.toLowerCase() === "true" || value === "1"))
	);
}
function IsValueFalse(value) {
	return (
		value === !1 ||
		(IsNumber2(value) && (value === 0 || Object.is(value, -0))) ||
		(IsBigInt2(value) && value === BigInt("0")) ||
		(IsString2(value) &&
			(value.toLowerCase() === "false" || value === "0" || value === "-0"))
	);
}
function IsTimeStringWithTimeZone(value) {
	return (
		IsString2(value) &&
		/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
			value,
		)
	);
}
function IsTimeStringWithoutTimeZone(value) {
	return (
		IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value)
	);
}
function IsDateTimeStringWithTimeZone(value) {
	return (
		IsString2(value) &&
		/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
			value,
		)
	);
}
function IsDateTimeStringWithoutTimeZone(value) {
	return (
		IsString2(value) &&
		/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(
			value,
		)
	);
}
function IsDateString(value) {
	return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
	let conversion = TryConvertString(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
	let conversion = TryConvertNumber(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
	let conversion = TryConvertBoolean(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
	return IsString2(schema.const)
		? TryConvertLiteralString(value, schema.const)
		: IsNumber2(schema.const)
			? TryConvertLiteralNumber(value, schema.const)
			: IsBoolean2(schema.const)
				? TryConvertLiteralBoolean(value, schema.const)
				: value;
}
function TryConvertBoolean(value) {
	return IsValueTrue(value) ? !0 : IsValueFalse(value) ? !1 : value;
}
function TryConvertBigInt(value) {
	let truncateInteger = (value2) => value2.split(".")[0];
	return IsStringNumeric(value)
		? BigInt(truncateInteger(value))
		: IsNumber2(value)
			? BigInt(Math.trunc(value))
			: IsValueFalse(value)
				? BigInt(0)
				: IsValueTrue(value)
					? BigInt(1)
					: value;
}
function TryConvertString(value) {
	return IsSymbol2(value) && value.description !== void 0
		? value.description.toString()
		: IsValueToString(value)
			? value.toString()
			: value;
}
function TryConvertNumber(value) {
	return IsStringNumeric(value)
		? parseFloat(value)
		: IsValueTrue(value)
			? 1
			: IsValueFalse(value)
				? 0
				: value;
}
function TryConvertInteger(value) {
	return IsStringNumeric(value)
		? parseInt(value)
		: IsNumber2(value)
			? Math.trunc(value)
			: IsValueTrue(value)
				? 1
				: IsValueFalse(value)
					? 0
					: value;
}
function TryConvertNull(value) {
	return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
	return IsString2(value) && value === "undefined" ? void 0 : value;
}
function TryConvertDate(value) {
	return IsDate2(value)
		? value
		: IsNumber2(value)
			? new Date(value)
			: IsValueTrue(value)
				? new Date(1)
				: IsValueFalse(value)
					? new Date(0)
					: IsStringNumeric(value)
						? new Date(parseInt(value))
						: IsTimeStringWithoutTimeZone(value)
							? new Date(`1970-01-01T${value}.000Z`)
							: IsTimeStringWithTimeZone(value)
								? new Date(`1970-01-01T${value}`)
								: IsDateTimeStringWithoutTimeZone(value)
									? new Date(`${value}.000Z`)
									: IsDateTimeStringWithTimeZone(value)
										? new Date(value)
										: IsDateString(value)
											? new Date(`${value}T00:00:00.000Z`)
											: value;
}
function Default4(value) {
	return value;
}
function FromArray16(schema, references, value) {
	return (IsArray2(value) ? value : [value]).map((element) =>
		Visit13(schema.items, references, element),
	);
}
function FromBigInt5(schema, references, value) {
	return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
	return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
	return TryConvertDate(value);
}
function FromImport9(schema, references, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit13(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
	return TryConvertInteger(value);
}
function FromIntersect17(schema, references, value) {
	return schema.allOf.reduce(
		(value2, schema2) => Visit13(schema2, references, value2),
		value,
	);
}
function FromLiteral6(schema, references, value) {
	return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
	return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
	return TryConvertNumber(value);
}
function FromObject17(schema, references, value) {
	if (!IsObject2(value)) return value;
	for (let propertyKey of Object.getOwnPropertyNames(schema.properties)) {
		if (!HasPropertyKey2(value, propertyKey)) continue;
		value[propertyKey] = Visit13(
			schema.properties[propertyKey],
			references,
			value[propertyKey],
		);
	}
	return value;
}
function FromRecord12(schema, references, value) {
	if (!IsObject2(value)) return value;
	let propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0],
		property = schema.patternProperties[propertyKey];
	for (let [propKey, propValue] of Object.entries(value))
		value[propKey] = Visit13(property, references, propValue);
	return value;
}
function FromRef13(schema, references, value) {
	return Visit13(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
	return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
	return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis9(schema, references, value) {
	return Visit13(Deref(schema, references), references, value);
}
function FromTuple14(schema, references, value) {
	if (!(IsArray2(value) && !IsUndefined2(schema.items))) return value;
	return value.map((value2, index) => {
		return index < schema.items.length
			? Visit13(schema.items[index], references, value2)
			: value2;
	});
}
function FromUndefined5(schema, references, value) {
	return TryConvertUndefined(value);
}
function FromUnion19(schema, references, value) {
	for (let subschema of schema.anyOf) {
		let converted = Visit13(subschema, references, Clone2(value));
		if (!Check(subschema, references, converted)) continue;
		return converted;
	}
	return value;
}
function Visit13(schema, references, value) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray16(schema_, references_, value);
		case "BigInt":
			return FromBigInt5(schema_, references_, value);
		case "Boolean":
			return FromBoolean5(schema_, references_, value);
		case "Date":
			return FromDate6(schema_, references_, value);
		case "Import":
			return FromImport9(schema_, references_, value);
		case "Integer":
			return FromInteger5(schema_, references_, value);
		case "Intersect":
			return FromIntersect17(schema_, references_, value);
		case "Literal":
			return FromLiteral6(schema_, references_, value);
		case "Null":
			return FromNull5(schema_, references_, value);
		case "Number":
			return FromNumber5(schema_, references_, value);
		case "Object":
			return FromObject17(schema_, references_, value);
		case "Record":
			return FromRecord12(schema_, references_, value);
		case "Ref":
			return FromRef13(schema_, references_, value);
		case "String":
			return FromString5(schema_, references_, value);
		case "Symbol":
			return FromSymbol5(schema_, references_, value);
		case "This":
			return FromThis9(schema_, references_, value);
		case "Tuple":
			return FromTuple14(schema_, references_, value);
		case "Undefined":
			return FromUndefined5(schema_, references_, value);
		case "Union":
			return FromUnion19(schema_, references_, value);
		default:
			return Default4(value);
	}
}
function Convert(...args) {
	return args.length === 3
		? Visit13(args[0], args[1], args[2])
		: Visit13(args[0], [], args[1]);
}
function Decode(...args) {
	let [schema, references, value] =
		args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
	if (!Check(schema, references, value))
		throw new TransformDecodeCheckError(
			schema,
			value,
			Errors(schema, references, value).First(),
		);
	return HasTransform(schema, references)
		? TransformDecode(schema, references, value)
		: value;
}
function ValueOrDefault(schema, value) {
	let defaultValue = HasPropertyKey2(schema, "default")
			? schema.default
			: void 0,
		clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
	return IsUndefined2(value)
		? clone
		: IsObject2(value) && IsObject2(clone)
			? Object.assign(clone, value)
			: value;
}
function HasDefaultProperty(schema) {
	return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
	if (IsArray2(value)) {
		for (let i = 0; i < value.length; i++)
			value[i] = Visit14(schema.items, references, value[i]);
		return value;
	}
	let defaulted = ValueOrDefault(schema, value);
	if (!IsArray2(defaulted)) return defaulted;
	for (let i = 0; i < defaulted.length; i++)
		defaulted[i] = Visit14(schema.items, references, defaulted[i]);
	return defaulted;
}
function FromDate7(schema, references, value) {
	return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
	let definitions = globalThis.Object.values(schema.$defs),
		target = schema.$defs[schema.$ref];
	return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
	let defaulted = ValueOrDefault(schema, value);
	return schema.allOf.reduce((acc, schema2) => {
		let next = Visit14(schema2, references, defaulted);
		return IsObject2(next) ? { ...acc, ...next } : next;
	}, {});
}
function FromObject18(schema, references, value) {
	let defaulted = ValueOrDefault(schema, value);
	if (!IsObject2(defaulted)) return defaulted;
	let knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
	for (let key of knownPropertyKeys) {
		let propertyValue = Visit14(
			schema.properties[key],
			references,
			defaulted[key],
		);
		if (IsUndefined2(propertyValue)) continue;
		defaulted[key] = Visit14(
			schema.properties[key],
			references,
			defaulted[key],
		);
	}
	if (!HasDefaultProperty(schema.additionalProperties)) return defaulted;
	for (let key of Object.getOwnPropertyNames(defaulted)) {
		if (knownPropertyKeys.includes(key)) continue;
		defaulted[key] = Visit14(
			schema.additionalProperties,
			references,
			defaulted[key],
		);
	}
	return defaulted;
}
function FromRecord13(schema, references, value) {
	let defaulted = ValueOrDefault(schema, value);
	if (!IsObject2(defaulted)) return defaulted;
	let additionalPropertiesSchema = schema.additionalProperties,
		[propertyKeyPattern, propertySchema] = Object.entries(
			schema.patternProperties,
		)[0],
		knownPropertyKey = new RegExp(propertyKeyPattern);
	for (let key of Object.getOwnPropertyNames(defaulted)) {
		if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
			continue;
		defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
	}
	if (!HasDefaultProperty(additionalPropertiesSchema)) return defaulted;
	for (let key of Object.getOwnPropertyNames(defaulted)) {
		if (knownPropertyKey.test(key)) continue;
		defaulted[key] = Visit14(
			additionalPropertiesSchema,
			references,
			defaulted[key],
		);
	}
	return defaulted;
}
function FromRef14(schema, references, value) {
	return Visit14(
		Deref(schema, references),
		references,
		ValueOrDefault(schema, value),
	);
}
function FromThis10(schema, references, value) {
	return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
	let defaulted = ValueOrDefault(schema, value);
	if (!IsArray2(defaulted) || IsUndefined2(schema.items)) return defaulted;
	let [items, max] = [
		schema.items,
		Math.max(schema.items.length, defaulted.length),
	];
	for (let i = 0; i < max; i++)
		if (i < items.length)
			defaulted[i] = Visit14(items[i], references, defaulted[i]);
	return defaulted;
}
function FromUnion20(schema, references, value) {
	let defaulted = ValueOrDefault(schema, value);
	for (let inner of schema.anyOf) {
		let result = Visit14(inner, references, Clone2(defaulted));
		if (Check(inner, references, result)) return result;
	}
	return defaulted;
}
function Visit14(schema, references, value) {
	let references_ = Pushref(schema, references),
		schema_ = schema;
	switch (schema_[Kind]) {
		case "Array":
			return FromArray17(schema_, references_, value);
		case "Date":
			return FromDate7(schema_, references_, value);
		case "Import":
			return FromImport10(schema_, references_, value);
		case "Intersect":
			return FromIntersect18(schema_, references_, value);
		case "Object":
			return FromObject18(schema_, references_, value);
		case "Record":
			return FromRecord13(schema_, references_, value);
		case "Ref":
			return FromRef14(schema_, references_, value);
		case "This":
			return FromThis10(schema_, references_, value);
		case "Tuple":
			return FromTuple15(schema_, references_, value);
		case "Union":
			return FromUnion20(schema_, references_, value);
		default:
			return ValueOrDefault(schema_, value);
	}
}
function Default5(...args) {
	return args.length === 3
		? Visit14(args[0], args[1], args[2])
		: Visit14(args[0], [], args[1]);
}
var exports_pointer = {};
__export(exports_pointer, {
	ValuePointerRootSetError: () => ValuePointerRootSetError,
	ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
	Set: () => Set4,
	Has: () => Has3,
	Get: () => Get3,
	Format: () => Format,
	Delete: () => Delete3,
});
class ValuePointerRootSetError extends TypeBoxError {
	constructor(value, path, update) {
		super("Cannot set root value");
		(this.value = value), (this.path = path), (this.update = update);
	}
}
class ValuePointerRootDeleteError extends TypeBoxError {
	constructor(value, path) {
		super("Cannot delete root value");
		(this.value = value), (this.path = path);
	}
}
function Escape2(component) {
	return component.indexOf("~") === -1
		? component
		: component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
	if (pointer === "") return;
	let [start, end] = [0, 0];
	for (let i = 0; i < pointer.length; i++)
		if (pointer.charAt(i) === "/")
			if (i === 0) start = i + 1;
			else (end = i), yield Escape2(pointer.slice(start, end)), (start = i + 1);
		else end = i;
	yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
	if (pointer === "")
		throw new ValuePointerRootSetError(value, pointer, update);
	let [owner, next, key] = [null, value, ""];
	for (let component of Format(pointer)) {
		if (next[component] === void 0) next[component] = {};
		(owner = next), (next = next[component]), (key = component);
	}
	owner[key] = update;
}
function Delete3(value, pointer) {
	if (pointer === "") throw new ValuePointerRootDeleteError(value, pointer);
	let [owner, next, key] = [null, value, ""];
	for (let component of Format(pointer)) {
		if (next[component] === void 0 || next[component] === null) return;
		(owner = next), (next = next[component]), (key = component);
	}
	if (Array.isArray(owner)) {
		let index = parseInt(key);
		owner.splice(index, 1);
	} else delete owner[key];
}
function Has3(value, pointer) {
	if (pointer === "") return !0;
	let [owner, next, key] = [null, value, ""];
	for (let component of Format(pointer)) {
		if (next[component] === void 0) return !1;
		(owner = next), (next = next[component]), (key = component);
	}
	return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
	if (pointer === "") return value;
	let current = value;
	for (let component of Format(pointer)) {
		if (current[component] === void 0) return;
		current = current[component];
	}
	return current;
}
function ObjectType3(left, right) {
	if (!IsObject2(right)) return !1;
	let leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)],
		rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
	if (leftKeys.length !== rightKeys.length) return !1;
	return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
	return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
	if (!IsArray2(right) || left.length !== right.length) return !1;
	return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
	if (
		!IsTypedArray(right) ||
		left.length !== right.length ||
		Object.getPrototypeOf(left).constructor.name !==
			Object.getPrototypeOf(right).constructor.name
	)
		return !1;
	return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
	return left === right;
}
function Equal(left, right) {
	if (IsDate2(left)) return DateType3(left, right);
	if (IsTypedArray(left)) return TypedArrayType(left, right);
	if (IsArray2(left)) return ArrayType3(left, right);
	if (IsObject2(left)) return ObjectType3(left, right);
	if (IsValueType(left)) return ValueType(left, right);
	throw new Error("ValueEquals: Unable to compare value");
}
var Insert = Object2({
		type: Literal("insert"),
		path: String2(),
		value: Unknown(),
	}),
	Update = Object2({
		type: Literal("update"),
		path: String2(),
		value: Unknown(),
	}),
	Delete4 = Object2({ type: Literal("delete"), path: String2() }),
	Edit = Union([Insert, Update, Delete4]);
class ValueDiffError extends TypeBoxError {
	constructor(value, message) {
		super(message);
		this.value = value;
	}
}
function CreateUpdate(path, value) {
	return { type: "update", path, value };
}
function CreateInsert(path, value) {
	return { type: "insert", path, value };
}
function CreateDelete(path) {
	return { type: "delete", path };
}
function AssertDiffable(value) {
	if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
		throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
	if ((AssertDiffable(current), AssertDiffable(next), !IsStandardObject(next)))
		return yield CreateUpdate(path, next);
	let currentKeys = globalThis.Object.getOwnPropertyNames(current),
		nextKeys = globalThis.Object.getOwnPropertyNames(next);
	for (let key of nextKeys) {
		if (HasPropertyKey2(current, key)) continue;
		yield CreateInsert(`${path}/${key}`, next[key]);
	}
	for (let key of currentKeys) {
		if (!HasPropertyKey2(next, key)) continue;
		if (Equal(current, next)) continue;
		yield* Visit15(`${path}/${key}`, current[key], next[key]);
	}
	for (let key of currentKeys) {
		if (HasPropertyKey2(next, key)) continue;
		yield CreateDelete(`${path}/${key}`);
	}
}
function* ArrayType4(path, current, next) {
	if (!IsArray2(next)) return yield CreateUpdate(path, next);
	for (let i = 0; i < Math.min(current.length, next.length); i++)
		yield* Visit15(`${path}/${i}`, current[i], next[i]);
	for (let i = 0; i < next.length; i++) {
		if (i < current.length) continue;
		yield CreateInsert(`${path}/${i}`, next[i]);
	}
	for (let i = current.length - 1; i >= 0; i--) {
		if (i < next.length) continue;
		yield CreateDelete(`${path}/${i}`);
	}
}
function* TypedArrayType2(path, current, next) {
	if (
		!IsTypedArray(next) ||
		current.length !== next.length ||
		globalThis.Object.getPrototypeOf(current).constructor.name !==
			globalThis.Object.getPrototypeOf(next).constructor.name
	)
		return yield CreateUpdate(path, next);
	for (let i = 0; i < Math.min(current.length, next.length); i++)
		yield* Visit15(`${path}/${i}`, current[i], next[i]);
}
function* ValueType2(path, current, next) {
	if (current === next) return;
	yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
	if (IsStandardObject(current)) return yield* ObjectType4(path, current, next);
	if (IsArray2(current)) return yield* ArrayType4(path, current, next);
	if (IsTypedArray(current)) return yield* TypedArrayType2(path, current, next);
	if (IsValueType(current)) return yield* ValueType2(path, current, next);
	throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
	return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
	return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
	return edits.length === 0;
}
function Patch(current, edits) {
	if (IsRootUpdate(edits)) return Clone2(edits[0].value);
	if (IsIdentity(edits)) return Clone2(current);
	let clone = Clone2(current);
	for (let edit of edits)
		switch (edit.type) {
			case "insert": {
				exports_pointer.Set(clone, edit.path, edit.value);
				break;
			}
			case "update": {
				exports_pointer.Set(clone, edit.path, edit.value);
				break;
			}
			case "delete": {
				exports_pointer.Delete(clone, edit.path);
				break;
			}
		}
	return clone;
}
function Encode(...args) {
	let [schema, references, value] =
			args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]],
		encoded = HasTransform(schema, references)
			? TransformEncode(schema, references, value)
			: value;
	if (!Check(schema, references, encoded))
		throw new TransformEncodeCheckError(
			schema,
			encoded,
			Errors(schema, references, encoded).First(),
		);
	return encoded;
}
function IsStandardObject2(value) {
	return IsObject2(value) && !IsArray2(value);
}
class ValueMutateError extends TypeBoxError {
	constructor(message) {
		super(message);
	}
}
function ObjectType5(root, path, current, next) {
	if (!IsStandardObject2(current))
		exports_pointer.Set(root, path, Clone2(next));
	else {
		let currentKeys = Object.getOwnPropertyNames(current),
			nextKeys = Object.getOwnPropertyNames(next);
		for (let currentKey of currentKeys)
			if (!nextKeys.includes(currentKey)) delete current[currentKey];
		for (let nextKey of nextKeys)
			if (!currentKeys.includes(nextKey)) current[nextKey] = null;
		for (let nextKey of nextKeys)
			Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
	}
}
function ArrayType5(root, path, current, next) {
	if (!IsArray2(current)) exports_pointer.Set(root, path, Clone2(next));
	else {
		for (let index = 0; index < next.length; index++)
			Visit16(root, `${path}/${index}`, current[index], next[index]);
		current.splice(next.length);
	}
}
function TypedArrayType3(root, path, current, next) {
	if (IsTypedArray(current) && current.length === next.length)
		for (let i = 0; i < current.length; i++) current[i] = next[i];
	else exports_pointer.Set(root, path, Clone2(next));
}
function ValueType3(root, path, current, next) {
	if (current === next) return;
	exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
	if (IsArray2(next)) return ArrayType5(root, path, current, next);
	if (IsTypedArray(next)) return TypedArrayType3(root, path, current, next);
	if (IsStandardObject2(next)) return ObjectType5(root, path, current, next);
	if (IsValueType(next)) return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
	return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
	return (
		(IsStandardObject2(current) && IsArray2(next)) ||
		(IsArray2(current) && IsStandardObject2(next))
	);
}
function Mutate(current, next) {
	if (IsNonMutableValue(current) || IsNonMutableValue(next))
		throw new ValueMutateError(
			"Only object and array types can be mutated at the root level",
		);
	if (IsMismatchedValue(current, next))
		throw new ValueMutateError(
			"Cannot assign due type mismatch of assignable values",
		);
	Visit16(current, "", current, next);
}
class ParseError extends TypeBoxError {
	constructor(message) {
		super(message);
	}
}
var ParseRegistry;
(function (ParseRegistry2) {
	let registry = new Map([
		[
			"Assert",
			(type, references, value) => {
				return Assert(type, references, value), value;
			},
		],
		["Cast", (type, references, value) => Cast(type, references, value)],
		["Clean", (type, references, value) => Clean(type, references, value)],
		["Clone", (_type, _references, value) => Clone2(value)],
		["Convert", (type, references, value) => Convert(type, references, value)],
		[
			"Decode",
			(type, references, value) =>
				HasTransform(type, references)
					? TransformDecode(type, references, value)
					: value,
		],
		["Default", (type, references, value) => Default5(type, references, value)],
		[
			"Encode",
			(type, references, value) =>
				HasTransform(type, references)
					? TransformEncode(type, references, value)
					: value,
		],
	]);
	function Delete5(key) {
		registry.delete(key);
	}
	ParseRegistry2.Delete = Delete5;
	function Set5(key, callback) {
		registry.set(key, callback);
	}
	ParseRegistry2.Set = Set5;
	function Get4(key) {
		return registry.get(key);
	}
	ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = ["Clone", "Clean", "Default", "Convert", "Assert", "Decode"];
function ParseValue(operations, type, references, value) {
	return operations.reduce((value2, operationKey) => {
		let operation = ParseRegistry.Get(operationKey);
		if (IsUndefined2(operation))
			throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
		return operation(type, references, value2);
	}, value);
}
function Parse(...args) {
	let [operations, schema, references, value] =
		args.length === 4
			? [args[0], args[1], args[2], args[3]]
			: args.length === 3
				? IsArray2(args[0])
					? [args[0], args[1], [], args[2]]
					: [ParseDefault, args[0], args[1], args[2]]
				: args.length === 2
					? [ParseDefault, args[0], [], args[1]]
					: (() => {
							throw new ParseError("Invalid Arguments");
						})();
	return ParseValue(operations, schema, references, value);
}
var exports_value2 = {};
__export(exports_value2, {
	ValueErrorIterator: () => ValueErrorIterator,
	Patch: () => Patch,
	Parse: () => Parse,
	Mutate: () => Mutate,
	Hash: () => Hash,
	Errors: () => Errors,
	Equal: () => Equal,
	Encode: () => Encode,
	Edit: () => Edit,
	Diff: () => Diff,
	Default: () => Default5,
	Decode: () => Decode,
	Create: () => Create2,
	Convert: () => Convert,
	Clone: () => Clone2,
	Clean: () => Clean,
	Check: () => Check,
	Cast: () => Cast,
	Assert: () => Assert,
});
var fullFormats = {
	date,
	time: getTime(!0),
	"date-time": getDateTime(!0),
	"iso-time": getTime(!1),
	"iso-date-time": getDateTime(!1),
	duration:
		/^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
	uri,
	"uri-reference":
		/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
	"uri-template":
		/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
	url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
	email:
		/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
	hostname:
		/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
	ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
	ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
	regex,
	uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
	"json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
	"json-pointer-uri-fragment":
		/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
	"relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
	byte,
	int32: { type: "number", validate: validateInt32 },
	int64: { type: "number", validate: validateInt64 },
	float: { type: "number", validate: validateNumber },
	double: { type: "number", validate: validateNumber },
	password: !0,
	binary: !0,
};
function isLeapYear(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
	DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
	let matches = DATE.exec(str);
	if (!matches) return !1;
	let year = +matches[1],
		month = +matches[2],
		day = +matches[3];
	return (
		month >= 1 &&
		month <= 12 &&
		day >= 1 &&
		day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])
	);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
	return function time(str) {
		let matches = TIME.exec(str);
		if (!matches) return !1;
		let hr = +matches[1],
			min = +matches[2],
			sec = +matches[3],
			tz = matches[4],
			tzSign = matches[5] === "-" ? -1 : 1,
			tzH = +(matches[6] || 0),
			tzM = +(matches[7] || 0);
		if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return !1;
		if (hr <= 23 && min <= 59 && sec < 60) return !0;
		let utcMin = min - tzM * tzSign,
			utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
		return (
			(utcHr === 23 || utcHr === -1) &&
			(utcMin === 59 || utcMin === -1) &&
			sec < 61
		);
	};
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
	let time = getTime(strictTimeZone);
	return function date_time(str) {
		let dateTime = str.split(DATE_TIME_SEPARATOR);
		return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
	};
}
var NOT_URI_FRAGMENT = /\/|:/,
	URI =
		/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
	return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
	return (BYTE.lastIndex = 0), BYTE.test(str);
}
var MIN_INT32 = -2147483648,
	MAX_INT32 = 2147483647;
function validateInt32(value) {
	return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
	return Number.isInteger(value);
}
function validateNumber() {
	return !0;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
	if (Z_ANCHOR.test(str)) return !1;
	try {
		return new RegExp(str), !0;
	} catch (e) {
		return !1;
	}
}
var hasHeaderShorthand = "toJSON" in new Headers(),
	replaceUrlPath = (url, pathname) => {
		let urlObject = new URL(url);
		return (urlObject.pathname = pathname), urlObject.toString();
	},
	isClass = (v) =>
		(typeof v === "function" && /^\s*class\s+/.test(v.toString())) ||
		(v.toString &&
			v.toString().startsWith("[object ") &&
			v.toString() !== "[object Object]") ||
		isNotEmpty(Object.getPrototypeOf(v)),
	isObject = (item) => item && typeof item === "object" && !Array.isArray(item),
	mergeDeep = (target, source, { skipKeys, override = !0 } = {}) => {
		if (!isObject(target) || !isObject(source)) return target;
		for (let [key, value] of Object.entries(source)) {
			if (skipKeys?.includes(key)) continue;
			if (!isObject(value) || !(key in target) || isClass(value)) {
				if (override || !(key in target)) target[key] = value;
				continue;
			}
			target[key] = mergeDeep(target[key], value, { skipKeys, override });
		}
		return target;
	},
	mergeCookie = (a, b) => {
		let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"] });
		if ("properties" in v) delete v.properties;
		return v;
	},
	mergeObjectArray = (a = [], b = []) => {
		if (!a) return;
		if (!b) return a;
		let array = [],
			checksums = [];
		if (!Array.isArray(a)) a = [a];
		if (!Array.isArray(b)) b = [b];
		for (let item of a)
			if ((array.push(item), item.checksum)) checksums.push(item.checksum);
		for (let item of b)
			if (!checksums.includes(item.checksum)) array.push(item);
		return array;
	},
	primitiveHooks = [
		"start",
		"request",
		"parse",
		"transform",
		"resolve",
		"beforeHandle",
		"afterHandle",
		"mapResponse",
		"afterResponse",
		"trace",
		"error",
		"stop",
		"body",
		"headers",
		"params",
		"query",
		"response",
		"type",
		"detail",
	],
	primitiveHookMap = primitiveHooks.reduce(
		(acc, x) => ((acc[x] = !0), acc),
		{},
	),
	mergeResponse = (a, b) => {
		let isRecordNumber = (x) =>
			typeof x === "object" && Object.keys(x).every(isNumericString);
		if (isRecordNumber(a) && isRecordNumber(b)) return Object.assign(a, b);
		else if (a && !isRecordNumber(a) && isRecordNumber(b))
			return Object.assign({ 200: a }, b);
		return b ?? a;
	},
	mergeSchemaValidator = (a, b) => {
		return {
			body: b?.body ?? a?.body,
			headers: b?.headers ?? a?.headers,
			params: b?.params ?? a?.params,
			query: b?.query ?? a?.query,
			cookie: b?.cookie ?? a?.cookie,
			response: mergeResponse(a?.response, b?.response),
		};
	},
	mergeHook = (a, b) => {
		let { resolve: resolveA, ...restA } = a ?? {},
			{ resolve: resolveB, ...restB } = b ?? {};
		return {
			...restA,
			...restB,
			body: b?.body ?? a?.body,
			headers: b?.headers ?? a?.headers,
			params: b?.params ?? a?.params,
			query: b?.query ?? a?.query,
			cookie: b?.cookie ?? a?.cookie,
			response: mergeResponse(a?.response, b?.response),
			type: a?.type || b?.type,
			detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
			parse: mergeObjectArray(a?.parse, b?.parse),
			transform: mergeObjectArray(a?.transform, b?.transform),
			beforeHandle: mergeObjectArray(
				mergeObjectArray(fnToContainer(resolveA, "resolve"), a?.beforeHandle),
				mergeObjectArray(fnToContainer(resolveB, "resolve"), b?.beforeHandle),
			),
			afterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),
			mapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse),
			afterResponse: mergeObjectArray(a?.afterResponse, b?.afterResponse),
			trace: mergeObjectArray(a?.trace, b?.trace),
			error: mergeObjectArray(a?.error, b?.error),
		};
	},
	replaceSchemaType = (schema, options, root = !0) => {
		if (!Array.isArray(options))
			return (
				(options.original = schema), _replaceSchemaType(schema, options, root)
			);
		for (let option of options)
			(option.original = schema),
				(schema = _replaceSchemaType(schema, option, root));
		return schema;
	},
	_replaceSchemaType = (schema, options, root = !0) => {
		if (!schema) return schema;
		if (options.untilObjectFound && !root && schema.type === "object")
			return schema;
		let fromSymbol = options.from[Kind];
		if (schema.oneOf) {
			for (let i = 0; i < schema.oneOf.length; i++)
				schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, root);
			return schema;
		}
		if (schema.anyOf) {
			for (let i = 0; i < schema.anyOf.length; i++)
				schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, root);
			return schema;
		}
		if (schema.allOf) {
			for (let i = 0; i < schema.allOf.length; i++)
				schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, root);
			return schema;
		}
		if (schema.not) return _replaceSchemaType(schema.not, options, root);
		let isRoot = root && !!options.excludeRoot;
		if (schema[Kind] === fromSymbol) {
			let {
					anyOf,
					oneOf,
					allOf,
					not,
					properties: properties2,
					items,
					...rest
				} = schema,
				to = options.to(rest);
			if (!to) return schema;
			let transform2,
				composeProperties = (v) => {
					if (properties2 && v.type === "object") {
						let newProperties = {};
						for (let [key, value2] of Object.entries(properties2))
							newProperties[key] = _replaceSchemaType(value2, options, !1);
						return { ...rest, ...v, properties: newProperties };
					}
					if (items && v.type === "array")
						return {
							...rest,
							...v,
							items: _replaceSchemaType(items, options, !1),
						};
					let value = { ...rest, ...v };
					if (
						(delete value.required,
						properties2 &&
							v.type === "string" &&
							v.format === "ObjectString" &&
							v.default === "{}")
					)
						(transform2 = t.ObjectString(properties2, rest)),
							(value.default = JSON.stringify(
								exports_value2.Create(t.Object(properties2)),
							)),
							(value.properties = properties2);
					if (
						items &&
						v.type === "string" &&
						v.format === "ArrayString" &&
						v.default === "[]"
					)
						(transform2 = t.ArrayString(items, rest)),
							(value.default = JSON.stringify(
								exports_value2.Create(t.Array(items)),
							)),
							(value.items = items);
					return value;
				};
			if (isRoot) {
				if (properties2) {
					let newProperties = {};
					for (let [key, value] of Object.entries(properties2))
						newProperties[key] = _replaceSchemaType(value, options, !1);
					return { ...rest, properties: newProperties };
				} else if (items?.map)
					return {
						...rest,
						items: items.map((v) => _replaceSchemaType(v, options, !1)),
					};
				return rest;
			}
			if (to.anyOf)
				for (let i = 0; i < to.anyOf.length; i++)
					to.anyOf[i] = composeProperties(to.anyOf[i]);
			else if (to.oneOf)
				for (let i = 0; i < to.oneOf.length; i++)
					to.oneOf[i] = composeProperties(to.oneOf[i]);
			else if (to.allOf)
				for (let i = 0; i < to.allOf.length; i++)
					to.allOf[i] = composeProperties(to.allOf[i]);
			else if (to.not) to.not = composeProperties(to.not);
			if (transform2) to[TransformKind] = transform2[TransformKind];
			if (to.anyOf || to.oneOf || to.allOf || to.not) return to;
			if (properties2) {
				let newProperties = {};
				for (let [key, value] of Object.entries(properties2))
					newProperties[key] = _replaceSchemaType(value, options, !1);
				return { ...rest, ...to, properties: newProperties };
			} else if (items?.map)
				return {
					...rest,
					...to,
					items: items.map((v) => _replaceSchemaType(v, options, !1)),
				};
			return { ...rest, ...to };
		}
		let properties = schema?.properties;
		if (properties && root && options.rootOnly !== !0)
			for (let [key, value] of Object.entries(properties))
				switch (value[Kind]) {
					case fromSymbol:
						let { anyOf, oneOf, allOf, not, type, ...rest } = value,
							to = options.to(rest);
						if (!to) return schema;
						if (to.anyOf)
							for (let i = 0; i < to.anyOf.length; i++)
								to.anyOf[i] = { ...rest, ...to.anyOf[i] };
						else if (to.oneOf)
							for (let i = 0; i < to.oneOf.length; i++)
								to.oneOf[i] = { ...rest, ...to.oneOf[i] };
						else if (to.allOf)
							for (let i = 0; i < to.allOf.length; i++)
								to.allOf[i] = { ...rest, ...to.allOf[i] };
						else if (to.not) to.not = { ...rest, ...to.not };
						properties[key] = {
							...rest,
							..._replaceSchemaType(rest, options, !1),
						};
						break;
					case "Object":
					case "Union":
						properties[key] = _replaceSchemaType(value, options, !1);
						break;
					default:
						if (Array.isArray(value.items))
							for (let i = 0; i < value.items.length; i++)
								value.items[i] = _replaceSchemaType(
									value.items[i],
									options,
									!1,
								);
						else if (value.anyOf || value.oneOf || value.allOf || value.not)
							properties[key] = _replaceSchemaType(value, options, !1);
						else if (value.type === "array")
							value.items = _replaceSchemaType(value.items, options, !1);
						break;
				}
		return schema;
	},
	createCleaner = (schema) => (value) => {
		if (typeof value === "object")
			try {
				return exports_value2.Clean(schema, structuredClone(value));
			} catch {
				try {
					return exports_value2.Clean(schema, value);
				} catch {
					return value;
				}
			}
		return value;
	},
	getSchemaValidator = (
		s,
		{
			models = {},
			dynamic = !1,
			modules,
			normalize = !1,
			additionalProperties = !1,
			coerce = !1,
			additionalCoerce = [],
		} = { modules: t.Module({}) },
	) => {
		if (!s) return;
		let schema;
		if (typeof s !== "string") schema = s;
		else {
			let isArray = s.endsWith("[]"),
				key = isArray ? s.substring(0, s.length - 2) : s;
			if (((schema = modules.Import(key) ?? models[key]), isArray))
				schema = t.Array(schema);
		}
		if (!schema) return;
		if (coerce || additionalCoerce)
			if (coerce)
				schema = replaceSchemaType(schema, [
					{ from: t.Ref(""), to: (options) => modules.Import(options.$ref) },
					{
						from: t.Number(),
						to: (options) => t.Numeric(options),
						untilObjectFound: !0,
					},
					{
						from: t.Boolean(),
						to: (options) => t.BooleanString(options),
						untilObjectFound: !0,
					},
					...(Array.isArray(additionalCoerce)
						? additionalCoerce
						: [additionalCoerce]),
				]);
			else
				schema = replaceSchemaType(schema, [
					{ from: t.Ref(""), to: (options) => modules.Import(options.$ref) },
					...(Array.isArray(additionalCoerce)
						? additionalCoerce
						: [additionalCoerce]),
				]);
		if (schema.type === "object" && "additionalProperties" in schema === !1)
			schema.additionalProperties = additionalProperties;
		if (dynamic) {
			let validator = {
				schema,
				references: "",
				checkFunc: () => {},
				code: "",
				Check: (value) => exports_value2.Check(schema, value),
				Errors: (value) => exports_value2.Errors(schema, value),
				Code: () => "",
				Clean: createCleaner(schema),
				Decode: (value) => exports_value2.Decode(schema, value),
				Encode: (value) => exports_value2.Encode(schema, value),
			};
			if (normalize && schema.additionalProperties === !1)
				validator.Clean = createCleaner(schema);
			if (schema.config) {
				if (((validator.config = schema.config), validator?.schema?.config))
					delete validator.schema.config;
			}
			return (
				(validator.parse = (v) => {
					try {
						return validator.Decode(v);
					} catch (error) {
						throw [...validator.Errors(v)].map(mapValueError);
					}
				}),
				(validator.safeParse = (v) => {
					try {
						return { success: !0, data: validator.Decode(v), error: null };
					} catch (error) {
						let errors = [...compiled.Errors(v)].map(mapValueError);
						return {
							success: !1,
							data: null,
							error: errors[0]?.summary,
							errors,
						};
					}
				}),
				validator
			);
		}
		let compiled = TypeCompiler.Compile(schema, Object.values(models));
		if (((compiled.Clean = createCleaner(schema)), schema.config)) {
			if (((compiled.config = schema.config), compiled?.schema?.config))
				delete compiled.schema.config;
		}
		return (
			(compiled.parse = (v) => {
				try {
					return compiled.Decode(v);
				} catch (error) {
					throw [...compiled.Errors(v)].map(mapValueError);
				}
			}),
			(compiled.safeParse = (v) => {
				try {
					return { success: !0, data: compiled.Decode(v), error: null };
				} catch (error) {
					let errors = [...compiled.Errors(v)].map(mapValueError);
					return { success: !1, data: null, error: errors[0]?.summary, errors };
				}
			}),
			compiled
		);
	},
	getResponseSchemaValidator = (
		s,
		{
			models = {},
			modules,
			dynamic = !1,
			normalize = !1,
			additionalProperties = !1,
		},
	) => {
		if (!s) return;
		let maybeSchemaOrRecord;
		if (typeof s !== "string") maybeSchemaOrRecord = s;
		else {
			let isArray = s.endsWith("[]"),
				key = isArray ? s.substring(0, s.length - 2) : s;
			if (((maybeSchemaOrRecord = modules.Import(key) ?? models[key]), isArray))
				maybeSchemaOrRecord = t.Array(maybeSchemaOrRecord);
		}
		if (!maybeSchemaOrRecord) return;
		let compile = (schema, references) => {
				if (dynamic)
					return {
						schema,
						references: "",
						checkFunc: () => {},
						code: "",
						Check: (value) => exports_value2.Check(schema, value),
						Errors: (value) => exports_value2.Errors(schema, value),
						Code: () => "",
						Clean: createCleaner(schema),
						Decode: (value) => exports_value2.Decode(schema, value),
						Encode: (value) => exports_value2.Encode(schema, value),
					};
				let compiledValidator = TypeCompiler.Compile(schema, references);
				if (normalize && schema.additionalProperties === !1)
					compiledValidator.Clean = createCleaner(schema);
				return compiledValidator;
			},
			modelValues = Object.values(models);
		if (Kind in maybeSchemaOrRecord) {
			if ("additionalProperties" in maybeSchemaOrRecord === !1)
				maybeSchemaOrRecord.additionalProperties = additionalProperties;
			return { 200: compile(maybeSchemaOrRecord, modelValues) };
		}
		let record = {};
		return (
			Object.keys(maybeSchemaOrRecord).forEach((status) => {
				let maybeNameOrSchema = maybeSchemaOrRecord[+status];
				if (typeof maybeNameOrSchema === "string") {
					if (maybeNameOrSchema in models) {
						let schema = models[maybeNameOrSchema];
						schema.type === "object" && "additionalProperties" in schema,
							(record[+status] =
								Kind in schema ? compile(schema, modelValues) : schema);
					}
					return;
				}
				if (
					maybeNameOrSchema.type === "object" &&
					"additionalProperties" in maybeNameOrSchema === !1
				)
					maybeNameOrSchema.additionalProperties = additionalProperties;
				record[+status] =
					Kind in maybeNameOrSchema
						? compile(maybeNameOrSchema, modelValues)
						: maybeNameOrSchema;
			}),
			record
		);
	},
	isBun = typeof Bun !== "undefined",
	hasHash = isBun && typeof Bun.hash === "function",
	checksum = (s) => {
		if (hasHash) return Bun.hash(s);
		let h = 9;
		for (let i = 0; i < s.length; )
			h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
		return (h = h ^ (h >>> 9));
	},
	_stringToStructureCoercions,
	stringToStructureCoercions = () => {
		if (!_stringToStructureCoercions)
			_stringToStructureCoercions = [
				{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: !0 },
				{ from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) },
			];
		return _stringToStructureCoercions;
	},
	_coercePrimitiveRoot,
	coercePrimitiveRoot = () => {
		if (!_coercePrimitiveRoot)
			_coercePrimitiveRoot = [
				{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: !0 },
				{
					from: t.Boolean(),
					to: (options) => t.BooleanString(options),
					rootOnly: !0,
				},
			];
		return _coercePrimitiveRoot;
	},
	getCookieValidator = ({
		validator,
		modules,
		defaultConfig = {},
		config,
		dynamic,
		models,
	}) => {
		let cookieValidator = getSchemaValidator(validator, {
			modules,
			dynamic,
			models,
			additionalProperties: !0,
			coerce: !0,
			additionalCoerce: stringToStructureCoercions(),
		});
		if (isNotEmpty(defaultConfig))
			if (cookieValidator)
				cookieValidator.config = mergeCookie(cookieValidator.config, config);
			else
				(cookieValidator = getSchemaValidator(t.Cookie({}), {
					modules,
					dynamic,
					models,
					additionalProperties: !0,
				})),
					(cookieValidator.config = defaultConfig);
		return cookieValidator;
	},
	injectChecksum = (checksum2, x) => {
		if (!x) return;
		if (!Array.isArray(x)) {
			let fn = x;
			if (checksum2 && !fn.checksum) fn.checksum = checksum2;
			if (fn.scope === "scoped") fn.scope = "local";
			return fn;
		}
		let fns = [...x];
		for (let fn of fns) {
			if (checksum2 && !fn.checksum) fn.checksum = checksum2;
			if (fn.scope === "scoped") fn.scope = "local";
		}
		return fns;
	},
	mergeLifeCycle = (a, b, checksum2) => {
		return {
			start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)),
			request: mergeObjectArray(
				a.request,
				injectChecksum(checksum2, b?.request),
			),
			parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)),
			transform: mergeObjectArray(
				a.transform,
				injectChecksum(checksum2, b?.transform),
			),
			beforeHandle: mergeObjectArray(
				mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle),
				injectChecksum(
					checksum2,
					mergeObjectArray(
						fnToContainer(b?.resolve, "resolve"),
						b?.beforeHandle,
					),
				),
			),
			afterHandle: mergeObjectArray(
				a.afterHandle,
				injectChecksum(checksum2, b?.afterHandle),
			),
			mapResponse: mergeObjectArray(
				a.mapResponse,
				injectChecksum(checksum2, b?.mapResponse),
			),
			afterResponse: mergeObjectArray(
				a.afterResponse,
				injectChecksum(checksum2, b?.afterResponse),
			),
			trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)),
			error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)),
			stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)),
		};
	},
	asHookType = (fn, inject, { skipIfHasType = !1 } = {}) => {
		if (!fn) return fn;
		if (!Array.isArray(fn)) {
			if (skipIfHasType) fn.scope ??= inject;
			else fn.scope = inject;
			return fn;
		}
		for (let x of fn)
			if (skipIfHasType) x.scope ??= inject;
			else x.scope = inject;
		return fn;
	},
	filterGlobal = (fn) => {
		if (!fn) return fn;
		if (!Array.isArray(fn))
			switch (fn.scope) {
				case "global":
				case "scoped":
					return { ...fn };
				default:
					return { fn };
			}
		let array = [];
		for (let x of fn)
			switch (x.scope) {
				case "global":
				case "scoped":
					array.push({ ...x });
					break;
			}
		return array;
	},
	filterGlobalHook = (hook) => {
		return {
			...hook,
			type: hook?.type,
			detail: hook?.detail,
			parse: filterGlobal(hook?.parse),
			transform: filterGlobal(hook?.transform),
			beforeHandle: filterGlobal(hook?.beforeHandle),
			afterHandle: filterGlobal(hook?.afterHandle),
			mapResponse: filterGlobal(hook?.mapResponse),
			afterResponse: filterGlobal(hook?.afterResponse),
			error: filterGlobal(hook?.error),
			trace: filterGlobal(hook?.trace),
		};
	},
	StatusMap = {
		Continue: 100,
		"Switching Protocols": 101,
		Processing: 102,
		"Early Hints": 103,
		OK: 200,
		Created: 201,
		Accepted: 202,
		"Non-Authoritative Information": 203,
		"No Content": 204,
		"Reset Content": 205,
		"Partial Content": 206,
		"Multi-Status": 207,
		"Already Reported": 208,
		"Multiple Choices": 300,
		"Moved Permanently": 301,
		Found: 302,
		"See Other": 303,
		"Not Modified": 304,
		"Temporary Redirect": 307,
		"Permanent Redirect": 308,
		"Bad Request": 400,
		Unauthorized: 401,
		"Payment Required": 402,
		Forbidden: 403,
		"Not Found": 404,
		"Method Not Allowed": 405,
		"Not Acceptable": 406,
		"Proxy Authentication Required": 407,
		"Request Timeout": 408,
		Conflict: 409,
		Gone: 410,
		"Length Required": 411,
		"Precondition Failed": 412,
		"Payload Too Large": 413,
		"URI Too Long": 414,
		"Unsupported Media Type": 415,
		"Range Not Satisfiable": 416,
		"Expectation Failed": 417,
		"I'm a teapot": 418,
		"Misdirected Request": 421,
		"Unprocessable Content": 422,
		Locked: 423,
		"Failed Dependency": 424,
		"Too Early": 425,
		"Upgrade Required": 426,
		"Precondition Required": 428,
		"Too Many Requests": 429,
		"Request Header Fields Too Large": 431,
		"Unavailable For Legal Reasons": 451,
		"Internal Server Error": 500,
		"Not Implemented": 501,
		"Bad Gateway": 502,
		"Service Unavailable": 503,
		"Gateway Timeout": 504,
		"HTTP Version Not Supported": 505,
		"Variant Also Negotiates": 506,
		"Insufficient Storage": 507,
		"Loop Detected": 508,
		"Not Extended": 510,
		"Network Authentication Required": 511,
	},
	InvertedStatusMap = Object.fromEntries(
		Object.entries(StatusMap).map(([k, v]) => [v, k]),
	);
function removeTrailingEquals(digest) {
	let trimmedDigest = digest;
	while (trimmedDigest.endsWith("="))
		trimmedDigest = trimmedDigest.slice(0, -1);
	return trimmedDigest;
}
var encoder = new TextEncoder(),
	signCookie = async (val, secret) => {
		if (typeof val !== "string")
			throw new TypeError("Cookie value must be provided as a string.");
		if (secret === null) throw new TypeError("Secret key must be provided.");
		let secretKey = await crypto.subtle.importKey(
				"raw",
				encoder.encode(secret),
				{ name: "HMAC", hash: "SHA-256" },
				!1,
				["sign"],
			),
			hmacBuffer = await crypto.subtle.sign(
				"HMAC",
				secretKey,
				encoder.encode(val),
			);
		return (
			val +
			"." +
			removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"))
		);
	},
	unsignCookie = async (input, secret) => {
		if (typeof input !== "string")
			throw new TypeError("Signed cookie string must be provided.");
		if (secret === null) throw new TypeError("Secret key must be provided.");
		let tentativeValue = input.slice(0, input.lastIndexOf("."));
		return (await signCookie(tentativeValue, secret)) === input
			? tentativeValue
			: !1;
	},
	traceBackMacro = (extension, property, manage) => {
		if (!extension || typeof extension !== "object" || !property) return;
		for (let [key, value] of Object.entries(property)) {
			if (key in primitiveHookMap || !(key in extension)) continue;
			let v = extension[key];
			if (typeof v === "function") {
				let hook = v(value);
				if (typeof hook === "object")
					for (let [k, v2] of Object.entries(hook)) manage(k)({ fn: v2 });
			}
			delete property[key];
		}
	},
	createMacroManager =
		({ globalHook, localHook }) =>
		(stackName) =>
		(type, fn) => {
			if (typeof type === "function") type = { fn: type };
			if (stackName === "resolve") type = { ...type, subType: "resolve" };
			if ("fn" in type || Array.isArray(type)) {
				if (!localHook[stackName]) localHook[stackName] = [];
				if (typeof localHook[stackName] === "function")
					localHook[stackName] = [localHook[stackName]];
				if (Array.isArray(type))
					localHook[stackName] = localHook[stackName].concat(type);
				else localHook[stackName].push(type);
				return;
			}
			let { insert = "after", stack = "local" } = type;
			if (typeof fn === "function") fn = { fn };
			if (stack === "global")
				if (!Array.isArray(fn))
					if (insert === "before") globalHook[stackName].unshift(fn);
					else globalHook[stackName].push(fn);
				else if (insert === "before")
					globalHook[stackName] = fn.concat(globalHook[stackName]);
				else globalHook[stackName] = globalHook[stackName].concat(fn);
			else {
				if (!localHook[stackName]) localHook[stackName] = [];
				if (typeof localHook[stackName] === "function")
					localHook[stackName] = [localHook[stackName]];
				if (!Array.isArray(fn))
					if (insert === "before") localHook[stackName].unshift(fn);
					else localHook[stackName].push(fn);
				else if (insert === "before")
					localHook[stackName] = fn.concat(localHook[stackName]);
				else localHook[stackName] = localHook[stackName].concat(fn);
			}
		},
	parseNumericString = (message) => {
		if (typeof message === "number") return message;
		if (message.length < 16) {
			if (message.trim().length === 0) return null;
			let length = Number(message);
			if (Number.isNaN(length)) return null;
			return length;
		}
		if (message.length === 16) {
			if (message.trim().length === 0) return null;
			let number = Number(message);
			if (Number.isNaN(number) || number.toString() !== message) return null;
			return number;
		}
		return null;
	},
	isNumericString = (message) => parseNumericString(message) !== null;
class PromiseGroup {
	constructor(onError = console.error) {
		(this.onError = onError), (this.root = null), (this.promises = []);
	}
	get size() {
		return this.promises.length;
	}
	add(promise) {
		return this.promises.push(promise), (this.root ||= this.drain()), promise;
	}
	async drain() {
		while (this.promises.length > 0) {
			try {
				await this.promises[0];
			} catch (error) {
				this.onError(error);
			}
			this.promises.shift();
		}
		this.root = null;
	}
	then(onfulfilled, onrejected) {
		return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
	}
}
var fnToContainer = (fn, subType) => {
		if (!fn) return fn;
		if (!Array.isArray(fn)) {
			if (typeof fn === "function" || typeof fn === "string")
				return subType ? { fn, subType } : { fn };
			else if ("fn" in fn) return fn;
		}
		let fns = [];
		for (let x of fn)
			if (typeof x === "function" || typeof x === "string")
				fns.push(subType ? { fn: x, subType } : { fn: x });
			else if ("fn" in x) fns.push(x);
		return fns;
	},
	localHookToLifeCycleStore = (a) => {
		return {
			...a,
			start: fnToContainer(a?.start),
			request: fnToContainer(a?.request),
			parse: fnToContainer(a?.parse),
			transform: fnToContainer(a?.transform),
			beforeHandle: fnToContainer(a?.beforeHandle),
			afterHandle: fnToContainer(a?.afterHandle),
			mapResponse: fnToContainer(a?.mapResponse),
			afterResponse: fnToContainer(a?.afterResponse),
			trace: fnToContainer(a?.trace),
			error: fnToContainer(a?.error),
			stop: fnToContainer(a?.stop),
		};
	},
	lifeCycleToFn = (a) => {
		let hook = {};
		if (a.start?.map) hook.start = a.start.map((x) => x.fn);
		if (a.request?.map) hook.request = a.request.map((x) => x.fn);
		if (a.parse?.map) hook.parse = a.parse.map((x) => x.fn);
		if (a.transform?.map) hook.transform = a.transform.map((x) => x.fn);
		if (a.beforeHandle?.map)
			hook.beforeHandle = a.beforeHandle.map((x) => x.fn);
		if (a.afterHandle?.map) hook.afterHandle = a.afterHandle.map((x) => x.fn);
		if (a.mapResponse?.map) hook.mapResponse = a.mapResponse.map((x) => x.fn);
		if (a.afterResponse?.map)
			hook.afterResponse = a.afterResponse.map((x) => x.fn);
		if (a.trace?.map) hook.trace = a.trace.map((x) => x.fn);
		if (a.error?.map) hook.error = a.error.map((x) => x.fn);
		if (a.stop?.map) hook.stop = a.stop.map((x) => x.fn);
		return hook;
	},
	cloneInference = (inference) => ({
		body: inference.body,
		cookie: inference.cookie,
		headers: inference.headers,
		query: inference.query,
		set: inference.set,
		server: inference.server,
		request: inference.request,
		route: inference.route,
	}),
	redirect = (url, status = 302) => Response.redirect(url, status),
	ELYSIA_FORM_DATA = Symbol("ElysiaFormData"),
	ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var randomId = () => {
		let uuid = crypto.randomUUID();
		return uuid.slice(0, 8) + uuid.slice(24, 32);
	},
	deduplicateChecksum = (array) => {
		let hashes = [];
		for (let i = 0; i < array.length; i++) {
			let item = array[i];
			if (item.checksum) {
				if (hashes.includes(item.checksum)) array.splice(i, 1), i--;
				hashes.push(item.checksum);
			}
		}
		return array;
	},
	promoteEvent = (events, as = "scoped") => {
		if (!events) return;
		if (as === "scoped") {
			for (let event of events)
				if ("scope" in event && event.scope === "local") event.scope = "scoped";
			return;
		}
		for (let event of events) if ("scope" in event) event.scope = "global";
	},
	getLoosePath = (path) => {
		if (path.charCodeAt(path.length - 1) === 47)
			return path.slice(0, path.length - 1);
		return path + "/";
	},
	isNotEmpty = (obj) => {
		if (!obj) return !1;
		for (let x in obj) return !0;
		return !1;
	},
	isEmptyHookProperty = (prop) => {
		if (Array.isArray(prop)) return prop.length === 0;
		return !prop;
	},
	compressHistoryHook = (hook) => {
		let history = { ...hook };
		if (isEmptyHookProperty(hook.afterHandle)) delete history.afterHandle;
		if (isEmptyHookProperty(hook.afterResponse)) delete history.afterResponse;
		if (isEmptyHookProperty(hook.beforeHandle)) delete history.beforeHandle;
		if (isEmptyHookProperty(hook.error)) delete history.error;
		if (isEmptyHookProperty(hook.mapResponse)) delete history.mapResponse;
		if (isEmptyHookProperty(hook.parse)) delete history.parse;
		if (isEmptyHookProperty(hook.request)) delete history.request;
		if (isEmptyHookProperty(hook.start)) delete history.start;
		if (isEmptyHookProperty(hook.stop)) delete history.stop;
		if (isEmptyHookProperty(hook.trace)) delete history.trace;
		if (isEmptyHookProperty(hook.transform)) delete history.transform;
		if (!history.type) delete history.type;
		if (history.detail && !Object.keys(history.detail).length)
			delete history.detail;
		if (!history.body) delete history.body;
		if (!history.cookie) delete history.cookie;
		if (!history.headers) delete history.headers;
		if (!history.query) delete history.query;
		if (!history.params) delete history.params;
		if (!history.response) delete history.response;
		return history;
	};
var encodePath = (path, { dynamic = !1 } = {}) => {
	let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
	if (dynamic) encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
	return encoded;
};
var env =
		typeof Bun !== "undefined"
			? Bun.env
			: typeof process !== "undefined"
				? process?.env
				: void 0,
	ERROR_CODE = Symbol("ElysiaErrorCode"),
	isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
class ElysiaCustomStatusResponse {
	constructor(code, response) {
		let res =
			response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
		(this.code = StatusMap[code] ?? code), (this.response = res);
	}
}
var error = (code, response) => new ElysiaCustomStatusResponse(code, response);
class InternalServerError extends Error {
	constructor(message) {
		super(message ?? "INTERNAL_SERVER_ERROR");
		(this.code = "INTERNAL_SERVER_ERROR"), (this.status = 500);
	}
}
class NotFoundError extends Error {
	constructor(message) {
		super(message ?? "NOT_FOUND");
		(this.code = "NOT_FOUND"), (this.status = 404);
	}
}
class ParseError2 extends Error {
	constructor() {
		super("Bad Request");
		(this.code = "PARSE"), (this.status = 400);
	}
}
class InvalidCookieSignature extends Error {
	constructor(key, message) {
		super(message ?? `"${key}" has invalid cookie signature`);
		(this.key = key),
			(this.code = "INVALID_COOKIE_SIGNATURE"),
			(this.status = 400);
	}
}
var mapValueError = (error2) => {
	if (!error2) return { summary: void 0 };
	let { message, path, value, type } = error2,
		property = path.slice(1).replaceAll("/", "."),
		isRoot = path === "";
	switch (type) {
		case 42:
			return {
				...error2,
				summary: isRoot
					? "Value should not be provided"
					: `Property '${property}' should not be provided`,
			};
		case 45:
			return {
				...error2,
				summary: isRoot
					? "Value is missing"
					: `Property '${property}' is missing`,
			};
		case 50:
			let quoteIndex = message.indexOf("'"),
				format = message.slice(
					quoteIndex + 1,
					message.indexOf("'", quoteIndex + 1),
				);
			return {
				...error2,
				summary: isRoot
					? "Value should be an email"
					: `Property '${property}' should be ${format}`,
			};
		case 54:
			return {
				...error2,
				summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value}`,
			};
		case 62:
			let union = error2.schema.anyOf
				.map((x) => `'${x?.format ?? x.type}'`)
				.join(", ");
			return {
				...error2,
				summary: isRoot
					? `Value should be one of ${union}`
					: `Property '${property}' should be one of: ${union}`,
			};
		default:
			return { summary: message, ...error2 };
	}
};
class ValidationError extends Error {
	constructor(type, validator, value) {
		if (
			value &&
			typeof value === "object" &&
			value instanceof ElysiaCustomStatusResponse
		)
			value = value.response;
		let error2 = isProduction
				? void 0
				: "Errors" in validator
					? validator.Errors(value).First()
					: exports_value2.Errors(validator, value).First(),
			customError =
				error2?.schema?.message || error2?.schema?.error !== void 0
					? typeof error2.schema.error === "function"
						? error2.schema.error({
								type,
								validator,
								value,
								get errors() {
									return [...validator.Errors(value)].map(mapValueError);
								},
							})
						: error2.schema.error
					: void 0,
			accessor = error2?.path || "root",
			message = "";
		if (customError !== void 0)
			message =
				typeof customError === "object"
					? JSON.stringify(customError)
					: customError + "";
		else if (isProduction)
			message = JSON.stringify({
				type: "validation",
				on: type,
				summary: mapValueError(error2).summary,
				message: error2?.message,
				found: value,
			});
		else {
			let schema = validator?.schema ?? validator,
				errors =
					"Errors" in validator
						? [...validator.Errors(value)].map(mapValueError)
						: [...exports_value2.Errors(validator, value)].map(mapValueError),
				expected;
			try {
				expected = exports_value2.Create(schema);
			} catch (error3) {
				expected = {
					type: "Could not create expected value",
					message: error3?.message,
					error: error3,
				};
			}
			message = JSON.stringify(
				{
					type: "validation",
					on: type,
					summary: mapValueError(error2).summary,
					property: accessor,
					message: error2?.message,
					expected,
					found: value,
					errors,
				},
				null,
				2,
			);
		}
		super(message);
		(this.type = type),
			(this.validator = validator),
			(this.value = value),
			(this.code = "VALIDATION"),
			(this.status = 422),
			Object.setPrototypeOf(this, ValidationError.prototype);
	}
	get all() {
		return "Errors" in this.validator
			? [...this.validator.Errors(this.value)].map(mapValueError)
			: [...exports_value2.Errors(this.validator, this.value)].map(
					mapValueError,
				);
	}
	static simplifyModel(validator) {
		let model = "schema" in validator ? validator.schema : validator;
		try {
			return exports_value2.Create(model);
		} catch {
			return model;
		}
	}
	get model() {
		return ValidationError.simplifyModel(this.validator);
	}
	toResponse(headers) {
		return new Response(this.message, {
			status: 400,
			headers: { ...headers, "content-type": "application/json" },
		});
	}
}
var isISO8601 =
		/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,
	isFormalDate =
		/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/,
	isShortenDate =
		/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/,
	_validateDate = fullFormats.date,
	_validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
	exports_format.Set("date", (value) => {
		let temp = value.replace(/"/g, "");
		if (
			isISO8601.test(temp) ||
			isFormalDate.test(temp) ||
			isShortenDate.test(temp) ||
			_validateDate(temp)
		) {
			let date2 = new Date(temp);
			if (!Number.isNaN(date2.getTime())) return !0;
		}
		return !1;
	});
if (!exports_format.Has("date-time"))
	exports_format.Set("date-time", (value) => {
		let temp = value.replace(/"/g, "");
		if (
			isISO8601.test(temp) ||
			isFormalDate.test(temp) ||
			isShortenDate.test(temp) ||
			_validateDateTime(temp)
		) {
			let date2 = new Date(temp);
			if (!Number.isNaN(date2.getTime())) return !0;
		}
		return !1;
	});
Object.entries(fullFormats).forEach((formatEntry) => {
	let [formatName, formatValue] = formatEntry;
	if (!exports_format.Has(formatName)) {
		if (formatValue instanceof RegExp)
			exports_format.Set(formatName, (value) => formatValue.test(value));
		else if (typeof formatValue === "function")
			exports_format.Set(formatName, formatValue);
	}
});
var t = Object.assign({}, Type),
	parseFileUnit = (size) => {
		if (typeof size === "string")
			switch (size.slice(-1)) {
				case "k":
					return +size.slice(0, size.length - 1) * 1024;
				case "m":
					return +size.slice(0, size.length - 1) * 1048576;
				default:
					return +size;
			}
		return size;
	},
	checkFileExtension = (type, extension) => {
		if (type.startsWith(extension)) return !0;
		return (
			extension.charCodeAt(extension.length - 1) === 42 &&
			extension.charCodeAt(extension.length - 2) === 47 &&
			type.startsWith(extension.slice(0, -1))
		);
	},
	validateFile = (options, value) => {
		if (!(value instanceof Blob)) return !1;
		if (options.minSize && value.size < parseFileUnit(options.minSize))
			return !1;
		if (options.maxSize && value.size > parseFileUnit(options.maxSize))
			return !1;
		if (options.extension) {
			if (typeof options.extension === "string")
				return checkFileExtension(value.type, options.extension);
			for (let i = 0; i < options.extension.length; i++)
				if (checkFileExtension(value.type, options.extension[i])) return !0;
			return !1;
		}
		return !0;
	},
	File2 = getOrSetType("File", validateFile),
	Files = getOrSetType("Files", (options, value) => {
		if (!Array.isArray(value)) return validateFile(options, value);
		if (options.minItems && value.length < options.minItems) return !1;
		if (options.maxItems && value.length > options.maxItems) return !1;
		for (let i = 0; i < value.length; i++)
			if (!validateFile(options, value[i])) return !1;
		return !0;
	});
if (!exports_format.Has("numeric"))
	exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
	exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
	exports_format.Set(
		"boolean",
		(value) => value === "true" || value === "false",
	);
if (!exports_format.Has("ObjectString"))
	exports_format.Set("ObjectString", (value) => {
		let start = value.charCodeAt(0);
		if (start === 9 || start === 10 || start === 32)
			start = value.trimStart().charCodeAt(0);
		if (start !== 123 && start !== 91) return !1;
		try {
			return JSON.parse(value), !0;
		} catch {
			return !1;
		}
	});
if (!exports_format.Has("ArrayString"))
	exports_format.Set("ArrayString", (value) => {
		let start = value.charCodeAt(0);
		if (start === 9 || start === 10 || start === 32)
			start = value.trimStart().charCodeAt(0);
		if (start !== 123 && start !== 91) return !1;
		try {
			return JSON.parse(value), !0;
		} catch {
			return !1;
		}
	});
if (!exports_type2.Has("UnionEnum"))
	exports_type2.Set("UnionEnum", (schema, value) => {
		return (
			(typeof value === "number" ||
				typeof value === "string" ||
				value === null) &&
			schema.enum.includes(value)
		);
	});
var ElysiaType = {
	Numeric: (property) => {
		let schema = Type.Number(property);
		return t
			.Transform(
				t.Union(
					[t.String({ format: "numeric", default: 0 }), t.Number(property)],
					property,
				),
			)
			.Decode((value) => {
				let number = +value;
				if (isNaN(number)) return value;
				if (property && !exports_value2.Check(schema, number))
					throw new ValidationError("property", schema, number);
				return number;
			})
			.Encode((value) => value);
	},
	Integer: (property) => {
		let schema = Type.Integer(property);
		return t
			.Transform(
				t.Union(
					[t.String({ format: "integer", default: 0 }), Type.Integer(property)],
					property,
				),
			)
			.Decode((value) => {
				let number = +value;
				if (!exports_value2.Check(schema, number))
					throw new ValidationError("property", schema, number);
				return number;
			})
			.Encode((value) => value);
	},
	Date: (property) => {
		let schema = Type.Date(property),
			_default = property?.default ? new Date(property.default) : void 0;
		return t
			.Transform(
				t.Union(
					[
						Type.Date(property),
						t.String({ format: "date", default: _default?.toISOString() }),
						t.String({ format: "date-time", default: _default?.toISOString() }),
						t.Number({ default: _default?.getTime() }),
					],
					property,
				),
			)
			.Decode((value) => {
				if (typeof value === "number") {
					let date22 = new Date(value);
					if (!exports_value2.Check(schema, date22))
						throw new ValidationError("property", schema, date22);
					return date22;
				}
				if (value instanceof Date) return value;
				let date2 = new Date(value);
				if (!date2 || isNaN(date2.getTime()))
					throw new ValidationError("property", schema, date2);
				if (!exports_value2.Check(schema, date2))
					throw new ValidationError("property", schema, date2);
				return date2;
			})
			.Encode((value) => value.toISOString());
	},
	BooleanString: (property) => {
		let schema = Type.Boolean(property);
		return t
			.Transform(
				t.Union(
					[t.Boolean(property), t.String({ format: "boolean", default: !1 })],
					property,
				),
			)
			.Decode((value) => {
				if (typeof value === "string") return value === "true";
				if (value !== void 0 && !exports_value2.Check(schema, value))
					throw new ValidationError("property", schema, value);
				return value;
			})
			.Encode((value) => value);
	},
	ObjectString: (properties, options) => {
		let schema = t.Object(properties, options),
			defaultValue = JSON.stringify(exports_value2.Create(schema)),
			compiler;
		try {
			compiler = TypeCompiler.Compile(schema);
		} catch {}
		return t
			.Transform(
				t.Union([
					t.String({ format: "ObjectString", default: defaultValue }),
					schema,
				]),
			)
			.Decode((value) => {
				if (typeof value === "string") {
					if (value.charCodeAt(0) !== 123)
						throw new ValidationError("property", schema, value);
					try {
						value = JSON.parse(value);
					} catch {
						throw new ValidationError("property", schema, value);
					}
					if (compiler) {
						if (!compiler.Check(value))
							throw new ValidationError("property", schema, value);
						return compiler.Decode(value);
					}
					if (!exports_value2.Check(schema, value))
						throw new ValidationError("property", schema, value);
					return exports_value2.Decode(schema, value);
				}
				return value;
			})
			.Encode((value) => {
				if (typeof value === "string")
					try {
						value = JSON.parse(value);
					} catch {
						throw new ValidationError("property", schema, value);
					}
				if (!exports_value2.Check(schema, value))
					throw new ValidationError("property", schema, value);
				return JSON.stringify(value);
			});
	},
	ArrayString: (children = t.String(), options) => {
		let schema = t.Array(children, options),
			compiler;
		try {
			compiler = TypeCompiler.Compile(schema);
		} catch {}
		let decode2 = (value, isProperty = !1) => {
			if (value.charCodeAt(0) === 91) {
				try {
					value = JSON.parse(value);
				} catch {
					throw new ValidationError("property", schema, value);
				}
				if (compiler) {
					if (!compiler.Check(value))
						throw new ValidationError("property", schema, value);
					return compiler.Decode(value);
				}
				if (!exports_value2.Check(schema, value))
					throw new ValidationError("property", schema, value);
				return exports_value2.Decode(schema, value);
			}
			if (value.indexOf(",") !== -1) {
				let newValue = value.split(",").map((v) => v.trim());
				if (compiler) {
					if (!compiler.Check(newValue))
						throw new ValidationError("property", schema, value);
					return compiler.Decode(newValue);
				}
				if (!exports_value2.Check(schema, newValue))
					throw new ValidationError("property", schema, newValue);
				return exports_value2.Decode(schema, newValue);
			}
			if (isProperty) return value;
			throw new ValidationError("property", schema, value);
		};
		return t
			.Transform(
				t.Union([
					t.String({ format: "ArrayString", default: options?.default }),
					schema,
				]),
			)
			.Decode((value) => {
				if (Array.isArray(value)) {
					let values = [];
					for (let i = 0; i < value.length; i++) {
						let v = value[i];
						if (typeof v === "string") {
							let t2 = decode2(v, !0);
							if (Array.isArray(t2)) values = values.concat(t2);
							else values.push(t2);
							continue;
						}
						values.push(v);
					}
					return values;
				}
				if (typeof value === "string") return decode2(value);
				return value;
			})
			.Encode((value) => {
				if (typeof value === "string")
					try {
						value = JSON.parse(value);
					} catch {
						throw new ValidationError("property", schema, value);
					}
				if (!exports_value2.Check(schema, value))
					throw new ValidationError("property", schema, value);
				return JSON.stringify(value);
			});
	},
	File: File2,
	Files: (options = {}) =>
		t
			.Transform(Files(options))
			.Decode((value) => {
				if (Array.isArray(value)) return value;
				return [value];
			})
			.Encode((value) => value),
	Nullable: (schema, options) => t.Union([schema, t.Null()], options),
	MaybeEmpty: (schema, options) =>
		t.Union([schema, t.Null(), t.Undefined()], options),
	Cookie: (
		properties,
		{
			domain,
			expires,
			httpOnly,
			maxAge,
			path,
			priority,
			sameSite,
			secure,
			secrets,
			sign,
			...options
		} = {},
	) => {
		let v = t.Object(properties, options);
		return (
			(v.config = {
				domain,
				expires,
				httpOnly,
				maxAge,
				path,
				priority,
				sameSite,
				secure,
				secrets,
				sign,
			}),
			v
		);
	},
	UnionEnum: (values, options = {}) => {
		let type = values.every((value) => typeof value === "string")
			? { type: "string" }
			: values.every((value) => typeof value === "number")
				? { type: "number" }
				: values.every((value) => value === null)
					? { type: "null" }
					: {};
		if (values.some((x) => typeof x === "object" && x !== null))
			throw new Error("This type does not support objects or arrays");
		return {
			default: values[0],
			...options,
			[Kind]: "UnionEnum",
			...type,
			enum: values,
		};
	},
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg = {}) =>
	ElysiaType.File({
		default: "File",
		...arg,
		extension: arg?.type,
		type: "string",
		format: "binary",
	});
t.Files = (arg = {}) =>
	ElysiaType.Files({
		...arg,
		elysiaMeta: "Files",
		default: "Files",
		extension: arg?.type,
		type: "array",
		items: { ...arg, default: "Files", type: "string", format: "binary" },
	});
t.Nullable = (schema) => ElysiaType.Nullable(schema);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
function getOrSetType(kind, func) {
	if (!exports_type2.Has(kind)) exports_type2.Set(kind, func);
	return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
var hasReturn = (fn) => {
		let fnLiteral =
				typeof fn === "object"
					? fn.fn.toString()
					: typeof fn === "string"
						? fn.toString()
						: fn,
			parenthesisEnd = fnLiteral.indexOf(")");
		if (
			fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&
			fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123
		)
			return !0;
		return fnLiteral.includes("return");
	},
	separateFunction = (code) => {
		if (code.startsWith("async")) code = code.slice(5);
		code = code.trimStart();
		let index = -1;
		if (code.charCodeAt(0) === 40) {
			if (((index = code.indexOf("=>", code.indexOf(")"))), index !== -1)) {
				let bracketEndIndex = index;
				while (bracketEndIndex > 0)
					if (code.charCodeAt(--bracketEndIndex) === 41) break;
				let body = code.slice(index + 2);
				if (body.charCodeAt(0) === 32) body = body.trimStart();
				return [
					code.slice(1, bracketEndIndex),
					body,
					{ isArrowReturn: body.charCodeAt(0) !== 123 },
				];
			}
		}
		if (/^(\w+)=>/g.test(code)) {
			if (((index = code.indexOf("=>")), index !== -1)) {
				let body = code.slice(index + 2);
				if (body.charCodeAt(0) === 32) body = body.trimStart();
				return [
					code.slice(0, index),
					body,
					{ isArrowReturn: body.charCodeAt(0) !== 123 },
				];
			}
		}
		if (code.startsWith("function")) {
			index = code.indexOf("(");
			let end = code.indexOf(")");
			return [
				code.slice(index + 1, end),
				code.slice(end + 2),
				{ isArrowReturn: !1 },
			];
		}
		let start = code.indexOf("(");
		if (start !== -1) {
			let sep = code.indexOf(
					`
`,
					2,
				),
				parameter = code.slice(0, sep),
				end = parameter.lastIndexOf(")") + 1,
				body = code.slice(sep + 1);
			return [parameter.slice(start, end), "{" + body, { isArrowReturn: !1 }];
		}
		let x = code.split(
			`
`,
			2,
		);
		return [x[0], x[1], { isArrowReturn: !1 }];
	},
	bracketPairRange = (parameter) => {
		let start = parameter.indexOf("{");
		if (start === -1) return [-1, 0];
		let end = start + 1,
			deep = 1;
		for (; end < parameter.length; end++) {
			let char = parameter.charCodeAt(end);
			if (char === 123) deep++;
			else if (char === 125) deep--;
			if (deep === 0) break;
		}
		if (deep !== 0) return [0, parameter.length];
		return [start, end + 1];
	},
	bracketPairRangeReverse = (parameter) => {
		let end = parameter.lastIndexOf("}");
		if (end === -1) return [-1, 0];
		let start = end - 1,
			deep = 1;
		for (; start >= 0; start--) {
			let char = parameter.charCodeAt(start);
			if (char === 125) deep++;
			else if (char === 123) deep--;
			if (deep === 0) break;
		}
		if (deep !== 0) return [-1, 0];
		return [start, end + 1];
	},
	removeColonAlias = (parameter) => {
		while (!0) {
			let start = parameter.indexOf(":");
			if (start === -1) break;
			let end = parameter.indexOf(",", start);
			if (end === -1) end = parameter.indexOf("}", start) - 1;
			if (end === -2) end = parameter.length;
			parameter = parameter.slice(0, start) + parameter.slice(end);
		}
		return parameter;
	},
	retrieveRootParamters = (parameter) => {
		let hasParenthesis = !1;
		if (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1);
		if (parameter.charCodeAt(0) === 123)
			(hasParenthesis = !0), (parameter = parameter.slice(1, -1));
		parameter = parameter.replace(/( |\t|\n)/g, "").trim();
		let parameters = [];
		while (!0) {
			let [start, end] = bracketPairRange(parameter);
			if (start === -1) break;
			if (
				(parameters.push(parameter.slice(0, start - 1)),
				parameter.charCodeAt(end) === 44)
			)
				end++;
			parameter = parameter.slice(end);
		}
		if (((parameter = removeColonAlias(parameter)), parameter))
			parameters = parameters.concat(parameter.split(","));
		let newParameters = [];
		for (let p of parameters) {
			if (p.indexOf(",") === -1) {
				newParameters.push(p);
				continue;
			}
			for (let q of p.split(",")) newParameters.push(q.trim());
		}
		return (parameters = newParameters), { hasParenthesis, parameters };
	},
	findParameterReference = (parameter, inference) => {
		let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
		if (!inference.query && parameters.includes("query")) inference.query = !0;
		if (!inference.headers && parameters.includes("headers"))
			inference.headers = !0;
		if (!inference.body && parameters.includes("body")) inference.body = !0;
		if (!inference.cookie && parameters.includes("cookie"))
			inference.cookie = !0;
		if (!inference.set && parameters.includes("set")) inference.set = !0;
		if (!inference.server && parameters.includes("server"))
			inference.server = !0;
		if (!inference.request && parameters.includes("request"))
			inference.request = !0;
		if (!inference.route && parameters.includes("route")) inference.route = !0;
		if (hasParenthesis) return `{ ${parameters.join(", ")} }`;
		return parameters.join(", ");
	},
	findEndIndex = (type, content, index) => {
		let newLineIndex = content.indexOf(
				type +
					`
`,
				index,
			),
			newTabIndex = content.indexOf(type + "\t", index),
			commaIndex = content.indexOf(type + ",", index),
			semicolonIndex = content.indexOf(type + ";", index),
			emptyIndex = content.indexOf(type + " ", index);
		return (
			[newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex]
				.filter((i) => i > 0)
				.sort((a, b) => a - b)[0] || -1
		);
	};
var findAlias = (type, body, depth = 0) => {
		if (depth > 5) return [];
		let aliases = [],
			content = body;
		while (!0) {
			let index = findEndIndex(" = " + type, content);
			if (index === -1) index = findEndIndex("=" + type, content);
			if (index === -1) {
				let lastIndex = content.indexOf(" = " + type);
				if (lastIndex === -1) lastIndex = content.indexOf("=" + type);
				if (lastIndex + 3 + type.length !== content.length) break;
				index = lastIndex;
			}
			let part = content.slice(0, index),
				lastPart = part.lastIndexOf(" "),
				variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
			if (variable === "}") {
				let [start, end] = bracketPairRangeReverse(part);
				aliases.push(removeColonAlias(content.slice(start, end))),
					(content = content.slice(index + 3 + type.length));
				continue;
			}
			while (variable.charCodeAt(0) === 44) variable = variable.slice(1);
			while (variable.charCodeAt(0) === 9) variable = variable.slice(1);
			if (!variable.includes("(")) aliases.push(variable);
			content = content.slice(index + 3 + type.length);
		}
		for (let alias of aliases) {
			if (alias.charCodeAt(0) === 123) continue;
			let deepAlias = findAlias(alias, body);
			if (deepAlias.length > 0) aliases.push(...deepAlias);
		}
		return aliases;
	},
	extractMainParameter = (parameter) => {
		if (!parameter) return;
		if (parameter.charCodeAt(0) !== 123) return parameter;
		if (((parameter = parameter.slice(2, -2)), !parameter.includes(","))) {
			if (parameter.includes("..."))
				return parameter.slice(parameter.indexOf("...") + 3);
			return;
		}
		let spreadIndex = parameter.indexOf("...");
		if (spreadIndex === -1) return;
		return parameter.slice(spreadIndex + 3).trimEnd();
	},
	inferBodyReference = (code, aliases, inference) => {
		let access = (type, alias) =>
			code.includes(alias + "." + type) ||
			code.includes(alias + '["' + type + '"]') ||
			code.includes(alias + "['" + type + "']");
		for (let alias of aliases) {
			if (!alias) continue;
			if (alias.charCodeAt(0) === 123) {
				let parameters = retrieveRootParamters(alias).parameters;
				if (!inference.query && parameters.includes("query"))
					inference.query = !0;
				if (!inference.headers && parameters.includes("headers"))
					inference.headers = !0;
				if (!inference.body && parameters.includes("body")) inference.body = !0;
				if (!inference.cookie && parameters.includes("cookie"))
					inference.cookie = !0;
				if (!inference.set && parameters.includes("set")) inference.set = !0;
				if (!inference.query && parameters.includes("server"))
					inference.server = !0;
				if (!inference.request && parameters.includes("request"))
					inference.request = !0;
				if (!inference.route && parameters.includes("route"))
					inference.route = !0;
				continue;
			}
			if (!inference.query && access("query", alias)) inference.query = !0;
			if (
				code.includes("return " + alias) ||
				code.includes("return " + alias + ".query")
			)
				inference.query = !0;
			if (!inference.headers && access("headers", alias))
				inference.headers = !0;
			if (!inference.body && access("body", alias)) inference.body = !0;
			if (!inference.cookie && access("cookie", alias)) inference.cookie = !0;
			if (!inference.set && access("set", alias)) inference.set = !0;
			if (!inference.server && access("server", alias)) inference.server = !0;
			if (
				inference.query &&
				inference.headers &&
				inference.body &&
				inference.cookie &&
				inference.set &&
				inference.server &&
				inference.server &&
				inference.route
			)
				break;
		}
		return aliases;
	};
var isContextPassToFunction = (context, body, inference) => {
		try {
			let captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
			captureFunction.test(body);
			let nextChar = body.charCodeAt(captureFunction.lastIndex);
			if (nextChar === 41 || nextChar === 44)
				return (
					(inference.query = !0),
					(inference.headers = !0),
					(inference.body = !0),
					(inference.cookie = !0),
					(inference.set = !0),
					(inference.server = !0),
					(inference.route = !0),
					(inference.request = !0),
					!0
				);
			return !1;
		} catch (error2) {
			return (
				console.log(
					"[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:",
				),
				console.log("--- body ---"),
				console.log(body),
				console.log("--- context ---"),
				console.log(context),
				!0
			);
		}
	},
	sucrose = (
		lifeCycle,
		inference = {
			query: !1,
			headers: !1,
			body: !1,
			cookie: !1,
			set: !1,
			server: !1,
			request: !1,
			route: !1,
		},
	) => {
		let events = [];
		if (lifeCycle.handler && typeof lifeCycle.handler === "function")
			events.push(lifeCycle.handler);
		if (lifeCycle.request?.length) events.push(...lifeCycle.request);
		if (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle);
		if (lifeCycle.parse?.length) events.push(...lifeCycle.parse);
		if (lifeCycle.error?.length) events.push(...lifeCycle.error);
		if (lifeCycle.transform?.length) events.push(...lifeCycle.transform);
		if (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle);
		if (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse);
		if (lifeCycle.afterResponse?.length)
			events.push(...lifeCycle.afterResponse);
		for (let e of events) {
			if (!e) continue;
			let event = "fn" in e ? e.fn : e;
			if (typeof event !== "function") continue;
			let [parameter, body, { isArrowReturn }] = separateFunction(
					event.toString(),
				),
				rootParameters = findParameterReference(parameter, inference),
				mainParameter = extractMainParameter(rootParameters);
			if (mainParameter) {
				let aliases = findAlias(mainParameter, body.slice(1, -1));
				aliases.splice(0, -1, mainParameter);
				let code = body;
				if (
					code.charCodeAt(0) === 123 &&
					code.charCodeAt(body.length - 1) === 125
				)
					code = code.slice(1, -1);
				if (!isContextPassToFunction(mainParameter, code, inference))
					inferBodyReference(code, aliases, inference);
				if (
					!inference.query &&
					code.includes("return " + mainParameter + ".query")
				)
					inference.query = !0;
			}
			if (
				inference.query &&
				inference.headers &&
				inference.body &&
				inference.cookie &&
				inference.set &&
				inference.server &&
				inference.request &&
				inference.route
			)
				break;
		}
		return inference;
	};
var import_cookie = __toESM(require_dist(), 1);
var hex = [];
for (let i = 48; i < 58; i++) hex[i] = i - 48;
for (let i = 0; i < 6; i++) hex[i + 65] = hex[i + 97] = i + 10;
var calcHex = (a, b) => {
		if (a in hex && b in hex) return (hex[a] << 4) | hex[b];
		return 255;
	},
	type = [
		...new Array(128).fill(0),
		...new Array(16).fill(1),
		...new Array(16).fill(2),
		...new Array(32).fill(3),
		4,
		4,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		5,
		6,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		7,
		8,
		7,
		7,
		10,
		9,
		9,
		9,
		11,
		4,
		4,
		4,
		4,
		4,
		4,
		4,
		4,
		4,
		4,
		4,
	],
	next = [
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84,
		96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	],
	mask = type.map((val) => [127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7][val]),
	decode2 = (url) => {
		let percentPosition = url.indexOf("%");
		if (percentPosition === -1) return url;
		let end = url.length - 3;
		if (percentPosition > end) return null;
		let decoded = "",
			start = 0,
			codepoint = 0,
			startOfOctets = percentPosition,
			state = 12,
			byte2;
		for (;;) {
			if (
				((byte2 = calcHex(
					url.charCodeAt(percentPosition + 1),
					url.charCodeAt(percentPosition + 2),
				)),
				(state = next[state + type[byte2]]),
				state === 0)
			)
				return null;
			if (state === 12) {
				if (
					((decoded += url.substring(start, startOfOctets)),
					(codepoint = (codepoint << 6) | (byte2 & mask[byte2])),
					codepoint > 65535)
				)
					decoded += String.fromCharCode(
						55232 + (codepoint >> 10),
						56320 + (codepoint & 1023),
					);
				else decoded += String.fromCharCode(codepoint);
				if (
					((start = percentPosition + 3),
					(percentPosition = url.indexOf("%", start)),
					percentPosition === -1)
				)
					return decoded + url.substring(start);
				if (percentPosition > end) return null;
				(startOfOctets = percentPosition), (codepoint = 0);
			} else {
				if (
					((percentPosition += 3),
					percentPosition > end || url.charCodeAt(percentPosition) !== 37)
				)
					return null;
				codepoint = (codepoint << 6) | (byte2 & mask[byte2]);
			}
		}
	};
class Cookie {
	constructor(name, jar, initial = {}) {
		(this.name = name), (this.jar = jar), (this.initial = initial);
	}
	get cookie() {
		return this.jar[this.name] ?? this.initial;
	}
	set cookie(jar) {
		if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
		this.jar[this.name] = jar;
	}
	get setCookie() {
		if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
		return this.jar[this.name];
	}
	set setCookie(jar) {
		this.cookie = jar;
	}
	get value() {
		return this.cookie.value;
	}
	set value(value) {
		this.setCookie.value = value;
	}
	get expires() {
		return this.cookie.expires;
	}
	set expires(expires) {
		this.setCookie.expires = expires;
	}
	get maxAge() {
		return this.cookie.maxAge;
	}
	set maxAge(maxAge) {
		this.setCookie.maxAge = maxAge;
	}
	get domain() {
		return this.cookie.domain;
	}
	set domain(domain) {
		this.setCookie.domain = domain;
	}
	get path() {
		return this.cookie.path;
	}
	set path(path) {
		this.setCookie.path = path;
	}
	get secure() {
		return this.cookie.secure;
	}
	set secure(secure) {
		this.setCookie.secure = secure;
	}
	get httpOnly() {
		return this.cookie.httpOnly;
	}
	set httpOnly(httpOnly) {
		this.setCookie.httpOnly = httpOnly;
	}
	get sameSite() {
		return this.cookie.sameSite;
	}
	set sameSite(sameSite) {
		this.setCookie.sameSite = sameSite;
	}
	get priority() {
		return this.cookie.priority;
	}
	set priority(priority) {
		this.setCookie.priority = priority;
	}
	get partitioned() {
		return this.cookie.partitioned;
	}
	set partitioned(partitioned) {
		this.setCookie.partitioned = partitioned;
	}
	get secrets() {
		return this.cookie.secrets;
	}
	set secrets(secrets) {
		this.setCookie.secrets = secrets;
	}
	update(config) {
		return (
			(this.setCookie = Object.assign(
				this.cookie,
				typeof config === "function" ? config(this.cookie) : config,
			)),
			this
		);
	}
	set(config) {
		return (
			(this.setCookie = Object.assign(
				{ ...this.initial, value: this.value },
				typeof config === "function" ? config(this.cookie) : config,
			)),
			this
		);
	}
	remove() {
		if (this.value === void 0) return;
		return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
	}
	toString() {
		return typeof this.value === "object"
			? JSON.stringify(this.value)
			: (this.value?.toString() ?? "");
	}
}
var createCookieJar = (set2, store, initial) => {
		if (!set2.cookie) set2.cookie = {};
		return new Proxy(store, {
			get(_, key) {
				if (key in store)
					return new Cookie(
						key,
						set2.cookie,
						Object.assign({}, initial ?? {}, store[key]),
					);
				return new Cookie(key, set2.cookie, Object.assign({}, initial));
			},
		});
	},
	parseCookie = async (
		set2,
		cookieString,
		{ secrets, sign, ...initial } = {},
	) => {
		if (!cookieString) return createCookieJar(set2, {}, initial);
		let isStringKey = typeof secrets === "string";
		if (sign && sign !== !0 && !Array.isArray(sign)) sign = [sign];
		let jar = {},
			cookies = import_cookie.parse(cookieString);
		for (let [name, v] of Object.entries(cookies)) {
			if (v === void 0) continue;
			let value = decode2(v);
			if (sign === !0 || sign?.includes(name)) {
				if (!secrets) throw new Error("No secret is provided to cookie plugin");
				if (isStringKey) {
					let temp = await unsignCookie(value, secrets);
					if (temp === !1) throw new InvalidCookieSignature(name);
					value = temp;
				} else {
					let decoded = !0;
					for (let i = 0; i < secrets.length; i++) {
						let temp = await unsignCookie(value, secrets[i]);
						if (temp !== !1) {
							(decoded = !0), (value = temp);
							break;
						}
					}
					if (!decoded) throw new InvalidCookieSignature(name);
				}
			}
			jar[name] = { value };
		}
		return createCookieJar(set2, jar, initial);
	},
	serializeCookie = (cookies) => {
		if (!cookies || !isNotEmpty(cookies)) return;
		let set2 = [];
		for (let [key, property] of Object.entries(cookies)) {
			if (!key || !property) continue;
			let value = property.value;
			if (value === void 0 || value === null) continue;
			set2.push(
				import_cookie.serialize(
					key,
					typeof value === "object" ? JSON.stringify(value) : value + "",
					property,
				),
			);
		}
		if (set2.length === 0) return;
		if (set2.length === 1) return set2[0];
		return set2;
	};
var handleFile = (response, set2) => {
		let size = response.size;
		if (
			(!set2 && size) ||
			(size &&
				set2 &&
				set2.status !== 206 &&
				set2.status !== 304 &&
				set2.status !== 412 &&
				set2.status !== 416)
		) {
			if (set2) {
				if (set2.headers instanceof Headers) {
					let setHeaders = {
						"accept-ranges": "bytes",
						"content-range": `bytes 0-${size - 1}/${size}`,
						"transfer-encoding": "chunked",
					};
					if (hasHeaderShorthand) setHeaders = set2.headers.toJSON();
					else {
						setHeaders = {};
						for (let [key, value] of set2.headers.entries())
							if (key in set2.headers) setHeaders[key] = value;
					}
					return new Response(response, {
						status: set2.status,
						headers: setHeaders,
					});
				}
				if (isNotEmpty(set2.headers))
					return new Response(response, {
						status: set2.status,
						headers: Object.assign(
							{
								"accept-ranges": "bytes",
								"content-range": `bytes 0-${size - 1}/${size}`,
								"transfer-encoding": "chunked",
							},
							set2.headers,
						),
					});
			}
			return new Response(response, {
				headers: {
					"accept-ranges": "bytes",
					"content-range": `bytes 0-${size - 1}/${size}`,
					"transfer-encoding": "chunked",
				},
			});
		}
		return new Response(response);
	},
	parseSetCookies = (headers, setCookie) => {
		if (!headers) return headers;
		headers.delete("set-cookie");
		for (let i = 0; i < setCookie.length; i++) {
			let index = setCookie[i].indexOf("=");
			headers.append(
				"set-cookie",
				`${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`,
			);
		}
		return headers;
	},
	responseToSetHeaders = (response, set2) => {
		if (set2?.headers) {
			if (response) {
				if (hasHeaderShorthand)
					Object.assign(set2.headers, response.headers.toJSON());
				else
					for (let [key, value] of response.headers.entries())
						if (key in set2.headers) set2.headers[key] = value;
			}
			if (set2.status === 200) set2.status = response.status;
			if (set2.headers["content-encoding"])
				delete set2.headers["content-encoding"];
			return set2;
		}
		if (!response) return { headers: {}, status: set2?.status ?? 200 };
		if (hasHeaderShorthand) {
			if (
				((set2 = {
					headers: response.headers.toJSON(),
					status: set2?.status ?? 200,
				}),
				set2.headers["content-encoding"])
			)
				delete set2.headers["content-encoding"];
			return set2;
		}
		set2 = { headers: {}, status: set2?.status ?? 200 };
		for (let [key, value] of response.headers.entries()) {
			if (key === "content-encoding") continue;
			if (key in set2.headers) set2.headers[key] = value;
		}
		return set2;
	},
	handleStream = async (generator, set2, request) => {
		let init = generator.next();
		if (init instanceof Promise) init = await init;
		if (init.done) {
			if (set2) return mapResponse(init.value, set2, request);
			return mapCompactResponse(init.value, request);
		}
		if (set2?.headers) {
			if (!set2.headers["transfer-encoding"])
				set2.headers["transfer-encoding"] = "chunked";
			if (!set2.headers["content-type"])
				set2.headers["content-type"] = "text/event-stream; charset=utf-8";
		} else
			set2 = {
				status: 200,
				headers: {
					"content-type": "text/event-stream; charset=utf-8",
					"transfer-encoding": "chunked",
				},
			};
		return new Response(
			new ReadableStream({
				async start(controller) {
					let end = !1;
					if (
						(request?.signal?.addEventListener("abort", () => {
							end = !0;
							try {
								controller.close();
							} catch {}
						}),
						init.value !== void 0 && init.value !== null)
					)
						if (typeof init.value === "object")
							try {
								controller.enqueue(Buffer.from(JSON.stringify(init.value)));
							} catch {
								controller.enqueue(Buffer.from(init.value.toString()));
							}
						else controller.enqueue(Buffer.from(init.value.toString()));
					for await (let chunk of generator) {
						if (end) break;
						if (chunk === void 0 || chunk === null) continue;
						if (typeof chunk === "object")
							try {
								controller.enqueue(Buffer.from(JSON.stringify(chunk)));
							} catch {
								controller.enqueue(Buffer.from(chunk.toString()));
							}
						else controller.enqueue(Buffer.from(chunk.toString()));
						await new Promise((resolve) => setTimeout(() => resolve(), 0));
					}
					try {
						controller.close();
					} catch {}
				},
			}),
			set2,
		);
	};
async function* streamResponse(response) {
	let body = response.body;
	if (!body) return;
	let reader = body.getReader(),
		decoder = new TextDecoder();
	try {
		while (!0) {
			let { done, value } = await reader.read();
			if (done) break;
			yield decoder.decode(value);
		}
	} finally {
		reader.releaseLock();
	}
}
var handleSet = (set2) => {
		if (typeof set2.status === "string") set2.status = StatusMap[set2.status];
		if (set2.cookie && isNotEmpty(set2.cookie)) {
			let cookie = serializeCookie(set2.cookie);
			if (cookie) set2.headers["set-cookie"] = cookie;
		}
		if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
			set2.headers = parseSetCookies(
				new Headers(set2.headers),
				set2.headers["set-cookie"],
			);
	},
	mergeResponseWithSetHeaders = (response, set2) => {
		if (
			response.status !== set2.status &&
			set2.status !== 200 &&
			(response.status <= 300 || response.status > 400)
		)
			response = new Response(response.body, {
				headers: response.headers,
				status: set2.status,
			});
		let isCookieSet = !1;
		if (set2.headers instanceof Headers)
			for (let key of set2.headers.keys())
				if (key === "set-cookie") {
					if (isCookieSet) continue;
					isCookieSet = !0;
					for (let cookie of set2.headers.getSetCookie())
						response.headers.append("set-cookie", cookie);
				} else response.headers.append(key, set2.headers?.get(key) ?? "");
		else
			for (let key in set2.headers)
				response.headers.append(key, set2.headers[key]);
		return response;
	},
	mapResponse = (response, set2, request) => {
		if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
			switch ((handleSet(set2), response?.constructor?.name)) {
				case "String":
					return new Response(response, set2);
				case "Array":
				case "Object":
					return Response.json(response, set2);
				case "ElysiaFile":
					return handleFile(response.value);
				case "Blob":
					return handleFile(response, set2);
				case "ElysiaCustomStatusResponse":
					return (
						(set2.status = response.code),
						mapResponse(response.response, set2, request)
					);
				case "ReadableStream":
					if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
						set2.headers["content-type"] = "text/event-stream; charset=utf-8";
					return (
						request?.signal?.addEventListener(
							"abort",
							{
								handleEvent() {
									if (request?.signal && !request?.signal?.aborted)
										response.cancel();
								},
							},
							{ once: !0 },
						),
						new Response(response, set2)
					);
				case void 0:
					if (!response) return new Response("", set2);
					return Response.json(response, set2);
				case "Response":
					if (
						((response = mergeResponseWithSetHeaders(response, set2)),
						!response.headers.has("content-length") &&
							response.headers.get("transfer-encoding") === "chunked")
					)
						return handleStream(
							streamResponse(response),
							responseToSetHeaders(response, set2),
							request,
						);
					return response;
				case "Error":
					return errorToResponse(response, set2);
				case "Promise":
					return response.then((x) => mapResponse(x, set2, request));
				case "Function":
					return mapResponse(response(), set2, request);
				case "Number":
				case "Boolean":
					return new Response(response.toString(), set2);
				case "Cookie":
					if (response instanceof Cookie)
						return new Response(response.value, set2);
					return new Response(response?.toString(), set2);
				case "FormData":
					return new Response(response, set2);
				default:
					if (response instanceof Response) {
						if (
							((response = mergeResponseWithSetHeaders(response, set2)),
							response.headers.get("transfer-encoding") === "chunked")
						)
							return handleStream(
								streamResponse(response),
								responseToSetHeaders(response, set2),
								request,
							);
						return response;
					}
					if (response instanceof Promise)
						return response.then((x) => mapResponse(x, set2));
					if (response instanceof Error) return errorToResponse(response, set2);
					if (response instanceof ElysiaCustomStatusResponse)
						return (
							(set2.status = response.code),
							mapResponse(response.response, set2, request)
						);
					if (typeof response?.next === "function")
						return handleStream(response, set2, request);
					if (typeof response?.then === "function")
						return response.then((x) => mapResponse(x, set2));
					if (typeof response?.toResponse === "function")
						return mapResponse(response.toResponse(), set2);
					if ("charCodeAt" in response) {
						let code = response.charCodeAt(0);
						if (code === 123 || code === 91) {
							if (!set2.headers["Content-Type"])
								set2.headers["Content-Type"] = "application/json";
							return new Response(JSON.stringify(response), set2);
						}
					}
					return new Response(response, set2);
			}
		if (
			response instanceof Response &&
			!response.headers.has("content-length") &&
			response.headers.get("transfer-encoding") === "chunked"
		)
			return handleStream(
				streamResponse(response),
				responseToSetHeaders(response, set2),
				request,
			);
		if (
			typeof response?.next === "function" ||
			response instanceof ReadableStream
		)
			return handleStream(response, set2, request);
		return mapCompactResponse(response, request);
	},
	mapEarlyResponse = (response, set2, request) => {
		if (response === void 0 || response === null) return;
		if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
			switch ((handleSet(set2), response?.constructor?.name)) {
				case "String":
					return new Response(response, set2);
				case "Array":
				case "Object":
					return Response.json(response, set2);
				case "ElysiaFile":
					return handleFile(response.value);
				case "Blob":
					return handleFile(response, set2);
				case "ElysiaCustomStatusResponse":
					return (
						(set2.status = response.code),
						mapEarlyResponse(response.response, set2, request)
					);
				case "ReadableStream":
					if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
						set2.headers["content-type"] = "text/event-stream; charset=utf-8";
					return (
						request?.signal?.addEventListener(
							"abort",
							{
								handleEvent() {
									if (request?.signal && !request?.signal?.aborted)
										response.cancel();
								},
							},
							{ once: !0 },
						),
						new Response(response, set2)
					);
				case void 0:
					if (!response) return;
					return Response.json(response, set2);
				case "Response":
					if (
						((response = mergeResponseWithSetHeaders(response, set2)),
						!response.headers.has("content-length") &&
							response.headers.get("transfer-encoding") === "chunked")
					)
						return handleStream(
							streamResponse(response),
							responseToSetHeaders(response, set2),
							request,
						);
					return response;
				case "Promise":
					return response.then((x) => mapEarlyResponse(x, set2));
				case "Error":
					return errorToResponse(response, set2);
				case "Function":
					return mapEarlyResponse(response(), set2);
				case "Number":
				case "Boolean":
					return new Response(response.toString(), set2);
				case "FormData":
					return new Response(response);
				case "Cookie":
					if (response instanceof Cookie)
						return new Response(response.value, set2);
					return new Response(response?.toString(), set2);
				default:
					if (response instanceof Response) {
						if (
							((response = mergeResponseWithSetHeaders(response, set2)),
							response.headers.get("transfer-encoding") === "chunked")
						)
							return handleStream(
								streamResponse(response),
								responseToSetHeaders(response, set2),
								request,
							);
						return response;
					}
					if (response instanceof Promise)
						return response.then((x) => mapEarlyResponse(x, set2));
					if (response instanceof Error) return errorToResponse(response, set2);
					if (response instanceof ElysiaCustomStatusResponse)
						return (
							(set2.status = response.code),
							mapEarlyResponse(response.response, set2, request)
						);
					if (typeof response?.next === "function")
						return handleStream(response, set2, request);
					if (typeof response?.then === "function")
						return response.then((x) => mapEarlyResponse(x, set2));
					if (typeof response?.toResponse === "function")
						return mapEarlyResponse(response.toResponse(), set2);
					if ("charCodeAt" in response) {
						let code = response.charCodeAt(0);
						if (code === 123 || code === 91) {
							if (!set2.headers["Content-Type"])
								set2.headers["Content-Type"] = "application/json";
							return new Response(JSON.stringify(response), set2);
						}
					}
					return new Response(response, set2);
			}
		else
			switch (response?.constructor?.name) {
				case "String":
					return new Response(response);
				case "Array":
				case "Object":
					return Response.json(response, set2);
				case "ElysiaFile":
					return handleFile(response.value);
				case "Blob":
					return handleFile(response, set2);
				case "ElysiaCustomStatusResponse":
					return (
						(set2.status = response.code),
						mapEarlyResponse(response.response, set2, request)
					);
				case "ReadableStream":
					return (
						request?.signal?.addEventListener(
							"abort",
							{
								handleEvent() {
									if (request?.signal && !request?.signal?.aborted)
										response.cancel();
								},
							},
							{ once: !0 },
						),
						new Response(response, {
							headers: { "Content-Type": "text/event-stream; charset=utf-8" },
						})
					);
				case void 0:
					if (!response) return new Response("");
					return new Response(JSON.stringify(response), {
						headers: { "content-type": "application/json" },
					});
				case "Response":
					if (
						!response.headers.has("content-length") &&
						response.headers.get("transfer-encoding") === "chunked"
					)
						return handleStream(
							streamResponse(response),
							responseToSetHeaders(response),
							request,
						);
					return response;
				case "Promise":
					return response.then((x) => {
						let r = mapEarlyResponse(x, set2);
						if (r !== void 0) return r;
					});
				case "Error":
					return errorToResponse(response, set2);
				case "Function":
					return mapCompactResponse(response(), request);
				case "Number":
				case "Boolean":
					return new Response(response.toString());
				case "Cookie":
					if (response instanceof Cookie)
						return new Response(response.value, set2);
					return new Response(response?.toString(), set2);
				case "FormData":
					return new Response(response);
				default:
					if (response instanceof Response) return response;
					if (response instanceof Promise)
						return response.then((x) => mapEarlyResponse(x, set2));
					if (response instanceof Error) return errorToResponse(response, set2);
					if (response instanceof ElysiaCustomStatusResponse)
						return (
							(set2.status = response.code),
							mapEarlyResponse(response.response, set2, request)
						);
					if (typeof response?.next === "function")
						return handleStream(response, set2, request);
					if (typeof response?.then === "function")
						return response.then((x) => mapEarlyResponse(x, set2));
					if (typeof response?.toResponse === "function")
						return mapEarlyResponse(response.toResponse(), set2);
					if ("charCodeAt" in response) {
						let code = response.charCodeAt(0);
						if (code === 123 || code === 91) {
							if (!set2.headers["Content-Type"])
								set2.headers["Content-Type"] = "application/json";
							return new Response(JSON.stringify(response), set2);
						}
					}
					return new Response(response);
			}
	},
	mapCompactResponse = (response, request) => {
		switch (response?.constructor?.name) {
			case "String":
				return new Response(response);
			case "Object":
			case "Array":
				return Response.json(response);
			case "ElysiaFile":
				return handleFile(response.value);
			case "Blob":
				return handleFile(response);
			case "ElysiaCustomStatusResponse":
				return mapResponse(response.response, {
					status: response.code,
					headers: {},
				});
			case "ReadableStream":
				return (
					request?.signal?.addEventListener(
						"abort",
						{
							handleEvent() {
								if (request?.signal && !request?.signal?.aborted)
									response.cancel();
							},
						},
						{ once: !0 },
					),
					new Response(response, {
						headers: { "Content-Type": "text/event-stream; charset=utf-8" },
					})
				);
			case void 0:
				if (!response) return new Response("");
				return new Response(JSON.stringify(response), {
					headers: { "content-type": "application/json" },
				});
			case "Response":
				if (response.headers.get("transfer-encoding") === "chunked")
					return handleStream(
						streamResponse(response),
						responseToSetHeaders(response),
						request,
					);
				return response;
			case "Error":
				return errorToResponse(response);
			case "Promise":
				return response.then((x) => mapCompactResponse(x, request));
			case "Function":
				return mapCompactResponse(response(), request);
			case "Number":
			case "Boolean":
				return new Response(response.toString());
			case "FormData":
				return new Response(response);
			default:
				if (response instanceof Response) return response;
				if (response instanceof Promise)
					return response.then((x) => mapCompactResponse(x, request));
				if (response instanceof Error) return errorToResponse(response);
				if (response instanceof ElysiaCustomStatusResponse)
					return mapResponse(response.response, {
						status: response.code,
						headers: {},
					});
				if (typeof response?.next === "function")
					return handleStream(response, void 0, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapResponse(x, set));
				if (typeof response?.toResponse === "function")
					return mapCompactResponse(response.toResponse());
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91)
						return new Response(JSON.stringify(response), {
							headers: { "Content-Type": "application/json" },
						});
				}
				return new Response(response);
		}
	},
	errorToResponse = (error2, set2) =>
		new Response(
			JSON.stringify({
				name: error2?.name,
				message: error2?.message,
				cause: error2?.cause,
			}),
			{
				status: set2?.status !== 200 ? (set2?.status ?? 500) : 500,
				headers: set2?.headers,
			},
		),
	createStaticHandler = (handle, hooks, setHeaders = {}) => {
		if (typeof handle === "function") return;
		let response = mapResponse(handle, { headers: setHeaders });
		if (
			!hooks.parse?.length &&
			!hooks.transform?.length &&
			!hooks.beforeHandle?.length &&
			!hooks.afterHandle?.length
		)
			return response.clone.bind(response);
	};
var WebStandardAdapter = {
	name: "web-standard",
	isWebStandard: !0,
	handler: {
		mapResponse,
		mapEarlyResponse,
		mapCompactResponse,
		createStaticHandler,
	},
	composeHandler: {
		mapResponseContext: "c.request",
		preferWebstandardHeaders: !0,
		headers: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`,
		parser: {
			json(isOptional) {
				if (isOptional)
					return `try{c.body=await c.request.json()}catch{}
`;
				return `c.body=await c.request.json()
`;
			},
			text() {
				return `c.body=await c.request.text()
`;
			},
			urlencoded() {
				return `c.body=parseQuery(await c.request.text())
`;
			},
			arrayBuffer() {
				return `c.body=await c.request.arrayBuffer()
`;
			},
			formData(isOptional) {
				let fnLiteral = `
c.body={}
`;
				if (isOptional)
					fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
				else
					fnLiteral += `const form=await c.request.formData()
`;
				return (
					fnLiteral +
					`for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`
				);
			},
		},
	},
	composeGeneralHandler: {
		parameters: "r",
		createContext(app) {
			let decoratorsLiteral = "",
				fnLiteral = "",
				defaultHeaders = app.setHeaders;
			for (let key of Object.keys(app.singleton.decorator))
				decoratorsLiteral += `,${key}: decorator['${key}']`;
			let standardHostname = app.config.handler?.standardHostname ?? !0,
				hasTrace = !!app.event.trace?.length;
			if (
				((fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?', s + 1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`),
				hasTrace)
			)
				fnLiteral += `const id=randomId()
`;
			if (
				((fnLiteral +=
					"const c={request:r,store,qi,path:p,url:u,redirect,error,set:{headers:"),
				(fnLiteral += Object.keys(defaultHeaders ?? {}).length
					? "Object.assign({}, app.setHeaders)"
					: "{}"),
				(fnLiteral += ",status:200}"),
				app.inference.server)
			)
				fnLiteral += ",get server(){return app.getServer()}";
			if (hasTrace) fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
			return (
				(fnLiteral += decoratorsLiteral),
				(fnLiteral += `}
`),
				fnLiteral
			);
		},
		websocket(app) {
			let fnLiteral = "",
				wsPaths = app.router.static.ws,
				router = app.router.http;
			if (
				(router.build(),
				Object.keys(wsPaths).length ||
					router.root.ws ||
					router.history.find((x) => x["0"] === "ws"))
			) {
				fnLiteral += "if(r.method==='GET'){switch(p){";
				for (let [path, index] of Object.entries(wsPaths))
					fnLiteral +=
						`case'${path}':` +
						(app.config.strictPath !== !0
							? `case'${getLoosePath(path)}':`
							: "") +
						`if(r.headers.get('upgrade')==='websocket')return ht[${index}].composed(c)
`;
				fnLiteral += `default:if(r.headers.get('upgrade')==='websocket'){const route=router.find('ws',p)
if(route){c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)}}break}}`;
			}
			return fnLiteral;
		},
		error404(hasEventHook, hasErrorHook) {
			let findDynamicRoute = "if(route===null)return ";
			if (hasErrorHook)
				findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
			else
				findDynamicRoute += hasEventHook
					? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})"
					: "error404.clone()";
			return {
				declare: hasErrorHook
					? ""
					: `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
				code: findDynamicRoute,
			};
		},
	},
	composeError: {
		mapResponseContext: "",
		validationError:
			"return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})",
		unknownError:
			"return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})",
	},
	listen() {
		return () => {
			throw new Error(
				"WebStandard does not support listen, you might want to export default Elysia.fetch instead",
			);
		};
	},
};
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
	if (typeof handle === "function" || handle instanceof Blob) return;
	if (
		typeof handle === "object" &&
		handle?.toString() === "[object HTMLBundle]"
	)
		return () => handle;
	let response = mapResponse(handle, { headers: setHeaders });
	if (
		!hooks.parse?.length &&
		!hooks.transform?.length &&
		!hooks.beforeHandle?.length &&
		!hooks.afterHandle?.length
	) {
		if (!response.headers.has("content-type"))
			response.headers.append("content-type", "text/plain;charset=utf-8");
		return response.clone.bind(response);
	}
};
var websocket = {
	open(ws) {
		ws.data.open?.(ws);
	},
	message(ws, message) {
		ws.data.message?.(ws, message);
	},
	drain(ws) {
		ws.data.drain?.(ws);
	},
	close(ws, code, reason) {
		ws.data.close?.(ws, code, reason);
	},
};
class ElysiaWS {
	constructor(raw, data, body = void 0) {
		(this.raw = raw),
			(this.data = data),
			(this.body = body),
			(this.validator = raw.data?.validator),
			(this.sendText = raw.sendText.bind(raw)),
			(this.sendBinary = raw.sendBinary.bind(raw)),
			(this.close = raw.close.bind(raw)),
			(this.terminate = raw.terminate.bind(raw)),
			(this.publishText = raw.publishText.bind(raw)),
			(this.publishBinary = raw.publishBinary.bind(raw)),
			(this.subscribe = raw.subscribe.bind(raw)),
			(this.unsubscribe = raw.unsubscribe.bind(raw)),
			(this.isSubscribed = raw.isSubscribed.bind(raw)),
			(this.cork = raw.cork.bind(raw)),
			(this.remoteAddress = raw.remoteAddress),
			(this.binaryType = raw.binaryType),
			(this.data = raw.data),
			(this.send = this.send.bind(this)),
			(this.ping = this.ping.bind(this)),
			(this.pong = this.pong.bind(this)),
			(this.publish = this.publish.bind(this));
	}
	get id() {
		return this.data.id;
	}
	send(data, compress) {
		if (Buffer.isBuffer(data)) return this.raw.send(data, compress);
		if (this.validator?.Check(data) === !1)
			return this.raw.send(
				new ValidationError("message", this.validator, data).message,
			);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.send(data, compress);
	}
	ping(data) {
		if (Buffer.isBuffer(data)) return this.raw.ping(data);
		if (this.validator?.Check(data) === !1)
			return this.raw.send(
				new ValidationError("message", this.validator, data).message,
			);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.ping(data);
	}
	pong(data) {
		if (Buffer.isBuffer(data)) return this.raw.pong(data);
		if (this.validator?.Check(data) === !1)
			return this.raw.send(
				new ValidationError("message", this.validator, data).message,
			);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.pong(data);
	}
	publish(topic, data, compress) {
		if (Buffer.isBuffer(data)) return this.raw.publish(topic, data, compress);
		if (this.validator?.Check(data) === !1)
			return this.raw.send(
				new ValidationError("message", this.validator, data).message,
			);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.publish(topic, data, compress);
	}
	get readyState() {
		return this.raw.readyState;
	}
}
var createWSMessageParser = (parse3) => {
		let parsers = typeof parse3 === "function" ? [parse3] : parse3;
		return async function parseMessage(ws, message) {
			if (typeof message === "string") {
				let start = message?.charCodeAt(0);
				if (start === 34 || start === 47 || start === 91 || start === 123)
					try {
						message = JSON.parse(message);
					} catch {}
				else if (isNumericString(message)) message = +message;
				else if (message === "true") message = !0;
				else if (message === "false") message = !1;
				else if (message === "null") message = null;
			}
			if (parsers)
				for (let i = 0; i < parsers.length; i++) {
					let temp = parsers[i](ws, message);
					if (temp instanceof Promise) temp = await temp;
					if (temp !== void 0) return temp;
				}
			return message;
		};
	},
	createHandleWSResponse = (validateResponse) => {
		let handleWSResponse = (ws, data) => {
			if (data instanceof Promise)
				return data.then((data2) => handleWSResponse(ws, data2));
			if (Buffer.isBuffer(data)) return ws.send(data.toString());
			if (data === void 0) return;
			let send = (datum) => {
				if (validateResponse?.Check(datum) === !1)
					return ws.send(
						new ValidationError("message", validateResponse, datum).message,
					);
				if (typeof datum === "object") return ws.send(JSON.stringify(datum));
				ws.send(datum);
			};
			if (typeof data?.next !== "function") return void send(data);
			let init = data.next();
			if (init instanceof Promise)
				return (async () => {
					let first = await init;
					if (validateResponse?.Check(first) === !1)
						return ws.send(
							new ValidationError("message", validateResponse, first).message,
						);
					if ((send(first.value), !first.done))
						for await (let datum of data) send(datum);
				})();
			if ((send(init.value), !init.done)) for (let datum of data) send(datum);
		};
		return handleWSResponse;
	};
var BunAdapter = {
	...WebStandardAdapter,
	name: "bun",
	handler: { ...WebStandardAdapter.handler, createNativeStaticHandler },
	composeHandler: {
		...WebStandardAdapter.composeHandler,
		headers: hasHeaderShorthand
			? `c.headers = c.request.headers.toJSON()
`
			: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`,
	},
	listen(app) {
		return (options, callback) => {
			if (typeof Bun === "undefined")
				throw new Error(
					".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch",
				);
			if ((app.compile(), typeof options === "string")) {
				if (!isNumericString(options))
					throw new Error("Port must be a numeric value");
				options = parseInt(options);
			}
			let fetch2 = app.fetch,
				serve =
					typeof options === "object"
						? {
								development: !isProduction,
								reusePort: !0,
								...(app.config.serve || {}),
								...(options || {}),
								static: {
									...app.router.static.http.static,
									...app.config.serve?.static,
								},
								websocket: {
									...(app.config.websocket || {}),
									...(websocket || {}),
								},
								fetch: fetch2,
								error: app.outerErrorHandler,
							}
						: {
								development: !isProduction,
								reusePort: !0,
								...(app.config.serve || {}),
								static: app.router.static.http.static,
								websocket: {
									...(app.config.websocket || {}),
									...(websocket || {}),
								},
								port: options,
								fetch: fetch2,
								error: app.outerErrorHandler,
							};
			if (((app.server = Bun?.serve(serve)), app.event.start))
				for (let i = 0; i < app.event.start.length; i++)
					app.event.start[i].fn(app);
			if (callback) callback(app.server);
			process.on("beforeExit", () => {
				if (app.server) {
					if ((app.server.stop?.(), (app.server = null), app.event.stop))
						for (let i = 0; i < app.event.stop.length; i++)
							app.event.stop[i].fn(app);
				}
			}),
				app.promisedModules.then(() => {
					Bun?.gc(!1);
				});
		};
	},
	ws(app, path, options) {
		let { parse: parse3, body, response, ...rest } = options,
			validateMessage = getSchemaValidator(body, {
				modules: app.definitions.typebox,
				models: app.definitions.type,
				normalize: app.config.normalize,
			}),
			validateResponse = getSchemaValidator(response, {
				modules: app.definitions.typebox,
				models: app.definitions.type,
				normalize: app.config.normalize,
			});
		app.route(
			"$INTERNALWS",
			path,
			async (context) => {
				let server = app.getServer(),
					{ set: set2, path: path2, qi, headers, query, params } = context;
				if (((context.validator = validateResponse), options.upgrade)) {
					if (typeof options.upgrade === "function") {
						let temp = options.upgrade(context);
						if (temp instanceof Promise) await temp;
					} else if (options.upgrade)
						Object.assign(set2.headers, options.upgrade);
				}
				if (set2.cookie && isNotEmpty(set2.cookie)) {
					let cookie = serializeCookie(set2.cookie);
					if (cookie) set2.headers["set-cookie"] = cookie;
				}
				if (
					set2.headers["set-cookie"] &&
					Array.isArray(set2.headers["set-cookie"])
				)
					set2.headers = parseSetCookies(
						new Headers(set2.headers),
						set2.headers["set-cookie"],
					);
				let handleResponse = createHandleWSResponse(validateResponse),
					parseMessage = createWSMessageParser(parse3),
					_id,
					errorHandlers = [
						...(Array.isArray(options.error) ? options.error : [options.error]),
						...(app.event.error ?? []).map((x) =>
							typeof x === "function" ? x : x.fn,
						),
					],
					handleErrors = !errorHandlers.length
						? () => {}
						: async (ws, error2) => {
								for (let handleError of errorHandlers) {
									let response2 = handleError(
										Object.assign(context, { error: error2 }),
									);
									if (response2 instanceof Promise) response2 = await response2;
									if ((await handleResponse(ws, response2), response2)) break;
								}
							};
				if (
					server?.upgrade(context.request, {
						headers: isNotEmpty(set2.headers) ? set2.headers : void 0,
						data: {
							...context,
							get id() {
								if (_id) return _id;
								return (_id = randomId());
							},
							validator: validateResponse,
							ping(data) {
								options.ping?.(data);
							},
							pong(data) {
								options.pong?.(data);
							},
							open(ws) {
								try {
									handleResponse(ws, options.open?.(new ElysiaWS(ws, context)));
								} catch (error2) {
									handleErrors(ws, error2);
								}
							},
							message: async (ws, _message) => {
								let message = await parseMessage(ws, _message);
								if (validateMessage?.Check(message) === !1)
									return void ws.send(
										new ValidationError("message", validateMessage, message)
											.message,
									);
								try {
									handleResponse(
										ws,
										options.message?.(
											new ElysiaWS(ws, context, message),
											message,
										),
									);
								} catch (error2) {
									handleErrors(ws, error2);
								}
							},
							drain(ws) {
								try {
									handleResponse(
										ws,
										options.drain?.(new ElysiaWS(ws, context)),
									);
								} catch (error2) {
									handleErrors(ws, error2);
								}
							},
							close(ws, code, reason) {
								try {
									handleResponse(
										ws,
										options.close?.(new ElysiaWS(ws, context), code, reason),
									);
								} catch (error2) {
									handleErrors(ws, error2);
								}
							},
						},
					})
				)
					return;
				return (set2.status = 400), "Expected a websocket connection";
			},
			{ ...rest, websocket: options },
		);
	},
};
var isBun2 = typeof Bun !== "undefined";
var env2 = isBun2
	? Bun.env
	: typeof process !== "undefined" && process?.env
		? process.env
		: {};
var plusRegex = /\+/g;
function parseQueryFromURL(input) {
	let result = {};
	if (typeof input !== "string") return result;
	let key = "",
		value = "",
		startingIndex = -1,
		equalityIndex = -1,
		flags = 0,
		l = input.length;
	for (let i = 0; i < l; i++)
		switch (input.charCodeAt(i)) {
			case 38:
				let hasBothKeyValuePair = equalityIndex > startingIndex;
				if (!hasBothKeyValuePair) equalityIndex = i;
				if (
					((key = input.slice(startingIndex + 1, equalityIndex)),
					hasBothKeyValuePair || key.length > 0)
				) {
					if (flags & 1) key = key.replace(plusRegex, " ");
					if (flags & 2) key = decode2(key) || key;
					if (!result[key]) {
						if (hasBothKeyValuePair) {
							if (((value = input.slice(equalityIndex + 1, i)), flags & 4))
								value = value.replace(plusRegex, " ");
							if (flags & 8) value = decode2(value) || value;
						}
						result[key] = value;
					}
				}
				(key = ""),
					(value = ""),
					(startingIndex = i),
					(equalityIndex = i),
					(flags = 0);
				break;
			case 61:
				if (equalityIndex <= startingIndex) equalityIndex = i;
				else flags |= 8;
				break;
			case 43:
				if (equalityIndex > startingIndex) flags |= 4;
				else flags |= 1;
				break;
			case 37:
				if (equalityIndex > startingIndex) flags |= 8;
				else flags |= 2;
				break;
		}
	if (startingIndex < l) {
		let hasBothKeyValuePair = equalityIndex > startingIndex;
		if (
			((key = input.slice(
				startingIndex + 1,
				hasBothKeyValuePair ? equalityIndex : l,
			)),
			hasBothKeyValuePair || key.length > 0)
		) {
			if (flags & 1) key = key.replace(plusRegex, " ");
			if (flags & 2) key = decode2(key) || key;
			if (!result[key]) {
				if (hasBothKeyValuePair) {
					if (((value = input.slice(equalityIndex + 1, l)), flags & 4))
						value = value.replace(plusRegex, " ");
					if (flags & 8) value = decode2(value) || value;
				}
				result[key] = value;
			}
		}
	}
	return result;
}
var parseQuery = (input) => {
	let result = {};
	if (typeof input !== "string") return result;
	let inputLength = input.length,
		key = "",
		value = "",
		startingIndex = -1,
		equalityIndex = -1,
		shouldDecodeKey = !1,
		shouldDecodeValue = !1,
		keyHasPlus = !1,
		valueHasPlus = !1,
		hasBothKeyValuePair = !1,
		c = 0;
	for (let i = 0; i < inputLength + 1; i++) {
		if (i !== inputLength) c = input.charCodeAt(i);
		else c = 38;
		switch (c) {
			case 38: {
				if (
					((hasBothKeyValuePair = equalityIndex > startingIndex),
					!hasBothKeyValuePair)
				)
					equalityIndex = i;
				if (
					((key = input.slice(startingIndex + 1, equalityIndex)),
					hasBothKeyValuePair || key.length > 0)
				) {
					if (keyHasPlus) key = key.replace(plusRegex, " ");
					if (shouldDecodeKey) key = decode2(key) || key;
					if (hasBothKeyValuePair) {
						if (((value = input.slice(equalityIndex + 1, i)), valueHasPlus))
							value = value.replace(plusRegex, " ");
						if (shouldDecodeValue) value = decode2(value) || value;
					}
					let currentValue = result[key];
					if (currentValue === void 0) result[key] = value;
					else if (currentValue.pop) currentValue.push(value);
					else result[key] = [currentValue, value];
				}
				(value = ""),
					(startingIndex = i),
					(equalityIndex = i),
					(shouldDecodeKey = !1),
					(shouldDecodeValue = !1),
					(keyHasPlus = !1),
					(valueHasPlus = !1);
				break;
			}
			case 61:
				if (equalityIndex <= startingIndex) equalityIndex = i;
				else shouldDecodeValue = !0;
				break;
			case 43:
				if (equalityIndex > startingIndex) valueHasPlus = !0;
				else keyHasPlus = !0;
				break;
			case 37:
				if (equalityIndex > startingIndex) shouldDecodeValue = !0;
				else shouldDecodeKey = !0;
				break;
		}
	}
	return result;
};
var ELYSIA_TRACE = Symbol("ElysiaTrace"),
	createProcess = () => {
		let { promise, resolve } = Promise.withResolvers(),
			{ promise: end, resolve: resolveEnd } = Promise.withResolvers(),
			{ promise: error2, resolve: resolveError } = Promise.withResolvers(),
			callbacks = [],
			callbacksEnd = [];
		return [
			(callback) => {
				if (callback) callbacks.push(callback);
				return promise;
			},
			(process2) => {
				let processes = [],
					resolvers = [],
					groupError = null;
				for (let i = 0; i < (process2.total ?? 0); i++) {
					let { promise: promise2, resolve: resolve2 } =
							Promise.withResolvers(),
						{ promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(),
						{ promise: error22, resolve: resolveError2 } =
							Promise.withResolvers(),
						callbacks2 = [],
						callbacksEnd2 = [];
					processes.push((callback) => {
						if (callback) callbacks2.push(callback);
						return promise2;
					}),
						resolvers.push((process22) => {
							let result2 = {
								...process22,
								end: end2,
								error: error22,
								index: i,
								onStop(callback) {
									if (callback) callbacksEnd2.push(callback);
									return end2;
								},
							};
							resolve2(result2);
							for (let i2 = 0; i2 < callbacks2.length; i2++)
								callbacks2[i2](result2);
							return (error3 = null) => {
								let end3 = performance.now();
								if (error3) groupError = error3;
								let detail = {
									end: end3,
									error: error3,
									get elapsed() {
										return end3 - process22.begin;
									},
								};
								for (let i2 = 0; i2 < callbacksEnd2.length; i2++)
									callbacksEnd2[i2](detail);
								resolveEnd2(end3), resolveError2(error3);
							};
						});
				}
				let result = {
					...process2,
					end,
					error: error2,
					onEvent(callback) {
						for (let i = 0; i < processes.length; i++) processes[i](callback);
					},
					onStop(callback) {
						if (callback) callbacksEnd.push(callback);
						return end;
					},
				};
				resolve(result);
				for (let i = 0; i < callbacks.length; i++) callbacks[i](result);
				return {
					resolveChild: resolvers,
					resolve(error22 = null) {
						let end2 = performance.now();
						if (!error22 && groupError) error22 = groupError;
						let detail = {
							end: end2,
							error: error22,
							get elapsed() {
								return end2 - process2.begin;
							},
						};
						for (let i = 0; i < callbacksEnd.length; i++)
							callbacksEnd[i](detail);
						resolveEnd(end2), resolveError(error22);
					},
				};
			},
		];
	},
	createTracer = (traceListener) => {
		return (context) => {
			let [onRequest, resolveRequest] = createProcess(),
				[onParse, resolveParse] = createProcess(),
				[onTransform, resolveTransform] = createProcess(),
				[onBeforeHandle, resolveBeforeHandle] = createProcess(),
				[onHandle, resolveHandle] = createProcess(),
				[onAfterHandle, resolveAfterHandle] = createProcess(),
				[onError, resolveError] = createProcess(),
				[onMapResponse, resolveMapResponse] = createProcess(),
				[onAfterResponse, resolveAfterResponse] = createProcess();
			return (
				traceListener({
					id: context[ELYSIA_REQUEST_ID],
					context,
					set: context.set,
					onRequest,
					onParse,
					onTransform,
					onBeforeHandle,
					onHandle,
					onAfterHandle,
					onMapResponse,
					onAfterResponse,
					onError,
				}),
				{
					request: resolveRequest,
					parse: resolveParse,
					transform: resolveTransform,
					beforeHandle: resolveBeforeHandle,
					handle: resolveHandle,
					afterHandle: resolveAfterHandle,
					error: resolveError,
					mapResponse: resolveMapResponse,
					afterResponse: resolveAfterResponse,
				}
			);
		};
	};
var TypeBoxSymbol = {
		optional: Symbol.for("TypeBox.Optional"),
		kind: Symbol.for("TypeBox.Kind"),
	},
	isOptional = (validator) => {
		if (!validator) return !1;
		let schema = validator?.schema;
		if (schema?.[TypeBoxSymbol.kind] === "Import")
			return validator.References().some(isOptional);
		return !!schema && TypeBoxSymbol.optional in schema;
	},
	allocateIf = (value, condition) => (condition ? value : ""),
	defaultParsers = [
		"json",
		"text",
		"urlencoded",
		"arrayBuffer",
		"formdata",
		"application/json",
		"text/plain",
		"application/x-www-form-urlencoded",
		"application/octet-stream",
		"multipart/form-data",
	],
	hasAdditionalProperties = (_schema) => {
		if (!_schema) return !1;
		let schema = _schema?.schema ?? _schema;
		if (schema[TypeBoxSymbol.kind] === "Import" && _schema.References())
			return _schema.References().some(hasAdditionalProperties);
		if (schema.anyOf) return schema.anyOf.some(hasAdditionalProperties);
		if (schema.someOf) return schema.someOf.some(hasAdditionalProperties);
		if (schema.allOf) return schema.allOf.some(hasAdditionalProperties);
		if (schema.not) return schema.not.some(hasAdditionalProperties);
		if (schema.type === "object") {
			let properties = schema.properties;
			if ("additionalProperties" in schema) return schema.additionalProperties;
			if ("patternProperties" in schema) return !1;
			for (let key of Object.keys(properties)) {
				let property = properties[key];
				if (property.type === "object") {
					if (hasAdditionalProperties(property)) return !0;
				} else if (property.anyOf) {
					for (let i = 0; i < property.anyOf.length; i++)
						if (hasAdditionalProperties(property.anyOf[i])) return !0;
				}
				return property.additionalProperties;
			}
			return !1;
		}
		return !1;
	},
	createReport = ({ context = "c", trace = [], addFn }) => {
		if (!trace.length)
			return () => {
				return {
					resolveChild() {
						return () => {};
					},
					resolve() {},
				};
			};
		for (let i = 0; i < trace.length; i++)
			addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
		return (event, { name, total = 0 } = {}) => {
			if (!name) name = "anonymous";
			let reporter = event === "error" ? "reportErr" : "report";
			for (let i = 0; i < trace.length; i++)
				addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
			return {
				resolve() {
					for (let i = 0; i < trace.length; i++)
						addFn(`${reporter}${i}.resolve()
`);
				},
				resolveChild(name2) {
					for (let i = 0; i < trace.length; i++)
						addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
					return (binding) => {
						for (let i = 0; i < trace.length; i++)
							if (binding)
								addFn(
									`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`,
								);
							else
								addFn(`${reporter}Child${i}?.()
`);
					};
				},
			};
		};
	},
	composeValidationFactory = ({
		injectResponse = "",
		normalize = !1,
		validator,
		encodeSchema = !1,
	}) => ({
		composeValidation: (type2, value = `c.${type2}`) =>
			`c.set.status=422;throw new ValidationError('${type2}',validator.${type2},${value})`,
		composeResponseValidation: (name = "r") => {
			let code =
				injectResponse +
				`
`;
			code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}const isResponse=${name} instanceof Response
switch(c.set.status){`;
			for (let [status, value] of Object.entries(validator.response)) {
				if (
					((code += `
case ${status}:if(!isResponse){`),
					normalize && "Clean" in value && !hasAdditionalProperties(value))
				)
					code += `${name}=validator.response['${status}'].Clean(${name})
`;
				if (
					encodeSchema &&
					(value.hasTransform || typeof value.Decode === "function")
				)
					code += `${name}=validator.response['${status}'].Encode(${name})
`;
				(code += `if(validator.response['${status}'].Check(${name})===false){c.set.status=422
throw new ValidationError('response',validator.response['${status}'],${name})}c.set.status = ${status}}
`),
					(code += `break
`);
			}
			return code + "}";
		},
	}),
	KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, _schema) => {
		if (!_schema) return;
		let schema = _schema.schema ?? _schema;
		if (schema[TypeBoxSymbol.kind] === "Import")
			return _schema
				.References()
				.some((schema2) => hasProperty(expectedProperty, schema2));
		if (schema.type === "object") {
			let properties = schema.properties;
			if (!properties) return !1;
			for (let key of Object.keys(properties)) {
				let property = properties[key];
				if (expectedProperty in property) return !0;
				if (property.type === "object") {
					if (hasProperty(expectedProperty, property)) return !0;
				} else if (property.anyOf) {
					for (let i = 0; i < property.anyOf.length; i++)
						if (hasProperty(expectedProperty, property.anyOf[i])) return !0;
				}
			}
			return !1;
		}
		return expectedProperty in schema;
	},
	TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema) => {
		if (!schema) return !1;
		if (
			schema.$ref &&
			schema.$defs &&
			schema.$ref in schema.$defs &&
			hasTransform(schema.$defs[schema.$ref])
		)
			return !0;
		if (schema.oneOf) {
			for (let i = 0; i < schema.oneOf.length; i++)
				if (hasTransform(schema.oneOf[i])) return !0;
		}
		if (schema.anyOf) {
			for (let i = 0; i < schema.anyOf.length; i++)
				if (hasTransform(schema.anyOf[i])) return !0;
		}
		if (schema.allOf) {
			for (let i = 0; i < schema.allOf.length; i++)
				if (hasTransform(schema.allOf[i])) return !0;
		}
		if (schema.not && hasTransform(schema.not)) return !0;
		if (schema.type === "object" && schema.properties) {
			let properties = schema.properties;
			for (let key of Object.keys(properties)) {
				let property = properties[key];
				if (hasTransform(property)) return !0;
				if (
					property.type === "array" &&
					property.items &&
					hasTransform(property.items)
				)
					return !0;
			}
		}
		if (schema.type === "array" && schema.items && hasTransform(schema.items))
			return !0;
		return TransformSymbol in schema;
	},
	matchFnReturn = /(?:return|=>) \S+\(/g,
	isAsyncName = (v) => {
		return (v?.fn ?? v).constructor.name === "AsyncFunction";
	},
	isAsync = (v) => {
		let fn = v?.fn ?? v;
		if (fn.constructor.name === "AsyncFunction") return !0;
		let literal = fn.toString();
		if (literal.includes("=> response.clone(")) return !1;
		if (literal.includes("await")) return !0;
		if (literal.includes("async")) return !0;
		if (literal.includes("=>response.clone(")) return !1;
		return !!literal.match(matchFnReturn);
	},
	isGenerator = (v) => {
		let fn = v?.fn ?? v;
		return (
			fn.constructor.name === "AsyncGeneratorFunction" ||
			fn.constructor.name === "GeneratorFunction"
		);
	},
	composeHandler = ({
		app,
		path,
		method,
		hooks,
		validator,
		handler,
		allowMeta = !1,
		inference,
		asManifest = !1,
	}) => {
		let adapter = app["~adapter"].composeHandler,
			adapterHandler = app["~adapter"].handler,
			isHandleFn = typeof handler === "function";
		if (!isHandleFn) {
			if (
				((handler = adapterHandler.mapResponse(handler, {
					headers: app.setHeaders ?? {},
				})),
				hooks.parse?.length &&
					hooks.transform?.length &&
					hooks.beforeHandle?.length &&
					hooks.afterHandle?.length)
			) {
				if (handler instanceof Response)
					return Function("a", "return function(){return a.clone()}")(handler);
				return Function("a", "return function(){return a}")(handler);
			}
		}
		let handle = isHandleFn ? "handler(c)" : "handler",
			hasAfterResponse = !!hooks.afterResponse?.length,
			hasTrace = !!hooks.trace?.length,
			fnLiteral = "";
		if (
			((inference = sucrose(Object.assign({}, hooks, { handler }), inference)),
			adapter.declare)
		) {
			let literal = adapter.declare(inference);
			if (literal) fnLiteral += literal;
		}
		if (inference.server)
			fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
		validator.createBody?.(),
			validator.createQuery?.(),
			validator.createHeaders?.(),
			validator.createParams?.(),
			validator.createCookie?.(),
			validator.createResponse?.();
		let hasValidation =
				validator.body ||
				validator.headers ||
				validator.params ||
				validator.query ||
				validator.cookie ||
				validator.response,
			hasQuery = inference.query || !!validator.query,
			requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none",
			hasBody =
				method !== "$INTERNALWS" &&
				method !== "GET" &&
				method !== "HEAD" &&
				(inference.body || !!validator.body || !!hooks.parse?.length) &&
				!requestNoBody;
		if (hasBody)
			fnLiteral += `let isParsing=false
`;
		let defaultHeaders = app.setHeaders,
			hasDefaultHeaders =
				defaultHeaders && !!Object.keys(defaultHeaders).length,
			hasHeaders =
				inference.headers ||
				validator.headers ||
				(adapter.preferWebstandardHeaders !== !0 && inference.body),
			hasCookie = inference.cookie || !!validator.cookie,
			cookieValidator = hasCookie
				? getCookieValidator({
						modules: app.definitions.typebox,
						validator: validator.cookie,
						defaultConfig: app.config.cookie,
						dynamic: !!app.config.aot,
						config: validator.cookie?.config ?? {},
						models: app.definitions.type,
					})
				: void 0,
			cookieMeta = cookieValidator?.config,
			encodeCookie = "";
		if (cookieMeta?.sign) {
			if (!cookieMeta.secrets)
				throw new Error(
					`t.Cookie required secret which is not set in (${method}) ${path}.`,
				);
			let secret = !cookieMeta.secrets
				? void 0
				: typeof cookieMeta.secrets === "string"
					? cookieMeta.secrets
					: cookieMeta.secrets[0];
			if (
				((encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`),
				cookieMeta.sign === !0)
			)
				encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
			else
				for (let name of cookieMeta.sign)
					encodeCookie += `if(_setCookie['${name}']?.value){c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')}`;
			encodeCookie += `}
`;
		}
		let normalize = app.config.normalize,
			encodeSchema = app.config.experimental?.encodeSchema,
			{ composeValidation, composeResponseValidation } =
				composeValidationFactory({ normalize, validator, encodeSchema });
		if (hasHeaders) fnLiteral += adapter.headers;
		if (hasTrace)
			fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
		let report = createReport({
			trace: hooks.trace,
			addFn: (word) => {
				fnLiteral += word;
			},
		});
		if (((fnLiteral += "try{"), hasCookie)) {
			let get = (name, defaultValue) => {
					let value = cookieMeta?.[name] ?? defaultValue;
					if (!value)
						return typeof defaultValue === "string"
							? `${name}:"${defaultValue}",`
							: `${name}:${defaultValue},`;
					if (typeof value === "string") return `${name}:'${value}',`;
					if (value instanceof Date)
						return `${name}: new Date(${value.getTime()}),`;
					return `${name}:${value},`;
				},
				options = cookieMeta
					? `{secrets:${cookieMeta.secrets !== void 0 ? (typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]") : "undefined"},sign:${cookieMeta.sign === !0 ? !0 : cookieMeta.sign !== void 0 ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` +
						get("domain") +
						get("expires") +
						get("httpOnly") +
						get("maxAge") +
						get("path", "/") +
						get("priority") +
						get("sameSite") +
						get("secure") +
						"}"
					: "undefined";
			if (hasHeaders)
				fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
			else
				fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
		}
		if (hasQuery) {
			let destructured = [];
			if (validator.query && validator.query.schema.type === "object") {
				let properties = validator.query.schema.properties;
				if (!hasAdditionalProperties(validator.query))
					for (let [key, _value] of Object.entries(properties)) {
						let value = _value,
							isArray =
								value.type === "array" ||
								!!value.anyOf?.some(
									(v) => v.type === "string" && v.format === "ArrayString",
								);
						if (
							value &&
							TypeBoxSymbol.optional in value &&
							value.type === "array" &&
							value.items
						)
							value = value.items;
						let { type: type2, anyOf } = value;
						destructured.push({
							key,
							isArray,
							isNestedObjectArray:
								(isArray && value.items?.type === "object") ||
								!!value.items?.anyOf?.some(
									(x) => x.type === "object" || x.type === "array",
								),
							isObject:
								type2 === "object" ||
								anyOf?.some(
									(v) => v.type === "string" && v.format === "ArrayString",
								),
							anyOf: !!anyOf,
						});
					}
			}
			if (!destructured.length)
				fnLiteral +=
					"if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url.slice(c.qi + 1))}";
			else {
				fnLiteral += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi + 1)
`;
				let index = 0;
				for (let {
					key,
					isArray,
					isObject: isObject2,
					isNestedObjectArray,
					anyOf,
				} of destructured) {
					let init2 =
						(index === 0 ? "let " : "") +
						`memory=url.indexOf('&${key}=')
let a${index}
`;
					if (isArray)
						if (((fnLiteral += init2), isNestedObjectArray))
							fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${index}+=temp
if(memory===-1)break
memory=url.indexOf('&${key}=',memory)
if(memory===-1)break}try{if(a${index}.charCodeAt(0)===91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
						else
							fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(temp)}
}memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
					else if (isObject2)
						fnLiteral +=
							init2 +
							`if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
					else {
						if (
							((fnLiteral +=
								init2 +
								`if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`),
							anyOf)
						)
							fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
						fnLiteral += "}}";
					}
					index++,
						(fnLiteral += `
`);
				}
				(fnLiteral +=
					"c.query={" +
					destructured
						.map(({ key }, index2) => `'${key}':a${index2}`)
						.join(",") +
					"}"),
					(fnLiteral += `} else c.query = {}
`);
			}
		}
		let isAsyncHandler = typeof handler === "function" && isAsync(handler),
			saveResponse =
				hasTrace || hooks.afterResponse?.length ? "c.response= " : "",
			maybeAsync =
				hasCookie ||
				hasBody ||
				isAsyncHandler ||
				!!hooks.parse?.length ||
				!!hooks.afterHandle?.some(isAsync) ||
				!!hooks.beforeHandle?.some(isAsync) ||
				!!hooks.transform?.some(isAsync) ||
				!!hooks.mapResponse?.some(isAsync),
			maybeStream =
				(typeof handler === "function" ? isGenerator(handler) : !1) ||
				!!hooks.beforeHandle?.some(isGenerator) ||
				!!hooks.afterHandle?.some(isGenerator) ||
				!!hooks.transform?.some(isGenerator),
			hasSet =
				inference.cookie ||
				inference.set ||
				hasHeaders ||
				hasTrace ||
				validator.response ||
				(isHandleFn && hasDefaultHeaders) ||
				maybeStream,
			mapResponseContext = adapter.mapResponseContext
				? `,${adapter.mapResponseContext}`
				: "";
		if (hasTrace || inference.route)
			fnLiteral += `c.route=\`${path}\`
`;
		let parseReporter = report("parse", { total: hooks.parse?.length });
		if (hasBody) {
			let isOptionalBody = isOptional(validator.body),
				hasBodyInference =
					!!hooks.parse?.length || inference.body || validator.body;
			if (adapter.parser.declare) fnLiteral += adapter.parser.declare;
			fnLiteral += `
isParsing=true
`;
			let parser =
				typeof hooks.parse === "string"
					? hooks.parse
					: Array.isArray(hooks.parse) && hooks.parse.length === 1
						? typeof hooks.parse[0] === "string"
							? hooks.parse[0]
							: typeof hooks.parse[0].fn === "string"
								? hooks.parse[0].fn
								: void 0
						: void 0;
			if (parser && defaultParsers.includes(parser)) {
				let reporter = report("parse", { total: hooks.parse?.length });
				switch (parser) {
					case "json":
					case "application/json":
						fnLiteral += adapter.parser.json(isOptionalBody);
						break;
					case "text":
					case "text/plain":
						fnLiteral += adapter.parser.text(isOptionalBody);
						break;
					case "urlencoded":
					case "application/x-www-form-urlencoded":
						fnLiteral += adapter.parser.urlencoded(isOptionalBody);
						break;
					case "arrayBuffer":
					case "application/octet-stream":
						fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
						break;
					case "formdata":
					case "multipart/form-data":
						fnLiteral += adapter.parser.formData(isOptionalBody);
						break;
					default:
						if (parser[0] in app["~parser"])
							(fnLiteral += hasHeaders
								? "let contentType = c.headers['content-type']"
								: "let contentType = c.request.headers.get('content-type')"),
								(fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`),
								(fnLiteral += `let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`);
						break;
				}
				reporter.resolve();
			} else if (hasBodyInference) {
				if (
					((fnLiteral += `
`),
					(fnLiteral += hasHeaders
						? "let contentType = c.headers['content-type']"
						: "let contentType = c.request.headers.get('content-type')"),
					(fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`),
					hooks.parse?.length)
				)
					fnLiteral += `let used=false
`;
				let reporter = report("parse", { total: hooks.parse?.length }),
					hasDefaultParser = !1;
				if (hooks.parse)
					for (let i = 0; i < hooks.parse.length; i++) {
						let name = `bo${i}`;
						if (i !== 0)
							fnLiteral += `
if(!used){`;
						if (typeof hooks.parse[i].fn === "string") {
							let endUnit = reporter.resolveChild(hooks.parse[i].fn);
							switch (hooks.parse[i].fn) {
								case "json":
								case "application/json":
									(hasDefaultParser = !0),
										(fnLiteral += adapter.parser.json(isOptionalBody));
									break;
								case "text":
								case "text/plain":
									(hasDefaultParser = !0),
										(fnLiteral += adapter.parser.text(isOptionalBody));
									break;
								case "urlencoded":
								case "application/x-www-form-urlencoded":
									(hasDefaultParser = !0),
										(fnLiteral += adapter.parser.urlencoded(isOptionalBody));
									break;
								case "arrayBuffer":
								case "application/octet-stream":
									(hasDefaultParser = !0),
										(fnLiteral += adapter.parser.arrayBuffer(isOptionalBody));
									break;
								case "formdata":
								case "multipart/form-data":
									(hasDefaultParser = !0),
										(fnLiteral += adapter.parser.formData(isOptionalBody));
									break;
								default:
									fnLiteral += `${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}
`;
							}
							endUnit();
						} else {
							let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
							(fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`),
								endUnit();
						}
						if (i !== 0) fnLiteral += "}";
						if (hasDefaultParser) break;
					}
				if ((reporter.resolve(), !hasDefaultParser)) {
					if (hooks.parse?.length)
						fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
					(fnLiteral += "switch(contentType){"),
						(fnLiteral +=
							`case 'application/json':
` +
							adapter.parser.json(isOptionalBody) +
							`break
case 'text/plain':` +
							adapter.parser.text(isOptionalBody) +
							`break
case 'application/x-www-form-urlencoded':` +
							adapter.parser.urlencoded(isOptionalBody) +
							`break
case 'application/octet-stream':` +
							adapter.parser.arrayBuffer(isOptionalBody) +
							`break
case 'multipart/form-data':` +
							adapter.parser.formData(isOptionalBody) +
							`break
`);
					for (let key of Object.keys(app["~parser"]))
						fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
					if (hooks.parse?.length) fnLiteral += "}";
					fnLiteral += "}";
				}
			}
			(fnLiteral += `
delete c.contentType`),
				(fnLiteral += `
isParsing=false
`);
		}
		if ((parseReporter.resolve(), hooks?.transform)) {
			let reporter = report("transform", { total: hooks.transform.length });
			if (hooks.transform.length)
				fnLiteral += `let transformed
`;
			for (let i = 0; i < hooks.transform.length; i++) {
				let transform2 = hooks.transform[i],
					endUnit = reporter.resolveChild(transform2.fn.name);
				if (
					((fnLiteral += isAsync(transform2)
						? `transformed=await e.transform[${i}](c)
`
						: `transformed=e.transform[${i}](c)
`),
					transform2.subType === "mapDerive")
				)
					fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
				else
					fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
				endUnit();
			}
			reporter.resolve();
		}
		if (validator) {
			if (validator.headers) {
				if (
					normalize &&
					"Clean" in validator.headers &&
					!hasAdditionalProperties(validator.headers)
				)
					fnLiteral += `c.headers=validator.headers.Clean(c.headers);
`;
				if (hasProperty("default", validator.headers))
					for (let [key, value] of Object.entries(
						exports_value2.Default(validator.headers.schema, {}),
					)) {
						let parsed =
							typeof value === "object"
								? JSON.stringify(value)
								: typeof value === "string"
									? `'${value}'`
									: value;
						if (parsed !== void 0)
							fnLiteral += `c.headers['${key}']??=${parsed}
`;
					}
				if (isOptional(validator.headers))
					fnLiteral += "if(isNotEmpty(c.headers)){";
				if (
					((fnLiteral +=
						"if(validator.headers.Check(c.headers) === false){" +
						composeValidation("headers") +
						"}"),
					hasTransform(validator.headers.schema))
				)
					fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
				if (isOptional(validator.headers)) fnLiteral += "}";
			}
			if (validator.params) {
				if (hasProperty("default", validator.params))
					for (let [key, value] of Object.entries(
						exports_value2.Default(validator.params.schema, {}),
					)) {
						let parsed =
							typeof value === "object"
								? JSON.stringify(value)
								: typeof value === "string"
									? `'${value}'`
									: value;
						if (parsed !== void 0)
							fnLiteral += `c.params['${key}']??=${parsed}
`;
					}
				if (
					((fnLiteral +=
						"if(validator.params.Check(c.params)===false){" +
						composeValidation("params") +
						"}"),
					hasTransform(validator.params.schema))
				)
					fnLiteral += `c.params=validator.params.Decode(c.params)
`;
			}
			if (validator.query) {
				if (
					normalize &&
					"Clean" in validator.query &&
					!hasAdditionalProperties(validator.query)
				)
					fnLiteral += `c.query=validator.query.Clean(c.query)
`;
				if (hasProperty("default", validator.query))
					for (let [key, value] of Object.entries(
						exports_value2.Default(validator.query.schema, {}),
					)) {
						let parsed =
							typeof value === "object"
								? JSON.stringify(value)
								: typeof value === "string"
									? `'${value}'`
									: value;
						if (parsed !== void 0)
							fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
					}
				if (isOptional(validator.query))
					fnLiteral += "if(isNotEmpty(c.query)){";
				if (
					((fnLiteral +=
						"if(validator.query.Check(c.query)===false){" +
						composeValidation("query") +
						"}"),
					hasTransform(validator.query.schema))
				)
					fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
				if (isOptional(validator.query)) fnLiteral += "}";
			}
			if (validator.body) {
				if (
					normalize &&
					"Clean" in validator.body &&
					!hasAdditionalProperties(validator.body)
				)
					fnLiteral += `c.body=validator.body.Clean(c.body)
`;
				let doesHaveTransform = hasTransform(validator.body.schema);
				if (doesHaveTransform || isOptional(validator.body))
					fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
				if (hasProperty("default", validator.body)) {
					let schema = validator.body.schema,
						value = exports_value2.Default(
							schema,
							schema.type === "object" ||
								(schema[TypeBoxSymbol.kind] === "Import" &&
									schema.$defs[schema.$ref][TypeBoxSymbol.kind] === "Object")
								? {}
								: void 0,
						),
						parsed =
							typeof value === "object"
								? JSON.stringify(value)
								: typeof value === "string"
									? `'${value}'`
									: value;
					if (
						((fnLiteral += "if(validator.body.Check(c.body)===false){"),
						value !== void 0 && value !== null)
					)
						fnLiteral += `if(typeof c.body==='object')c.body=Object.assign(${parsed},c.body)
else c.body=${parsed}
`;
					if (isOptional(validator.body))
						fnLiteral +=
							"if(isNotEmptyObject&&validator.body.Check(c.body)===false){" +
							composeValidation("body") +
							"}";
					else
						fnLiteral +=
							"if(validator.body.Check(c.body)===false){" +
							composeValidation("body") +
							"}";
					fnLiteral += "}";
				} else if (isOptional(validator.body))
					fnLiteral +=
						"if(isNotEmptyObject&&validator.body.Check(c.body)===false){" +
						composeValidation("body") +
						"}";
				else
					fnLiteral +=
						"if(validator.body.Check(c.body)===false){" +
						composeValidation("body") +
						"}";
				if (doesHaveTransform)
					fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
			}
			if (
				cookieValidator &&
				isNotEmpty(
					cookieValidator?.schema?.properties ??
						cookieValidator?.schema?.schema ??
						{},
				)
			) {
				if (
					((fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`),
					hasProperty("default", cookieValidator))
				)
					for (let [key, value] of Object.entries(
						exports_value2.Default(cookieValidator.schema, {}),
					))
						fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
				if (isOptional(validator.cookie))
					fnLiteral += "if(isNotEmpty(c.cookie)){";
				if (
					((fnLiteral +=
						"if(validator.cookie.Check(cookieValue)===false){" +
						composeValidation("cookie", "cookieValue") +
						"}"),
					hasTransform(validator.cookie.schema))
				)
					fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
				if (isOptional(validator.cookie)) fnLiteral += "}";
			}
		}
		if (hooks?.beforeHandle) {
			let reporter = report("beforeHandle", {
					total: hooks.beforeHandle.length,
				}),
				hasResolve = !1;
			for (let i = 0; i < hooks.beforeHandle.length; i++) {
				let beforeHandle = hooks.beforeHandle[i],
					endUnit = reporter.resolveChild(beforeHandle.fn.name),
					returning = hasReturn(beforeHandle);
				if (
					beforeHandle.subType === "resolve" ||
					beforeHandle.subType === "mapResolve"
				) {
					if (!hasResolve)
						(hasResolve = !0),
							(fnLiteral += `
let resolved
`);
					if (
						((fnLiteral += isAsync(beforeHandle)
							? `resolved=await e.beforeHandle[${i}](c);
`
							: `resolved=e.beforeHandle[${i}](c);
`),
						beforeHandle.subType === "mapResolve")
					)
						fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request = c.request
resolved.store = c.store
resolved.qi = c.qi
resolved.path = c.path
resolved.url = c.url
resolved.redirect = c.redirect
resolved.set = c.set
resolved.error = c.error
c = resolved}`;
					else
						fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
				} else if (!returning)
					(fnLiteral += isAsync(beforeHandle)
						? `await e.beforeHandle[${i}](c)
`
						: `e.beforeHandle[${i}](c)
`),
						endUnit();
				else {
					if (
						((fnLiteral += isAsync(beforeHandle)
							? `be=await e.beforeHandle[${i}](c)
`
							: `be=e.beforeHandle[${i}](c)
`),
						endUnit("be"),
						(fnLiteral += "if(be!==undefined){"),
						reporter.resolve(),
						hooks.afterHandle?.length)
					) {
						report("handle", {
							name: isHandleFn ? handler.name : void 0,
						}).resolve();
						let reporter2 = report("afterHandle", {
							total: hooks.afterHandle.length,
						});
						for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
							let hook = hooks.afterHandle[i2],
								returning2 = hasReturn(hook),
								endUnit2 = reporter2.resolveChild(hook.fn.name);
							if (
								((fnLiteral += `c.response = be
`),
								!returning2)
							)
								fnLiteral += isAsync(hook.fn)
									? `await e.afterHandle[${i2}](c, be)
`
									: `e.afterHandle[${i2}](c, be)
`;
							else
								(fnLiteral += isAsync(hook.fn)
									? `af = await e.afterHandle[${i2}](c)
`
									: `af = e.afterHandle[${i2}](c)
`),
									(fnLiteral += `if(af!==undefined) c.response=be=af
`);
							endUnit2("af");
						}
						reporter2.resolve();
					}
					if (validator.response) fnLiteral += composeResponseValidation("be");
					let mapResponseReporter = report("mapResponse", {
						total: hooks.mapResponse?.length,
					});
					if (hooks.mapResponse?.length) {
						fnLiteral += `c.response=be
`;
						for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
							let mapResponse2 = hooks.mapResponse[i2],
								endUnit2 = mapResponseReporter.resolveChild(
									mapResponse2.fn.name,
								);
							(fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`),
								endUnit2();
						}
					}
					mapResponseReporter.resolve(),
						(fnLiteral += encodeCookie),
						(fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`);
				}
			}
			reporter.resolve();
		}
		if (hooks.afterHandle?.length) {
			let handleReporter = report("handle", {
				name: isHandleFn ? handler.name : void 0,
			});
			if (hooks.afterHandle.length)
				fnLiteral += isAsyncHandler
					? `let r=c.response=await ${handle}
`
					: `let r=c.response=${handle}
`;
			else
				fnLiteral += isAsyncHandler
					? `let r=await ${handle}
`
					: `let r=${handle}
`;
			handleReporter.resolve();
			let reporter = report("afterHandle", { total: hooks.afterHandle.length });
			for (let i = 0; i < hooks.afterHandle.length; i++) {
				let hook = hooks.afterHandle[i],
					returning = hasReturn(hook),
					endUnit = reporter.resolveChild(hook.fn.name);
				if (!returning)
					(fnLiteral += isAsync(hook.fn)
						? `await e.afterHandle[${i}](c)
`
						: `e.afterHandle[${i}](c)
`),
						endUnit();
				else if (
					((fnLiteral += isAsync(hook.fn)
						? `af=await e.afterHandle[${i}](c)
`
						: `af=e.afterHandle[${i}](c)
`),
					endUnit("af"),
					validator.response)
				)
					(fnLiteral += "if(af!==undefined){"),
						reporter.resolve(),
						(fnLiteral += composeResponseValidation("af")),
						(fnLiteral += "c.response=af}");
				else
					(fnLiteral += "if(af!==undefined){"),
						reporter.resolve(),
						(fnLiteral += "c.response=af}");
			}
			if (
				(reporter.resolve(),
				(fnLiteral += `r=c.response
`),
				validator.response)
			)
				fnLiteral += composeResponseValidation();
			fnLiteral += encodeCookie;
			let mapResponseReporter = report("mapResponse", {
				total: hooks.mapResponse?.length,
			});
			if (hooks.mapResponse?.length)
				for (let i = 0; i < hooks.mapResponse.length; i++) {
					let mapResponse2 = hooks.mapResponse[i],
						endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
					(fnLiteral += `mr=${isAsyncName(mapResponse2) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`),
						endUnit();
				}
			if ((mapResponseReporter.resolve(), hasSet))
				fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
			else
				fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
		} else {
			let handleReporter = report("handle", {
				name: isHandleFn ? handler.name : void 0,
			});
			if (validator.response || hooks.mapResponse?.length) {
				if (
					((fnLiteral += isAsyncHandler
						? `let r=await ${handle}
`
						: `let r=${handle}
`),
					handleReporter.resolve(),
					validator.response)
				)
					fnLiteral += composeResponseValidation();
				report("afterHandle").resolve();
				let mapResponseReporter = report("mapResponse", {
					total: hooks.mapResponse?.length,
				});
				if (hooks.mapResponse?.length) {
					fnLiteral += `
c.response=r
`;
					for (let i = 0; i < hooks.mapResponse.length; i++) {
						let mapResponse2 = hooks.mapResponse[i],
							endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
						(fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`),
							endUnit();
					}
				}
				if (
					(mapResponseReporter.resolve(),
					(fnLiteral += encodeCookie),
					handler instanceof Response)
				)
					(fnLiteral += inference.set
						? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()`
						: `return ${handle}.clone()`),
						(fnLiteral += `
`);
				else if (hasSet)
					fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
				else
					fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
			} else if (hasCookie || hasTrace) {
				(fnLiteral += isAsyncHandler
					? `let r=await ${handle}
`
					: `let r=${handle}
`),
					handleReporter.resolve(),
					report("afterHandle").resolve();
				let mapResponseReporter = report("mapResponse", {
					total: hooks.mapResponse?.length,
				});
				if (hooks.mapResponse?.length) {
					fnLiteral += `c.response= r
`;
					for (let i = 0; i < hooks.mapResponse.length; i++) {
						let mapResponse2 = hooks.mapResponse[i],
							endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
						(fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`),
							endUnit();
					}
				}
				if (
					(mapResponseReporter.resolve(), (fnLiteral += encodeCookie), hasSet)
				)
					fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
				else
					fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
			} else {
				handleReporter.resolve();
				let handled = isAsyncHandler ? `await ${handle}` : handle;
				if ((report("afterHandle").resolve(), handler instanceof Response))
					fnLiteral += inference.set
						? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
`
						: `return ${handle}.clone()
`;
				else if (hasSet)
					fnLiteral += `return mapResponse(${saveResponse}${handled},c.set${mapResponseContext})
`;
				else
					fnLiteral += `return mapCompactResponse(${saveResponse}${handled}${mapResponseContext})
`;
			}
		}
		if (
			((fnLiteral += `
}catch(error){`),
			hasBody)
		)
			fnLiteral += `if(isParsing)error=new ParseError()
`;
		if (!maybeAsync) fnLiteral += "return(async()=>{";
		if (
			((fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`),
			hasTrace && hooks.trace)
		)
			for (let i = 0; i < hooks.trace.length; i++)
				fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
		let errorReporter = report("error", { total: hooks.error?.length });
		if (hooks.error?.length) {
			if (
				((fnLiteral += `c.error=error
`),
				hasValidation)
			)
				fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
			else
				fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
			fnLiteral += `let er
`;
			for (let i = 0; i < hooks.error.length; i++) {
				let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
				if (isAsync(hooks.error[i]))
					fnLiteral += `er=await e.error[${i}](c)
`;
				else
					fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
				endUnit();
				let mapResponseReporter = report("mapResponse", {
					total: hooks.mapResponse?.length,
				});
				if (hooks.mapResponse?.length)
					for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
						let mapResponse2 = hooks.mapResponse[i2],
							endUnit2 = mapResponseReporter.resolveChild(mapResponse2.fn.name);
						(fnLiteral += `c.response=er
er=e.mapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`),
							endUnit2();
					}
				if (
					(mapResponseReporter.resolve(),
					(fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`),
					(fnLiteral += "if(er){"),
					hasTrace && hooks.trace)
				) {
					for (let i2 = 0; i2 < hooks.trace.length; i2++)
						fnLiteral += `report${i2}.resolve()
`;
					errorReporter.resolve();
				}
				fnLiteral += "return er}";
			}
		}
		if (
			(errorReporter.resolve(),
			(fnLiteral += "return handleError(c,error,true)"),
			!maybeAsync)
		)
			fnLiteral += "})()";
		if (((fnLiteral += "}"), hasAfterResponse || hasTrace)) {
			if (((fnLiteral += "finally{ "), !maybeAsync))
				fnLiteral += ";(async()=>{";
			let reporter = report("afterResponse", {
				total: hooks.afterResponse?.length,
			});
			if (hasAfterResponse && hooks.afterResponse)
				for (let i = 0; i < hooks.afterResponse.length; i++) {
					let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
					(fnLiteral += `
await e.afterResponse[${i}](c)
`),
						endUnit();
				}
			if ((reporter.resolve(), !maybeAsync)) fnLiteral += "})()";
			fnLiteral += "}";
		}
		let adapterVariables = adapter.inject
				? Object.keys(adapter.inject).join(",") + ","
				: "",
			init =
				"const {handler,handleError,hooks:e, " +
				allocateIf("validator,", hasValidation) +
				"mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" +
				allocateIf("parseQuery,", hasBody) +
				allocateIf("parseQueryFromURL,", hasQuery) +
				"},error:{" +
				allocateIf("ValidationError,", hasValidation) +
				"InternalServerError," +
				allocateIf("ParseError", hasBody) +
				"},schema,definitions,ERROR_CODE," +
				allocateIf("parseCookie,", hasCookie) +
				allocateIf("signCookie,", hasCookie) +
				allocateIf("decodeURIComponent,", hasQuery) +
				"ElysiaCustomStatusResponse," +
				allocateIf("ELYSIA_TRACE,", hasTrace) +
				allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
				allocateIf("parser,", hooks.parse?.length) +
				allocateIf("getServer,", inference.server) +
				adapterVariables +
				allocateIf("TypeBoxError", hasValidation) +
				`}=hooks
const trace=e.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
return ${maybeAsync ? "async " : ""}function handle(c){`;
		if (hooks.beforeHandle?.length)
			init += `let be
`;
		if (hooks.afterHandle?.length)
			init += `let af
`;
		if (hooks.mapResponse?.length)
			init += `let mr
`;
		if (allowMeta)
			init += `c.schema = schema
c.defs = definitions
`;
		init += fnLiteral + "}";
		try {
			if (asManifest) return Function("hooks", init);
			return Function(
				"hooks",
				init,
			)({
				handler,
				hooks: lifeCycleToFn(hooks),
				validator: hasValidation ? validator : void 0,
				handleError: app.handleError,
				mapResponse: adapterHandler.mapResponse,
				mapCompactResponse: adapterHandler.mapCompactResponse,
				mapEarlyResponse: adapterHandler.mapEarlyResponse,
				isNotEmpty,
				utils: {
					parseQuery: hasBody ? parseQuery : void 0,
					parseQueryFromURL: hasQuery ? parseQueryFromURL : void 0,
				},
				error: {
					ValidationError: hasValidation ? ValidationError : void 0,
					InternalServerError,
					ParseError: hasBody ? ParseError2 : void 0,
				},
				schema: app.router.history,
				definitions: app.definitions.type,
				ERROR_CODE,
				parseCookie: hasCookie ? parseCookie : void 0,
				signCookie: hasCookie ? signCookie : void 0,
				decodeURIComponent: hasQuery ? decode2 : void 0,
				ElysiaCustomStatusResponse,
				ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : void 0,
				ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : void 0,
				getServer: () => app.getServer(),
				TypeBoxError: hasValidation ? TypeBoxError : void 0,
				parser: app["~parser"],
				...adapter.inject,
			});
		} catch (error2) {
			let debugHooks = lifeCycleToFn(hooks);
			console.log("[Composer] failed to generate optimized handler"),
				console.log("---"),
				console.log({
					handler: typeof handler === "function" ? handler.toString() : handler,
					instruction: init,
					hooks: {
						...debugHooks,
						transform: debugHooks?.transform?.map?.((x) => x.toString()),
						resolve: debugHooks?.resolve?.map?.((x) => x.toString()),
						beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()),
						afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()),
						mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()),
						parse: debugHooks?.parse?.map?.((x) => x.toString()),
						error: debugHooks?.error?.map?.((x) => x.toString()),
						afterResponse: debugHooks?.afterResponse?.map?.((x) =>
							x.toString(),
						),
						stop: debugHooks?.stop?.map?.((x) => x.toString()),
					},
					validator,
					definitions: app.definitions.type,
					error: error2,
					fnLiteral,
				}),
				console.log("---"),
				process.exit(1);
		}
	},
	composeGeneralHandler = (app, { asManifest = !1 } = {}) => {
		let adapter = app["~adapter"].composeGeneralHandler;
		app.router.http.build();
		let error404 = adapter.error404(
				!!app.event.request?.length,
				!!app.event.error?.length,
			),
			hasTrace = app.event.trace?.length,
			fnLiteral = "",
			router = app.router,
			findDynamicRoute = "const route=router.find(r.method,p)";
		(findDynamicRoute += router.http.root.ALL
			? `??router.find("ALL",p)
`
			: `
`),
			(findDynamicRoute += error404.code),
			(findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)
`);
		let switchMap = "";
		for (let [path, v] of Object.entries(router.static.http.map)) {
			if (((switchMap += `case'${path}':`), app.config.strictPath !== !0))
				switchMap += `case'${getLoosePath(path)}':`;
			let encoded = encodePath(path);
			if (path !== encoded) switchMap += `case'${encoded}':`;
			switchMap +=
				`switch(r.method){${v.code}
` +
				(v.all ?? "default: break map") +
				"}";
		}
		let maybeAsync = !!app.event.request?.some(isAsync),
			adapterVariables = adapter.inject
				? Object.keys(adapter.inject).join(",") + ","
				: "";
		if (
			((fnLiteral +=
				`
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,error,redirect,` +
				allocateIf("ELYSIA_TRACE,", hasTrace) +
				allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
				adapterVariables +
				`}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`),
			app.event.request?.length)
		)
			fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
		if (((fnLiteral += error404.declare), app.event.trace?.length))
			fnLiteral +=
				"const " +
				app.event.trace
					.map((_, i) => `tr${i}=app.event.trace[${i}].fn`)
					.join(",") +
				`
`;
		if (
			((fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`),
			app.event.request?.length)
		)
			fnLiteral += `let re
`;
		if (((fnLiteral += adapter.createContext(app)), app.event.trace?.length))
			fnLiteral +=
				"c[ELYSIA_TRACE]=[" +
				app.event.trace.map((_, i) => `tr${i}(c)`).join(",") +
				`]
`;
		let reporter = createReport({
			trace: app.event.trace,
			addFn(word) {
				fnLiteral += word;
			},
		})("request", { total: app.event.request?.length });
		if (app.event.request?.length) {
			fnLiteral += "try{";
			for (let i = 0; i < app.event.request.length; i++) {
				let hook = app.event.request[i],
					withReturn = hasReturn(hook),
					maybeAsync2 = isAsync(hook),
					endUnit = reporter.resolveChild(app.event.request[i].fn.name);
				if (withReturn)
					(fnLiteral += `re=mapEarlyResponse(${maybeAsync2 ? "await " : ""}onRequest[${i}](c),c.set)
`),
						endUnit("re"),
						(fnLiteral += `if(re!==undefined)return re
`);
				else
					(fnLiteral += `${maybeAsync2 ? "await " : ""}onRequest[${i}](c)
`),
						endUnit();
			}
			fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
		}
		if (
			(reporter.resolve(),
			(fnLiteral += adapter.websocket(app)),
			(fnLiteral +=
				`
map:switch(p){
` +
				switchMap +
				"default:break}" +
				findDynamicRoute +
				`}
`),
			app.extender.higherOrderFunctions.length)
		) {
			let handler = "map";
			for (let i = 0; i < app.extender.higherOrderFunctions.length; i++)
				handler = `hoc[${i}](${handler},${adapter.parameters})`;
			fnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
		} else fnLiteral += "return map";
		let handleError = composeErrorHandler(app);
		return (
			(app.handleError = handleError),
			Function(
				"data",
				fnLiteral,
			)({
				app,
				mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse,
				NotFoundError,
				randomId,
				handleError,
				error,
				redirect,
				ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : void 0,
				ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : void 0,
				...adapter.inject,
			})
		);
	},
	composeErrorHandler = (app) => {
		let hooks = app.event,
			fnLiteral = "",
			adapter = app["~adapter"].composeError,
			adapterVariables = adapter.inject
				? Object.keys(adapter.inject).join(",") + ","
				: "",
			hasTrace = !!app.event.trace?.length;
		if (
			((fnLiteral +=
				"const {app:{event:{error:onErrorContainer,afterResponse:resContainer,mapResponse:_onMapResponse,trace:_trace}},mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," +
				allocateIf("ELYSIA_TRACE,", hasTrace) +
				allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
				adapterVariables +
				`}=inject
`),
			(fnLiteral += `const trace=_trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const onMapResponse=[]
if(_onMapResponse)for(let i=0;i<_onMapResponse.length;i++)onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])
delete _onMapResponse
const onError=onErrorContainer?.map(x=>x.fn)??[]
const res=resContainer?.map(x=>x.fn)??[]
return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`),
			(fnLiteral += ""),
			hasTrace)
		)
			fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
		let report = createReport({
			context: "context",
			trace: hooks.trace,
			addFn: (word) => {
				fnLiteral += word;
			},
		});
		if (
			((fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`),
			adapter.declare)
		)
			fnLiteral += adapter.declare;
		let saveResponse =
			hasTrace || !!hooks.afterResponse?.length || !!hooks.afterResponse?.length
				? "context.response = "
				: "";
		if (app.event.error)
			for (let i = 0; i < app.event.error.length; i++) {
				let handler = app.event.error[i],
					response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
				if (((fnLiteral += "if(skipGlobal!==true){"), hasReturn(handler))) {
					fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
					let mapResponseReporter2 = report("mapResponse", {
						total: hooks.mapResponse?.length,
						name: "context",
					});
					if (hooks.mapResponse?.length)
						for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
							let mapResponse2 = hooks.mapResponse[i2],
								endUnit = mapResponseReporter2.resolveChild(
									mapResponse2.fn.name,
								);
							(fnLiteral += `context.response=_r_r=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i2}](context)
`),
								endUnit();
						}
					mapResponseReporter2.resolve(),
						(fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`);
				} else fnLiteral += response;
				fnLiteral += "}";
			}
		(fnLiteral +=
			`if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){if(error.error)error=error.error
set.status=error.status??422
` +
			adapter.validationError +
			"}"),
			(fnLiteral += "if(error instanceof Error){" + adapter.unknownError + "}");
		let mapResponseReporter = report("mapResponse", {
			total: hooks.mapResponse?.length,
			name: "context",
		});
		if (
			((fnLiteral += `
if(!context.response)context.response=error.message??error
`),
			hooks.mapResponse?.length)
		) {
			fnLiteral += `let mr
`;
			for (let i = 0; i < hooks.mapResponse.length; i++) {
				let mapResponse2 = hooks.mapResponse[i],
					endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
				(fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`),
					endUnit();
			}
		}
		return (
			mapResponseReporter.resolve(),
			(fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`),
			Function(
				"inject",
				fnLiteral,
			)({
				app,
				mapResponse: app["~adapter"].handler.mapResponse,
				ERROR_CODE,
				ElysiaCustomStatusResponse,
				ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : void 0,
				ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : void 0,
				...adapter.inject,
			})
		);
	};
var injectDefaultValues = (typeChecker, obj) => {
		for (let [key, keySchema] of Object.entries(typeChecker.schema.properties))
			obj[key] ??= keySchema.default;
	},
	createDynamicHandler = (app) => {
		let { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2 } =
			app["~adapter"].handler;
		return async (request) => {
			let url = request.url,
				s = url.indexOf("/", 11),
				qi = url.indexOf("?", s + 1),
				path = qi === -1 ? url.substring(s) : url.substring(s, qi),
				set2 = { cookie: {}, status: 200, headers: {} },
				context = Object.assign({}, app.singleton.decorator, {
					set: set2,
					store: app.singleton.store,
					request,
					path,
					qi,
					error,
					redirect,
				});
			try {
				if (app.event.request)
					for (let i = 0; i < app.event.request.length; i++) {
						let onRequest = app.event.request[i].fn,
							response2 = onRequest(context);
						if (response2 instanceof Promise) response2 = await response2;
						if (((response2 = mapEarlyResponse2(response2, set2)), response2))
							return (context.response = response2);
					}
				let handler =
					app.router.dynamic.find(request.method, path) ??
					app.router.dynamic.find("ALL", path);
				if (!handler) throw new NotFoundError();
				let { handle, hooks, validator, content, route } = handler.store,
					body;
				if (request.method !== "GET" && request.method !== "HEAD")
					if (content)
						switch (content) {
							case "application/json":
								body = await request.json();
								break;
							case "text/plain":
								body = await request.text();
								break;
							case "application/x-www-form-urlencoded":
								body = parseQuery(await request.text());
								break;
							case "application/octet-stream":
								body = await request.arrayBuffer();
								break;
							case "multipart/form-data":
								body = {};
								let form = await request.formData();
								for (let key of form.keys()) {
									if (body[key]) continue;
									let value = form.getAll(key);
									if (value.length === 1) body[key] = value[0];
									else body[key] = value;
								}
								break;
						}
					else {
						let contentType = request.headers.get("content-type");
						if (contentType) {
							let index = contentType.indexOf(";");
							if (index !== -1) contentType = contentType.slice(0, index);
							if (((context.contentType = contentType), hooks.parse))
								for (let i = 0; i < hooks.parse.length; i++) {
									let hook = hooks.parse[i].fn,
										temp = hook(context, contentType);
									if (temp instanceof Promise) temp = await temp;
									if (temp) {
										body = temp;
										break;
									}
								}
							if ((delete context.contentType, body === void 0))
								switch (contentType) {
									case "application/json":
										body = await request.json();
										break;
									case "text/plain":
										body = await request.text();
										break;
									case "application/x-www-form-urlencoded":
										body = parseQuery(await request.text());
										break;
									case "application/octet-stream":
										body = await request.arrayBuffer();
										break;
									case "multipart/form-data":
										body = {};
										let form = await request.formData();
										for (let key of form.keys()) {
											if (body[key]) continue;
											let value = form.getAll(key);
											if (value.length === 1) body[key] = value[0];
											else body[key] = value;
										}
										break;
								}
						}
					}
				(context.route = route),
					(context.body = body),
					(context.params = handler?.params || void 0),
					(context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))),
					(context.headers = {});
				for (let [key, value] of request.headers.entries())
					context.headers[key] = value;
				let cookieMeta = Object.assign(
						{},
						app.config?.cookie,
						validator?.cookie?.config,
					),
					cookieHeaderValue = request.headers.get("cookie");
				context.cookie = await parseCookie(
					context.set,
					cookieHeaderValue,
					cookieMeta
						? {
								secrets:
									cookieMeta.secrets !== void 0
										? typeof cookieMeta.secrets === "string"
											? cookieMeta.secrets
											: cookieMeta.secrets.join(",")
										: void 0,
								sign:
									cookieMeta.sign === !0
										? !0
										: cookieMeta.sign !== void 0
											? typeof cookieMeta.sign === "string"
												? cookieMeta.sign
												: cookieMeta.sign.join(",")
											: void 0,
							}
						: void 0,
				);
				let headerValidator = validator?.createHeaders?.();
				if (headerValidator)
					injectDefaultValues(headerValidator, context.headers);
				let paramsValidator = validator?.createParams?.();
				if (paramsValidator)
					injectDefaultValues(paramsValidator, context.params);
				let queryValidator = validator?.createQuery?.();
				if (queryValidator) injectDefaultValues(queryValidator, context.query);
				if (hooks.transform)
					for (let i = 0; i < hooks.transform.length; i++) {
						let hook = hooks.transform[i],
							operation = hook.fn(context);
						if (hook.subType === "derive")
							if (operation instanceof Promise)
								Object.assign(context, await operation);
							else Object.assign(context, operation);
						else if (operation instanceof Promise) await operation;
					}
				if (validator) {
					if (headerValidator) {
						let _header = structuredClone(context.headers);
						for (let [key, value] of request.headers) _header[key] = value;
						if (validator.headers.Check(_header) === !1)
							throw new ValidationError("header", validator.headers, _header);
					} else if (validator.headers?.Decode)
						context.headers = validator.headers.Decode(context.headers);
					if (paramsValidator?.Check(context.params) === !1)
						throw new ValidationError(
							"params",
							validator.params,
							context.params,
						);
					else if (validator.params?.Decode)
						context.params = validator.params.Decode(context.params);
					if (queryValidator?.Check(context.query) === !1)
						throw new ValidationError("query", validator.query, context.query);
					else if (validator.query?.Decode)
						context.query = validator.query.Decode(context.query);
					if (validator.createCookie?.()) {
						let cookieValue = {};
						for (let [key, value] of Object.entries(context.cookie))
							cookieValue[key] = value.value;
						if (validator.cookie.Check(cookieValue) === !1)
							throw new ValidationError(
								"cookie",
								validator.cookie,
								cookieValue,
							);
						else if (validator.cookie?.Decode)
							cookieValue = validator.cookie.Decode(cookieValue);
					}
					if (validator.createBody?.()?.Check(body) === !1)
						throw new ValidationError("body", validator.body, body);
					else if (validator.body?.Decode)
						context.body = validator.body.Decode(body);
				}
				if (hooks.beforeHandle)
					for (let i = 0; i < hooks.beforeHandle.length; i++) {
						let hook = hooks.beforeHandle[i],
							response2 = hook.fn(context);
						if (hook.subType === "resolve") {
							if (response2 instanceof ElysiaCustomStatusResponse) {
								let result = mapEarlyResponse2(response2, context.set);
								if (result) return (context.response = result);
							}
							if (response2 instanceof Promise)
								Object.assign(context, await response2);
							else Object.assign(context, response2);
							continue;
						} else if (response2 instanceof Promise)
							response2 = await response2;
						if (response2 !== void 0) {
							if (((context.response = response2), hooks.afterHandle))
								for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
									let newResponse = hooks.afterHandle[i2].fn(context);
									if (newResponse instanceof Promise)
										newResponse = await newResponse;
									if (newResponse) response2 = newResponse;
								}
							let result = mapEarlyResponse2(response2, context.set);
							if (result) return (context.response = result);
						}
					}
				let response = typeof handle === "function" ? handle(context) : handle;
				if (response instanceof Promise) response = await response;
				if (hooks.afterHandle)
					if (!hooks.afterHandle.length) {
						let status =
								response instanceof ElysiaCustomStatusResponse
									? response.code
									: set2.status
										? typeof set2.status === "string"
											? StatusMap[set2.status]
											: set2.status
										: 200,
							responseValidator = validator?.createResponse?.()?.[status];
						if (responseValidator?.Check(response) === !1)
							throw new ValidationError(
								"response",
								responseValidator,
								response,
							);
						else if (responseValidator?.Decode)
							response = responseValidator.Decode(response);
					} else {
						context.response = response;
						for (let i = 0; i < hooks.afterHandle.length; i++) {
							let newResponse = hooks.afterHandle[i].fn(context);
							if (newResponse instanceof Promise)
								newResponse = await newResponse;
							let result = mapEarlyResponse2(newResponse, context.set);
							if (result !== void 0) {
								let responseValidator = validator?.response?.[result.status];
								if (responseValidator?.Check(result) === !1)
									throw new ValidationError(
										"response",
										responseValidator,
										result,
									);
								else if (responseValidator?.Decode)
									response = responseValidator.Decode(response);
								return (context.response = result);
							}
						}
					}
				if (context.set.cookie && cookieMeta?.sign) {
					let secret = !cookieMeta.secrets
						? void 0
						: typeof cookieMeta.secrets === "string"
							? cookieMeta.secrets
							: cookieMeta.secrets[0];
					if (cookieMeta.sign === !0)
						for (let [key, cookie] of Object.entries(context.set.cookie))
							context.set.cookie[key].value = await signCookie(
								cookie.value,
								"${secret}",
							);
					else {
						let properties = validator?.cookie?.schema?.properties;
						for (let name of cookieMeta.sign) {
							if (!(name in properties)) continue;
							if (context.set.cookie[name]?.value)
								context.set.cookie[name].value = await signCookie(
									context.set.cookie[name].value,
									secret,
								);
						}
					}
				}
				return mapResponse2((context.response = response), context.set);
			} catch (error2) {
				let reportedError =
					error2 instanceof TransformDecodeError && error2.error
						? error2.error
						: error2;
				return app.handleError(context, reportedError);
			} finally {
				if (app.event.afterResponse)
					for (let afterResponse of app.event.afterResponse)
						await afterResponse.fn(context);
			}
		};
	},
	createDynamicErrorHandler = (app) => {
		let { mapResponse: mapResponse2 } = app["~adapter"].handler;
		return async (context, error2) => {
			let errorContext = Object.assign(context, {
				error: error2,
				code: error2.code,
			});
			if (((errorContext.set = context.set), app.event.error))
				for (let i = 0; i < app.event.error.length; i++) {
					let response = app.event.error[i].fn(errorContext);
					if (response instanceof Promise) response = await response;
					if (response !== void 0 && response !== null)
						return (context.response = mapResponse2(response, context.set));
				}
			return new Response(
				typeof error2.cause === "string" ? error2.cause : error2.message,
				{ headers: context.set.headers, status: error2.status ?? 500 },
			);
		};
	};
class Elysia {
	constructor(config = {}) {
		if (
			((this.server = null),
			(this.dependencies = {}),
			(this._routes = {}),
			(this._types = {
				Prefix: "",
				Singleton: {},
				Definitions: {},
				Metadata: {},
			}),
			(this._ephemeral = {}),
			(this._volatile = {}),
			(this.singleton = { decorator: {}, store: {}, derive: {}, resolve: {} }),
			(this.definitions = { typebox: t.Module({}), type: {}, error: {} }),
			(this.extender = { macros: [], higherOrderFunctions: [] }),
			(this.validator = {
				global: null,
				scoped: null,
				local: null,
				getCandidate() {
					return mergeSchemaValidator(
						mergeSchemaValidator(this.global, this.scoped),
						this.local,
					);
				},
			}),
			(this.event = {}),
			(this.telemetry = { stack: void 0 }),
			(this.router = {
				"~http": void 0,
				get http() {
					if (!this["~http"]) this["~http"] = new Memoirist({ lazy: !0 });
					return this["~http"];
				},
				"~dynamic": void 0,
				get dynamic() {
					if (!this["~dynamic"]) this["~dynamic"] = new Memoirist();
					return this["~dynamic"];
				},
				static: { http: { static: {}, map: {}, all: "" }, ws: {} },
				history: [],
			}),
			(this.routeTree = new Map()),
			(this.inference = {
				body: !1,
				cookie: !1,
				headers: !1,
				query: !1,
				set: !1,
				server: !1,
				request: !1,
				route: !1,
			}),
			(this["~parser"] = {}),
			(this.handle = async (request) => this.fetch(request)),
			(this.fetch = (request) => {
				return (this.fetch = this.config.aot
					? composeGeneralHandler(this)
					: createDynamicHandler(this))(request);
			}),
			(this.handleError = async (context, error2) => {
				return (this.handleError = this.config.aot
					? composeErrorHandler(this)
					: createDynamicErrorHandler(this))(context, error2);
			}),
			(this.outerErrorHandler = (error2) =>
				new Response(error2.message || error2.name || "Error", {
					status: error2?.status ?? 500,
				})),
			(this.listen = (options, callback) => {
				return this["~adapter"].listen(this)(options, callback), this;
			}),
			(this.stop = async (closeActiveConnections) => {
				if (!this.server)
					throw new Error(
						"Elysia isn't running. Call `app.listen` to start the server.",
					);
				if (this.server) {
					if (
						(this.server.stop(closeActiveConnections),
						(this.server = null),
						this.event.stop?.length)
					)
						for (let i = 0; i < this.event.stop.length; i++)
							this.event.stop[i].fn(this);
				}
			}),
			config.tags)
		)
			if (!config.detail) config.detail = { tags: config.tags };
			else config.detail.tags = config.tags;
		if (config.nativeStaticResponse === void 0)
			config.nativeStaticResponse = !0;
		if (
			((this.config = {}),
			this.applyConfig(config ?? {}),
			(this["~adapter"] =
				config.adapter ??
				(typeof Bun !== "undefined" ? BunAdapter : WebStandardAdapter)),
			config?.analytic && (config?.name || config?.seed !== void 0))
		)
			this.telemetry.stack = new Error().stack;
	}
	get store() {
		return this.singleton.store;
	}
	get decorator() {
		return this.singleton.decorator;
	}
	get routes() {
		return this.router.history;
	}
	getGlobalRoutes() {
		return this.router.history;
	}
	getServer() {
		return this.server;
	}
	getParent() {
		return null;
	}
	get promisedModules() {
		if (!this._promisedModules) this._promisedModules = new PromiseGroup();
		return this._promisedModules;
	}
	env(model, _env = env2) {
		if (
			getSchemaValidator(model, {
				modules: this.definitions.typebox,
				dynamic: !0,
				additionalProperties: !0,
				coerce: !0,
			}).Check(_env) === !1
		) {
			let error2 = new ValidationError("env", model, _env);
			throw new Error(
				error2.all
					.map((x) => x.summary)
					.join(`
`),
			);
		}
		return this;
	}
	wrap(fn) {
		return (
			this.extender.higherOrderFunctions.push({
				checksum: checksum(
					JSON.stringify({
						name: this.config.name,
						seed: this.config.seed,
						content: fn.toString(),
					}),
				),
				fn,
			}),
			this
		);
	}
	applyMacro(localHook) {
		if (this.extender.macros.length) {
			let manage = createMacroManager({ globalHook: this.event, localHook }),
				manager = {
					events: { global: this.event, local: localHook },
					get onParse() {
						return manage("parse");
					},
					get onTransform() {
						return manage("transform");
					},
					get onBeforeHandle() {
						return manage("beforeHandle");
					},
					get onAfterHandle() {
						return manage("afterHandle");
					},
					get mapResponse() {
						return manage("mapResponse");
					},
					get onAfterResponse() {
						return manage("afterResponse");
					},
					get onError() {
						return manage("error");
					},
				};
			for (let macro of this.extender.macros)
				traceBackMacro(macro.fn(manager), localHook, manage);
		}
	}
	applyConfig(config) {
		return (
			(this.config = {
				prefix: "",
				aot: env2.ELYSIA_AOT !== "false",
				normalize: !0,
				...config,
				cookie: { path: "/", ...config?.cookie },
				experimental: config?.experimental ?? {},
				seed: config?.seed === void 0 ? "" : config?.seed,
			}),
			this
		);
	}
	get models() {
		let models = {};
		for (let name of Object.keys(this.definitions.type))
			models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
		return (models.modules = this.definitions.typebox), models;
	}
	add(
		method,
		path,
		handle,
		localHook,
		{ allowMeta = !1, skipPrefix = !1 } = { allowMeta: !1, skipPrefix: !1 },
	) {
		if (
			((localHook = compressHistoryHook(localHookToLifeCycleStore(localHook))),
			path !== "" && path.charCodeAt(0) !== 47)
		)
			path = "/" + path;
		if (this.config.prefix && !skipPrefix) path = this.config.prefix + path;
		if (localHook?.type)
			switch (localHook.type) {
				case "text":
					localHook.type = "text/plain";
					break;
				case "json":
					localHook.type = "application/json";
					break;
				case "formdata":
					localHook.type = "multipart/form-data";
					break;
				case "urlencoded":
					localHook.type = "application/x-www-form-urlencoded";
					break;
				case "arrayBuffer":
					localHook.type = "application/octet-stream";
					break;
				default:
					break;
			}
		let models = this.definitions.type,
			dynamic = !this.config.aot,
			instanceValidator = { ...this.validator.getCandidate() },
			cloned = {
				body: localHook?.body ?? instanceValidator?.body,
				headers: localHook?.headers ?? instanceValidator?.headers,
				params: localHook?.params ?? instanceValidator?.params,
				query: localHook?.query ?? instanceValidator?.query,
				cookie: localHook?.cookie ?? instanceValidator?.cookie,
				response: localHook?.response ?? instanceValidator?.response,
			},
			cookieValidator = () =>
				cloned.cookie
					? getCookieValidator({
							modules,
							validator: cloned.cookie,
							defaultConfig: this.config.cookie,
							config: cloned.cookie?.config ?? {},
							dynamic,
							models,
						})
					: void 0,
			normalize = this.config.normalize,
			modules = this.definitions.typebox,
			validator =
				this.config.precompile === !0 ||
				(typeof this.config.precompile === "object" &&
					this.config.precompile.schema === !0)
					? {
							body: getSchemaValidator(cloned.body, {
								modules,
								dynamic,
								models,
								normalize,
								additionalCoerce: coercePrimitiveRoot(),
							}),
							headers: getSchemaValidator(cloned.headers, {
								modules,
								dynamic,
								models,
								additionalProperties: !this.config.normalize,
								coerce: !0,
								additionalCoerce: stringToStructureCoercions(),
							}),
							params: getSchemaValidator(cloned.params, {
								modules,
								dynamic,
								models,
								coerce: !0,
								additionalCoerce: stringToStructureCoercions(),
							}),
							query: getSchemaValidator(cloned.query, {
								modules,
								dynamic,
								models,
								normalize,
								coerce: !0,
								additionalCoerce: stringToStructureCoercions(),
							}),
							cookie: cookieValidator(),
							response: getResponseSchemaValidator(cloned.response, {
								modules,
								dynamic,
								models,
								normalize,
							}),
						}
					: {
							createBody() {
								if (this.body) return this.body;
								return (this.body = getSchemaValidator(cloned.body, {
									modules,
									dynamic,
									models,
									normalize,
									additionalCoerce: coercePrimitiveRoot(),
								}));
							},
							createHeaders() {
								if (this.headers) return this.headers;
								return (this.headers = getSchemaValidator(cloned.headers, {
									modules,
									dynamic,
									models,
									additionalProperties: !normalize,
									coerce: !0,
									additionalCoerce: stringToStructureCoercions(),
								}));
							},
							createParams() {
								if (this.params) return this.params;
								return (this.params = getSchemaValidator(cloned.params, {
									modules,
									dynamic,
									models,
									coerce: !0,
									additionalCoerce: stringToStructureCoercions(),
								}));
							},
							createQuery() {
								if (this.query) return this.query;
								return (this.query = getSchemaValidator(cloned.query, {
									modules,
									dynamic,
									models,
									coerce: !0,
									additionalCoerce: stringToStructureCoercions(),
								}));
							},
							createCookie() {
								if (this.cookie) return this.cookie;
								return (this.cookie = cookieValidator());
							},
							createResponse() {
								if (this.response) return this.response;
								return (this.response = getResponseSchemaValidator(
									cloned.response,
									{ modules, dynamic, models, normalize },
								));
							},
						};
		if (
			((localHook = mergeHook(
				localHook,
				compressHistoryHook(instanceValidator),
			)),
			localHook.tags)
		)
			if (!localHook.detail) localHook.detail = { tags: localHook.tags };
			else localHook.detail.tags = localHook.tags;
		if (isNotEmpty(this.config.detail))
			localHook.detail = mergeDeep(
				Object.assign({}, this.config.detail),
				localHook.detail,
			);
		this.applyMacro(localHook);
		let hooks = compressHistoryHook(mergeHook(this.event, localHook));
		if (this.config.aot === !1) {
			this.router.dynamic.add(method, path, {
				validator,
				hooks,
				content: localHook?.type,
				handle,
				route: path,
			});
			let encoded = encodePath(path, { dynamic: !0 });
			if (path !== encoded)
				this.router.dynamic.add(method, encoded, {
					validator,
					hooks,
					content: localHook?.type,
					handle,
					route: path,
				});
			if (this.config.strictPath === !1) {
				let loosePath = getLoosePath(path);
				this.router.dynamic.add(method, loosePath, {
					validator,
					hooks,
					content: localHook?.type,
					handle,
					route: path,
				});
				let encoded2 = encodePath(loosePath);
				if (loosePath !== encoded2)
					this.router.dynamic.add(method, loosePath, {
						validator,
						hooks,
						content: localHook?.type,
						handle,
						route: path,
					});
			}
			this.router.history.push({
				method,
				path,
				composed: null,
				handler: handle,
				hooks,
			});
			return;
		}
		let shouldPrecompile =
				this.config.precompile === !0 ||
				(typeof this.config.precompile === "object" &&
					this.config.precompile.compose === !0),
			inference = cloneInference(this.inference),
			adapter = this["~adapter"].handler,
			staticHandler =
				typeof handle !== "function" &&
				typeof adapter.createStaticHandler === "function"
					? adapter.createStaticHandler(handle, hooks, this.setHeaders)
					: void 0,
			nativeStaticHandler =
				typeof handle !== "function"
					? adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders)
					: void 0;
		if (
			this.config.nativeStaticResponse === !0 &&
			nativeStaticHandler &&
			(method === "GET" || method === "ALL")
		)
			this.router.static.http.static[path] = nativeStaticHandler();
		let compile = (asManifest = !1) =>
				composeHandler({
					app: this,
					path,
					method,
					hooks,
					validator,
					handler:
						typeof handle !== "function" &&
						typeof adapter.createStaticHandler !== "function"
							? () => handle
							: handle,
					allowMeta,
					inference,
					asManifest,
				}),
			oldIndex;
		if (this.routeTree.has(method + path))
			for (let i = 0; i < this.router.history.length; i++) {
				let route = this.router.history[i];
				if (route.path === path && route.method === method) {
					oldIndex = i;
					break;
				}
			}
		else this.routeTree.set(method + path, this.router.history.length);
		let history = this.router.history,
			index = oldIndex ?? this.router.history.length,
			mainHandler = shouldPrecompile
				? compile()
				: (ctx) => {
						let temp = (history[index].composed = compile())(ctx);
						return (compile = void 0), temp;
					};
		if (shouldPrecompile) compile = void 0;
		let isWebSocket = method === "$INTERNALWS";
		if (oldIndex !== void 0)
			this.router.history[oldIndex] = Object.assign(
				{ method, path, composed: mainHandler, handler: handle, hooks },
				localHook.webSocket ? { websocket: localHook.websocket } : {},
			);
		else
			this.router.history.push(
				Object.assign(
					{ method, path, composed: mainHandler, handler: handle, hooks },
					localHook.webSocket ? { websocket: localHook.websocket } : {},
				),
			);
		let staticRouter = this.router.static.http,
			handler = {
				handler: shouldPrecompile ? mainHandler : void 0,
				compile() {
					return (this.handler = compile());
				},
			};
		if (isWebSocket) {
			if ((this.router.http.add("ws", path, handler), !this.config.strictPath))
				this.router.http.add("ws", getLoosePath(path), handler);
			let encoded = encodePath(path, { dynamic: !0 });
			if (encoded !== path) this.router.http.add("ws", encoded, handler);
			return;
		}
		if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
			if (!staticRouter.map[path]) staticRouter.map[path] = { code: "" };
			let ctx = staticHandler ? "" : "c";
			if (method === "ALL")
				staticRouter.map[path].all =
					`default:return ht[${index}].composed(${ctx})
`;
			else
				staticRouter.map[path].code =
					`case '${method}':return ht[${index}].composed(${ctx})
${staticRouter.map[path].code}`;
			if (
				!this.config.strictPath &&
				this.config.nativeStaticResponse === !0 &&
				nativeStaticHandler &&
				(method === "GET" || method === "ALL")
			)
				this.router.static.http.static[getLoosePath(path)] =
					nativeStaticHandler();
		} else {
			if (
				(this.router.http.add(method, path, handler), !this.config.strictPath)
			) {
				let loosePath = getLoosePath(path);
				if (
					this.config.nativeStaticResponse === !0 &&
					staticHandler &&
					(method === "GET" || method === "ALL")
				)
					this.router.static.http.static[loosePath] = staticHandler();
				this.router.http.add(method, loosePath, handler);
			}
			let encoded = encodePath(path, { dynamic: !0 });
			if (path !== encoded) {
				if (
					(this.router.http.add(method, encoded, handler),
					this.config.nativeStaticResponse === !0 &&
						staticHandler &&
						(method === "GET" || method === "ALL"))
				)
					this.router.static.http.static[encoded] = staticHandler();
				this.router.http.add(method, encoded, handler);
			}
		}
	}
	headers(header) {
		if (!header) return this;
		if (!this.setHeaders) this.setHeaders = {};
		return (this.setHeaders = mergeDeep(this.setHeaders, header)), this;
	}
	onStart(handler) {
		return this.on("start", handler), this;
	}
	onRequest(handler) {
		return this.on("request", handler), this;
	}
	onParse(options, handler) {
		if (!handler) {
			if (typeof options === "string")
				return this.on("parse", this["~parser"][options]);
			return this.on("parse", options);
		}
		return this.on(options, "parse", handler);
	}
	parser(name, parser) {
		return (this["~parser"][name] = parser), this;
	}
	onTransform(options, handler) {
		if (!handler) return this.on("transform", options);
		return this.on(options, "transform", handler);
	}
	resolve(optionsOrResolve, resolve) {
		if (!resolve)
			(resolve = optionsOrResolve), (optionsOrResolve = { as: "local" });
		let hook = { subType: "resolve", fn: resolve };
		return this.onBeforeHandle(optionsOrResolve, hook);
	}
	mapResolve(optionsOrResolve, mapper) {
		if (!mapper)
			(mapper = optionsOrResolve), (optionsOrResolve = { as: "local" });
		let hook = { subType: "mapResolve", fn: mapper };
		return this.onBeforeHandle(optionsOrResolve, hook);
	}
	onBeforeHandle(options, handler) {
		if (!handler) return this.on("beforeHandle", options);
		return this.on(options, "beforeHandle", handler);
	}
	onAfterHandle(options, handler) {
		if (!handler) return this.on("afterHandle", options);
		return this.on(options, "afterHandle", handler);
	}
	mapResponse(options, handler) {
		if (!handler) return this.on("mapResponse", options);
		return this.on(options, "mapResponse", handler);
	}
	onAfterResponse(options, handler) {
		if (!handler) return this.on("afterResponse", options);
		return this.on(options, "afterResponse", handler);
	}
	trace(options, handler) {
		if (!handler) (handler = options), (options = { as: "local" });
		if (!Array.isArray(handler)) handler = [handler];
		for (let fn of handler) this.on(options, "trace", createTracer(fn));
		return this;
	}
	error(name, error2) {
		switch (typeof name) {
			case "string":
				return (
					(error2.prototype[ERROR_CODE] = name),
					(this.definitions.error[name] = error2),
					this
				);
			case "function":
				return (this.definitions.error = name(this.definitions.error)), this;
		}
		for (let [code, error3] of Object.entries(name))
			(error3.prototype[ERROR_CODE] = code),
				(this.definitions.error[code] = error3);
		return this;
	}
	onError(options, handler) {
		if (!handler) return this.on("error", options);
		return this.on(options, "error", handler);
	}
	onStop(handler) {
		return this.on("stop", handler), this;
	}
	on(optionsOrType, typeOrHandlers, handlers) {
		let type2;
		switch (typeof optionsOrType) {
			case "string":
				(type2 = optionsOrType), (handlers = typeOrHandlers);
				break;
			case "object":
				if (
					((type2 = typeOrHandlers),
					!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
				)
					handlers = typeOrHandlers;
				break;
		}
		if (Array.isArray(handlers)) handlers = fnToContainer(handlers);
		else if (typeof handlers === "function") handlers = [{ fn: handlers }];
		else handlers = [handlers];
		let handles = handlers;
		for (let handle of handles)
			if (
				((handle.scope =
					typeof optionsOrType === "string"
						? "local"
						: (optionsOrType?.as ?? "local")),
				type2 === "resolve" || type2 === "derive")
			)
				handle.subType = type2;
		if (type2 !== "trace")
			sucrose({ [type2]: handles.map((x) => x.fn) }, this.inference);
		for (let handle of handles) {
			let fn = asHookType(handle, "global", { skipIfHasType: !0 });
			switch (type2) {
				case "start":
					(this.event.start ??= []), this.event.start.push(fn);
					break;
				case "request":
					(this.event.request ??= []), this.event.request.push(fn);
					break;
				case "parse":
					(this.event.parse ??= []), this.event.parse.push(fn);
					break;
				case "transform":
					(this.event.transform ??= []), this.event.transform.push(fn);
					break;
				case "derive":
					(this.event.transform ??= []),
						this.event.transform.push(fnToContainer(fn, "derive"));
					break;
				case "beforeHandle":
					(this.event.beforeHandle ??= []), this.event.beforeHandle.push(fn);
					break;
				case "resolve":
					(this.event.beforeHandle ??= []),
						this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
					break;
				case "afterHandle":
					(this.event.afterHandle ??= []), this.event.afterHandle.push(fn);
					break;
				case "mapResponse":
					(this.event.mapResponse ??= []), this.event.mapResponse.push(fn);
					break;
				case "afterResponse":
					(this.event.afterResponse ??= []), this.event.afterResponse.push(fn);
					break;
				case "trace":
					(this.event.trace ??= []), this.event.trace.push(fn);
					break;
				case "error":
					(this.event.error ??= []), this.event.error.push(fn);
					break;
				case "stop":
					(this.event.stop ??= []), this.event.stop.push(fn);
					break;
			}
		}
		return this;
	}
	propagate() {
		return (
			promoteEvent(this.event.parse),
			promoteEvent(this.event.transform),
			promoteEvent(this.event.beforeHandle),
			promoteEvent(this.event.afterHandle),
			promoteEvent(this.event.mapResponse),
			promoteEvent(this.event.afterResponse),
			promoteEvent(this.event.trace),
			promoteEvent(this.event.error),
			this
		);
	}
	as(type2) {
		let castType = { plugin: "scoped", scoped: "scoped", global: "global" }[
			type2
		];
		if (
			(promoteEvent(this.event.parse, castType),
			promoteEvent(this.event.transform, castType),
			promoteEvent(this.event.beforeHandle, castType),
			promoteEvent(this.event.afterHandle, castType),
			promoteEvent(this.event.mapResponse, castType),
			promoteEvent(this.event.afterResponse, castType),
			promoteEvent(this.event.trace, castType),
			promoteEvent(this.event.error, castType),
			type2 === "plugin")
		)
			(this.validator.scoped = mergeSchemaValidator(
				this.validator.scoped,
				this.validator.local,
			)),
				(this.validator.local = null);
		else if (type2 === "global")
			(this.validator.global = mergeSchemaValidator(
				this.validator.global,
				mergeSchemaValidator(this.validator.scoped, this.validator.local),
			)),
				(this.validator.scoped = null),
				(this.validator.local = null);
		return this;
	}
	group(prefix, schemaOrRun, run) {
		let instance = new Elysia({ ...this.config, prefix: "" });
		(instance.singleton = { ...this.singleton }),
			(instance.definitions = { ...this.definitions }),
			(instance.getServer = () => this.getServer()),
			(instance.inference = cloneInference(this.inference)),
			(instance.extender = { ...this.extender });
		let isSchema = typeof schemaOrRun === "object",
			sandbox = (isSchema ? run : schemaOrRun)(instance);
		if (
			((this.singleton = mergeDeep(this.singleton, instance.singleton)),
			(this.definitions = mergeDeep(this.definitions, instance.definitions)),
			sandbox.event.request?.length)
		)
			this.event.request = [
				...(this.event.request || []),
				...(sandbox.event.request || []),
			];
		if (sandbox.event.mapResponse?.length)
			this.event.mapResponse = [
				...(this.event.mapResponse || []),
				...(sandbox.event.mapResponse || []),
			];
		return (
			this.model(sandbox.definitions.type),
			Object.values(instance.router.history).forEach(
				({ method, path, handler, hooks }) => {
					if (
						((path = (isSchema ? "" : this.config.prefix) + prefix + path),
						isSchema)
					) {
						let hook = schemaOrRun,
							localHook = hooks;
						this.add(
							method,
							path,
							handler,
							mergeHook(hook, {
								...(localHook || {}),
								error: !localHook.error
									? sandbox.event.error
									: Array.isArray(localHook.error)
										? [
												...(localHook.error || {}),
												...(sandbox.event.error || {}),
											]
										: [localHook.error, ...(sandbox.event.error || {})],
							}),
						);
					} else
						this.add(
							method,
							path,
							handler,
							mergeHook(hooks, { error: sandbox.event.error }),
							{ skipPrefix: !0 },
						);
				},
			),
			this
		);
	}
	guard(hook, run) {
		if (!run) {
			if (typeof hook === "object") {
				this.applyMacro(hook);
				let type2 = hook.as ?? "local";
				if (
					((this.validator[type2] = {
						body: hook.body ?? this.validator[type2]?.body,
						headers: hook.headers ?? this.validator[type2]?.headers,
						params: hook.params ?? this.validator[type2]?.params,
						query: hook.query ?? this.validator[type2]?.query,
						response: hook.response ?? this.validator[type2]?.response,
						cookie: hook.cookie ?? this.validator[type2]?.cookie,
					}),
					hook.parse)
				)
					this.on({ as: type2 }, "parse", hook.parse);
				if (hook.transform) this.on({ as: type2 }, "transform", hook.transform);
				if (hook.derive) this.on({ as: type2 }, "derive", hook.derive);
				if (hook.beforeHandle)
					this.on({ as: type2 }, "beforeHandle", hook.beforeHandle);
				if (hook.resolve) this.on({ as: type2 }, "resolve", hook.resolve);
				if (hook.afterHandle)
					this.on({ as: type2 }, "afterHandle", hook.afterHandle);
				if (hook.mapResponse)
					this.on({ as: type2 }, "mapResponse", hook.mapResponse);
				if (hook.afterResponse)
					this.on({ as: type2 }, "afterResponse", hook.afterResponse);
				if (hook.error) this.on({ as: type2 }, "error", hook.error);
				if (hook.detail)
					if (this.config.detail)
						this.config.detail = mergeDeep(
							Object.assign({}, this.config.detail),
							hook.detail,
						);
					else this.config.detail = hook.detail;
				if (hook?.tags)
					if (!this.config.detail) this.config.detail = { tags: hook.tags };
					else this.config.detail.tags = hook.tags;
				return this;
			}
			return this.guard({}, hook);
		}
		let instance = new Elysia({ ...this.config, prefix: "" });
		(instance.singleton = { ...this.singleton }),
			(instance.definitions = { ...this.definitions }),
			(instance.inference = cloneInference(this.inference)),
			(instance.extender = { ...this.extender });
		let sandbox = run(instance);
		if (
			((this.singleton = mergeDeep(this.singleton, instance.singleton)),
			(this.definitions = mergeDeep(this.definitions, instance.definitions)),
			(sandbox.getServer = () => this.server),
			sandbox.event.request?.length)
		)
			this.event.request = [
				...(this.event.request || []),
				...(sandbox.event.request || []),
			];
		if (sandbox.event.mapResponse?.length)
			this.event.mapResponse = [
				...(this.event.mapResponse || []),
				...(sandbox.event.mapResponse || []),
			];
		return (
			this.model(sandbox.definitions.type),
			Object.values(instance.router.history).forEach(
				({ method, path, handler, hooks: localHook }) => {
					this.add(
						method,
						path,
						handler,
						mergeHook(hook, {
							...(localHook || {}),
							error: !localHook.error
								? sandbox.event.error
								: Array.isArray(localHook.error)
									? [...(localHook.error || {}), ...(sandbox.event.error || [])]
									: [localHook.error, ...(sandbox.event.error || [])],
						}),
					);
				},
			),
			this
		);
	}
	use(plugin, options) {
		if (Array.isArray(plugin)) {
			let app = this;
			for (let p of plugin) app = app.use(p);
			return app;
		}
		if (options?.scoped) return this.guard({}, (app) => app.use(plugin));
		if (Array.isArray(plugin)) {
			let current = this;
			for (let p of plugin) current = this.use(p);
			return current;
		}
		if (plugin instanceof Promise)
			return (
				this.promisedModules.add(
					plugin
						.then((plugin2) => {
							if (typeof plugin2 === "function") return plugin2(this);
							if (plugin2 instanceof Elysia)
								return this._use(plugin2).compile();
							if (plugin2.constructor.name === "Elysia")
								return this._use(plugin2).compile();
							if (typeof plugin2.default === "function")
								return plugin2.default(this);
							if (plugin2.default instanceof Elysia)
								return this._use(plugin2.default);
							if (plugin2.constructor.name === "Elysia")
								return this._use(plugin2.default);
							if (plugin2.constructor.name === "_Elysia")
								return this._use(plugin2.default);
							try {
								return this._use(plugin2.default);
							} catch (error2) {
								throw (
									(console.error(
										'Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.',
									),
									error2)
								);
							}
						})
						.then((v) => {
							if (v && typeof v.compile === "function") v.compile();
							return v;
						}),
				),
				this
			);
		return this._use(plugin);
	}
	propagatePromiseModules(plugin) {
		if (plugin.promisedModules.size <= 0) return this;
		for (let promise of plugin.promisedModules.promises)
			this.promisedModules.add(
				promise.then((v) => {
					if (!v) return;
					let t3 = this._use(v);
					if (t3 instanceof Promise)
						return t3.then((v2) => {
							if (v2) v2.compile();
							else v.compile();
						});
					return v.compile();
				}),
			);
		return this;
	}
	_use(plugin) {
		if (typeof plugin === "function") {
			let instance = plugin(this);
			if (instance instanceof Promise)
				return (
					this.promisedModules.add(
						instance
							.then((plugin2) => {
								if (plugin2 instanceof Elysia) {
									(plugin2.getServer = () => this.getServer()),
										(plugin2.getGlobalRoutes = () => this.getGlobalRoutes()),
										plugin2.model(this.definitions.type),
										plugin2.error(this.definitions.error);
									for (let { method, path, handler, hooks } of Object.values(
										plugin2.router.history,
									))
										this.add(
											method,
											path,
											handler,
											mergeHook(hooks, { error: plugin2.event.error }),
										);
									if ((plugin2.compile(), plugin2 === this)) return;
									return this.propagatePromiseModules(plugin2), plugin2;
								}
								if (typeof plugin2 === "function") return plugin2(this);
								if (typeof plugin2.default === "function")
									return plugin2.default(this);
								return this._use(plugin2);
							})
							.then((v) => {
								if (v && typeof v.compile === "function") v.compile();
								return v;
							}),
					),
					this
				);
			return instance;
		}
		this.propagatePromiseModules(plugin);
		let { name, seed } = plugin.config;
		if (
			((plugin.getParent = () => this),
			(plugin.getServer = () => this.getServer()),
			(plugin.getGlobalRoutes = () => this.getGlobalRoutes()),
			plugin.model(this.definitions.type),
			plugin.error(this.definitions.error),
			(this["~parser"] = { ...plugin["~parser"], ...this["~parser"] }),
			this.headers(plugin.setHeaders),
			name)
		) {
			if (!(name in this.dependencies)) this.dependencies[name] = [];
			let current = seed !== void 0 ? checksum(name + JSON.stringify(seed)) : 0;
			if (
				!this.dependencies[name].some(
					({ checksum: checksum3 }) => current === checksum3,
				)
			)
				(this.extender.macros = this.extender.macros.concat(
					plugin.extender.macros,
				)),
					(this.extender.higherOrderFunctions =
						this.extender.higherOrderFunctions.concat(
							plugin.extender.higherOrderFunctions,
						));
		} else
			(this.extender.macros = this.extender.macros.concat(
				plugin.extender.macros,
			)),
				(this.extender.higherOrderFunctions =
					this.extender.higherOrderFunctions.concat(
						plugin.extender.higherOrderFunctions,
					));
		deduplicateChecksum(this.extender.macros),
			deduplicateChecksum(this.extender.higherOrderFunctions);
		let hofHashes = [];
		for (let i = 0; i < this.extender.higherOrderFunctions.length; i++) {
			let hof = this.extender.higherOrderFunctions[i];
			if (hof.checksum) {
				if (hofHashes.includes(hof.checksum))
					this.extender.higherOrderFunctions.splice(i, 1), i--;
				hofHashes.push(hof.checksum);
			}
		}
		(this.inference = {
			body: this.inference.body || plugin.inference.body,
			cookie: this.inference.cookie || plugin.inference.cookie,
			headers: this.inference.headers || plugin.inference.headers,
			query: this.inference.query || plugin.inference.query,
			set: this.inference.set || plugin.inference.set,
			server: this.inference.server || plugin.inference.server,
			request: this.inference.request || plugin.inference.request,
			route: this.inference.route || plugin.inference.route,
		}),
			this.decorate(plugin.singleton.decorator),
			this.state(plugin.singleton.store),
			this.model(plugin.definitions.type),
			this.error(plugin.definitions.error),
			(plugin.extender.macros = this.extender.macros.concat(
				plugin.extender.macros,
			));
		for (let { method, path, handler, hooks } of Object.values(
			plugin.router.history,
		))
			this.add(
				method,
				path,
				handler,
				mergeHook(hooks, { error: plugin.event.error }),
			);
		if (name) {
			if (!(name in this.dependencies)) this.dependencies[name] = [];
			let current = seed !== void 0 ? checksum(name + JSON.stringify(seed)) : 0;
			if (
				this.dependencies[name].some(
					({ checksum: checksum3 }) => current === checksum3,
				)
			)
				return this;
			this.dependencies[name].push(
				this.config?.analytic
					? {
							name: plugin.config.name,
							seed: plugin.config.seed,
							checksum: current,
							dependencies: plugin.dependencies,
							stack: plugin.telemetry.stack,
							routes: plugin.router.history,
							decorators: plugin.singleton,
							store: plugin.singleton.store,
							error: plugin.definitions.error,
							derive: plugin.event.transform
								?.filter((x) => x?.subType === "derive")
								.map((x) => ({
									fn: x.toString(),
									stack: new Error().stack ?? "",
								})),
							resolve: plugin.event.transform
								?.filter((x) => x?.subType === "resolve")
								.map((x) => ({
									fn: x.toString(),
									stack: new Error().stack ?? "",
								})),
						}
					: {
							name: plugin.config.name,
							seed: plugin.config.seed,
							checksum: current,
							dependencies: plugin.dependencies,
						},
			),
				(this.event = mergeLifeCycle(
					this.event,
					filterGlobalHook(plugin.event),
					current,
				));
		} else
			this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
		return (
			(this.validator.global = mergeHook(this.validator.global, {
				...plugin.validator.global,
			})),
			(this.validator.local = mergeHook(this.validator.local, {
				...plugin.validator.scoped,
			})),
			this
		);
	}
	macro(macro) {
		if (typeof macro === "function") {
			let hook = {
				checksum: checksum(
					JSON.stringify({
						name: this.config.name,
						seed: this.config.seed,
						content: macro.toString(),
					}),
				),
				fn: macro,
			};
			this.extender.macros.push(hook);
		} else if (typeof macro === "object") {
			for (let name of Object.keys(macro))
				if (typeof macro[name] === "object") {
					let actualValue = { ...macro[name] };
					macro[name] = (v) => {
						if (v === !0) return actualValue;
					};
				}
			let hook = {
				checksum: checksum(
					JSON.stringify({
						name: this.config.name,
						seed: this.config.seed,
						content: Object.entries(macro)
							.map(([k, v]) => `${k}+${v}`)
							.join(","),
					}),
				),
				fn: () => macro,
			};
			this.extender.macros.push(hook);
		}
		return this;
	}
	mount(path, handle) {
		if (
			path instanceof Elysia ||
			typeof path === "function" ||
			path.length === 0 ||
			path === "/"
		) {
			let run =
					typeof path === "function"
						? path
						: path instanceof Elysia
							? path.compile().fetch
							: handle instanceof Elysia
								? handle.compile().fetch
								: handle,
				handler2 = ({ request, path: path2 }) =>
					run(
						new Request(replaceUrlPath(request.url, path2), {
							method: request.method,
							headers: request.headers,
							signal: request.signal,
							credentials: request.credentials,
							referrerPolicy: request.referrerPolicy,
							duplex: request.duplex,
							redirect: request.redirect,
							mode: request.mode,
							keepalive: request.keepalive,
							integrity: request.integrity,
							body: request.body,
						}),
					);
			return this.all("/*", handler2, { parse: "none" }), this;
		}
		if (!handle) return this;
		let length = path.length - (path.endsWith("*") ? 1 : 0);
		if (handle instanceof Elysia) handle = handle.compile().fetch;
		let handler = ({ request, path: path2 }) =>
			handle(
				new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), {
					method: request.method,
					headers: request.headers,
					signal: request.signal,
					credentials: request.credentials,
					referrerPolicy: request.referrerPolicy,
					duplex: request.duplex,
					redirect: request.redirect,
					mode: request.mode,
					keepalive: request.keepalive,
					integrity: request.integrity,
					body: request.body,
				}),
			);
		return (
			this.all(path, handler, { parse: "none" }),
			this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
				parse: "none",
			}),
			this
		);
	}
	get(path, handler, hook) {
		return this.add("GET", path, handler, hook), this;
	}
	post(path, handler, hook) {
		return this.add("POST", path, handler, hook), this;
	}
	put(path, handler, hook) {
		return this.add("PUT", path, handler, hook), this;
	}
	patch(path, handler, hook) {
		return this.add("PATCH", path, handler, hook), this;
	}
	delete(path, handler, hook) {
		return this.add("DELETE", path, handler, hook), this;
	}
	options(path, handler, hook) {
		return this.add("OPTIONS", path, handler, hook), this;
	}
	all(path, handler, hook) {
		return this.add("ALL", path, handler, hook), this;
	}
	head(path, handler, hook) {
		return this.add("HEAD", path, handler, hook), this;
	}
	connect(path, handler, hook) {
		return this.add("CONNECT", path, handler, hook), this;
	}
	route(method, path, handler, hook) {
		return (
			this.add(method.toUpperCase(), path, handler, hook, hook?.config), this
		);
	}
	ws(path, options) {
		if (this["~adapter"].ws) this["~adapter"].ws(this, path, options);
		else console.warn("Current adapter doesn't support WebSocket");
		return this;
	}
	state(options, name, value) {
		if (name === void 0)
			(value = options), (options = { as: "append" }), (name = "");
		else if (value === void 0) {
			if (typeof options === "string")
				(value = name), (name = options), (options = { as: "append" });
			else if (typeof options === "object") (value = name), (name = "");
		}
		let { as } = options;
		if (typeof name !== "string") return this;
		switch (typeof value) {
			case "object":
				if (name) {
					if (name in this.singleton.store)
						this.singleton.store[name] = mergeDeep(
							this.singleton.store[name],
							value,
							{ override: as === "override" },
						);
					else this.singleton.store[name] = value;
					return this;
				}
				if (value === null) return this;
				return (
					(this.singleton.store = mergeDeep(this.singleton.store, value, {
						override: as === "override",
					})),
					this
				);
			case "function":
				if (name) {
					if (as === "override" || !(name in this.singleton.store))
						this.singleton.store[name] = value;
				} else this.singleton.store = value(this.singleton.store);
				return this;
			default:
				if (as === "override" || !(name in this.singleton.store))
					this.singleton.store[name] = value;
				return this;
		}
	}
	decorate(options, name, value) {
		if (name === void 0)
			(value = options), (options = { as: "append" }), (name = "");
		else if (value === void 0) {
			if (typeof options === "string")
				(value = name), (name = options), (options = { as: "append" });
			else if (typeof options === "object") (value = name), (name = "");
		}
		let { as } = options;
		if (typeof name !== "string") return this;
		switch (typeof value) {
			case "object":
				if (name) {
					if (name in this.singleton.decorator)
						this.singleton.decorator[name] = mergeDeep(
							this.singleton.decorator[name],
							value,
							{ override: as === "override" },
						);
					else this.singleton.decorator[name] = value;
					return this;
				}
				if (value === null) return this;
				return (
					(this.singleton.decorator = mergeDeep(
						this.singleton.decorator,
						value,
						{ override: as === "override" },
					)),
					this
				);
			case "function":
				if (name) {
					if (as === "override" || !(name in this.singleton.decorator))
						this.singleton.decorator[name] = value;
				} else this.singleton.decorator = value(this.singleton.decorator);
				return this;
			default:
				if (as === "override" || !(name in this.singleton.decorator))
					this.singleton.decorator[name] = value;
				return this;
		}
	}
	derive(optionsOrTransform, transform2) {
		if (!transform2)
			(transform2 = optionsOrTransform), (optionsOrTransform = { as: "local" });
		let hook = { subType: "derive", fn: transform2 };
		return this.onTransform(optionsOrTransform, hook);
	}
	model(name, model) {
		let coerce = (schema) =>
			replaceSchemaType(schema, [
				{
					from: t.Number(),
					to: (options) => t.Numeric(options),
					untilObjectFound: !0,
				},
				{
					from: t.Boolean(),
					to: (options) => t.BooleanString(options),
					untilObjectFound: !0,
				},
			]);
		switch (typeof name) {
			case "object":
				let parsedSchemas = {},
					kvs = Object.entries(name);
				for (let [key, value] of kvs) {
					if (key in this.definitions.type) continue;
					(parsedSchemas[key] = this.definitions.type[key] = coerce(value)),
						(parsedSchemas[key].$id ??= `#/components/schemas/${key}`);
				}
				return (
					(this.definitions.typebox = t.Module({
						...this.definitions.typebox.$defs,
						...parsedSchemas,
					})),
					this
				);
			case "function":
				let result = coerce(name(this.definitions.type));
				return (
					(this.definitions.type = result),
					(this.definitions.typebox = t.Module(result)),
					this
				);
			case "string":
				if (!model) break;
				let newModel = {
					...model,
					id: model.$id ?? `#/components/schemas/${name}`,
				};
				return (
					(this.definitions.type[name] = model),
					(this.definitions.typebox = t.Module({
						...this.definitions.typebox.$defs,
						...newModel,
					})),
					this
				);
		}
		return (
			(this.definitions.type[name] = model),
			(this.definitions.typebox = t.Module({
				...this.definitions.typebox.$defs,
				[name]: model,
			})),
			this
		);
	}
	mapDerive(optionsOrDerive, mapper) {
		if (!mapper)
			(mapper = optionsOrDerive), (optionsOrDerive = { as: "local" });
		let hook = { subType: "mapDerive", fn: mapper };
		return this.onTransform(optionsOrDerive, hook);
	}
	affix(base, type2, word) {
		if (word === "") return this;
		let delimieter = ["_", "-", " "],
			capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1),
			joinKey =
				base === "prefix"
					? (prefix, word2) =>
							delimieter.includes(prefix.at(-1) ?? "")
								? prefix + word2
								: prefix + capitalize(word2)
					: delimieter.includes(word.at(-1) ?? "")
						? (suffix, word2) => word2 + suffix
						: (suffix, word2) => word2 + capitalize(suffix),
			remap = (type22) => {
				let store = {};
				switch (type22) {
					case "decorator":
						for (let key in this.singleton.decorator)
							store[joinKey(word, key)] = this.singleton.decorator[key];
						this.singleton.decorator = store;
						break;
					case "state":
						for (let key in this.singleton.store)
							store[joinKey(word, key)] = this.singleton.store[key];
						this.singleton.store = store;
						break;
					case "model":
						for (let key in this.definitions.type)
							store[joinKey(word, key)] = this.definitions.type[key];
						this.definitions.type = store;
						break;
					case "error":
						for (let key in this.definitions.error)
							store[joinKey(word, key)] = this.definitions.error[key];
						this.definitions.error = store;
						break;
				}
			},
			types = Array.isArray(type2) ? type2 : [type2];
		for (let type22 of types.some((x) => x === "all")
			? ["decorator", "state", "model", "error"]
			: types)
			remap(type22);
		return this;
	}
	prefix(type2, word) {
		return this.affix("prefix", type2, word);
	}
	suffix(type2, word) {
		return this.affix("suffix", type2, word);
	}
	compile() {
		if (this["~adapter"].isWebStandard) {
			if (
				((this.fetch = this.config.aot
					? composeGeneralHandler(this)
					: createDynamicHandler(this)),
				typeof this.server?.reload === "function")
			)
				this.server.reload({ ...(this.server || {}), fetch: this.fetch });
			return this;
		}
		if (typeof this.server?.reload === "function")
			this.server.reload(this.server || {});
		return (this._handle = composeGeneralHandler(this)), this;
	}
	get modules() {
		return this.promisedModules;
	}
}
import { createHash } from "node:crypto";
var md5 = (data) => createHash("md5").update(data).digest("hex"),
	makeRepeated = (arr, repeats) =>
		Array.from({ length: repeats }, () => arr).flat();
function getHashedPercentateForObjIds(objectIds, iterations = 1) {
	let toHash = makeRepeated(objectIds, iterations).join(","),
		hashedValue = md5(toHash),
		hashedInt = BigInt("0x" + hashedValue),
		value = (Number(hashedInt % 9999n) / 9998) * 100;
	if (value === 100)
		return getHashedPercentateForObjIds(objectIds, iterations + 1);
	return value;
}
var ALL_RULE = "ALL",
	ANY_RULE = "ANY",
	NONE_RULE = "NONE";
var NOT_CONTAINS = "NOT_CONTAINS";
var REGEX = "REGEX",
	PERCENTAGE_SPLIT = "PERCENTAGE_SPLIT",
	IS_SET = "IS_SET",
	IS_NOT_SET = "IS_NOT_SET",
	MODULO = "MODULO",
	IN = "IN",
	CONDITION_OPERATORS = {
		EQUAL: "EQUAL",
		GREATER_THAN: "GREATER_THAN",
		LESS_THAN: "LESS_THAN",
		LESS_THAN_INCLUSIVE: "LESS_THAN_INCLUSIVE",
		CONTAINS: "CONTAINS",
		GREATER_THAN_INCLUSIVE: "GREATER_THAN_INCLUSIVE",
		NOT_CONTAINS: "NOT_CONTAINS",
		NOT_EQUAL: "NOT_EQUAL",
		REGEX: "REGEX",
		PERCENTAGE_SPLIT: "PERCENTAGE_SPLIT",
		IS_SET: "IS_SET",
		IS_NOT_SET: "IS_NOT_SET",
		MODULO: "MODULO",
		IN: "IN",
	};
function getIdentitySegments(environment, identity, overrideTraits) {
	return environment.project.segments.filter((segment) =>
		evaluateIdentityInSegment(identity, segment, overrideTraits),
	);
}
function evaluateIdentityInSegment(identity, segment, overrideTraits) {
	return (
		segment.rules.length > 0 &&
		segment.rules.filter((rule) =>
			traitsMatchSegmentRule(
				overrideTraits || identity.identityTraits,
				rule,
				segment.id,
				identity.djangoID || identity.compositeKey,
			),
		).length === segment.rules.length
	);
}
function traitsMatchSegmentRule(identityTraits, rule, segmentId, identityId) {
	return (
		(rule.conditions.length > 0
			? rule.matchingFunction()(
					rule.conditions.map((condition) =>
						traitsMatchSegmentCondition(
							identityTraits,
							condition,
							segmentId,
							identityId,
						),
					),
				)
			: !0) &&
		rule.rules.filter((rule2) =>
			traitsMatchSegmentRule(identityTraits, rule2, segmentId, identityId),
		).length === rule.rules.length
	);
}
function traitsMatchSegmentCondition(
	identityTraits,
	condition,
	segmentId,
	identityId,
) {
	if (condition.operator == PERCENTAGE_SPLIT) {
		var hashedPercentage = getHashedPercentateForObjIds([
			segmentId,
			identityId,
		]);
		return hashedPercentage <= parseFloat(String(condition.value));
	}
	let traits = identityTraits.filter(
			(t2) => t2.traitKey === condition.property_,
		),
		trait = traits.length > 0 ? traits[0] : void 0;
	if (condition.operator === IS_SET) return !!trait;
	else if (condition.operator === IS_NOT_SET) return trait == null;
	return trait ? condition.matchesTraitValue(trait.traitValue) : !1;
}
class EnvironmentModel {
	id;
	apiKey;
	project;
	featureStates = [];
	identityOverrides = [];
	constructor(id, apiKey, project) {
		(this.id = id), (this.apiKey = apiKey), (this.project = project);
	}
}
import { randomUUID as uuidv4 } from "node:crypto";
class FeatureModel {
	id;
	name;
	type;
	constructor(id, name, type2) {
		(this.id = id), (this.name = name), (this.type = type2);
	}
	eq(other) {
		return !!other && this.id === other.id;
	}
}
class MultivariateFeatureOptionModel {
	value;
	id;
	constructor(value, id) {
		(this.value = value), (this.id = id);
	}
}
class MultivariateFeatureStateValueModel {
	multivariateFeatureOption;
	percentageAllocation;
	id;
	mvFsValueUuid = uuidv4();
	constructor(
		multivariate_feature_option,
		percentage_allocation,
		id,
		mvFsValueUuid,
	) {
		(this.id = id),
			(this.percentageAllocation = percentage_allocation),
			(this.multivariateFeatureOption = multivariate_feature_option),
			(this.mvFsValueUuid = mvFsValueUuid || this.mvFsValueUuid);
	}
}
class FeatureStateModel {
	feature;
	enabled;
	djangoID;
	featurestateUUID = uuidv4();
	featureSegment;
	value;
	multivariateFeatureStateValues = [];
	constructor(feature, enabled, djangoID, value, featurestateUuid = uuidv4()) {
		(this.feature = feature),
			(this.enabled = enabled),
			(this.djangoID = djangoID),
			(this.value = value),
			(this.featurestateUUID = featurestateUuid);
	}
	setValue(value) {
		this.value = value;
	}
	getValue(identityId) {
		if (!!identityId && this.multivariateFeatureStateValues.length > 0)
			return this.getMultivariateValue(identityId);
		return this.value;
	}
	isHigherSegmentPriority(other) {
		if (!other.featureSegment || !this.featureSegment)
			return !!this.featureSegment && !other.featureSegment;
		return this.featureSegment.priority < other.featureSegment.priority;
	}
	getMultivariateValue(identityID) {
		let percentageValue,
			startPercentage = 0,
			sortedF = this.multivariateFeatureStateValues.sort((a, b) => {
				return a.id - b.id;
			});
		for (let myValue of sortedF) {
			switch (myValue.percentageAllocation) {
				case 0:
					continue;
				case 100:
					return myValue.multivariateFeatureOption.value;
				default:
					if (percentageValue === void 0)
						percentageValue = getHashedPercentateForObjIds([
							this.djangoID || this.featurestateUUID,
							identityID,
						]);
			}
			let limit = myValue.percentageAllocation + startPercentage;
			if (startPercentage <= percentageValue && percentageValue < limit)
				return myValue.multivariateFeatureOption.value;
			startPercentage = limit;
		}
		return this.value;
	}
}
class FeatureSegment {
	priority;
	constructor(priority) {
		this.priority = priority;
	}
}
class IdentityFeaturesList extends Array {}
import { randomUUID as uuidv42 } from "node:crypto";
class IdentityModel {
	identifier;
	environmentApiKey;
	createdDate;
	identityFeatures;
	identityTraits;
	identityUuid;
	djangoID;
	constructor(
		created_date,
		identityTraits,
		identityFeatures,
		environmentApiKey,
		identifier,
		identityUuid,
		djangoID,
	) {
		(this.identityUuid = identityUuid || uuidv42()),
			(this.createdDate = Date.parse(created_date) || Date.now()),
			(this.identityTraits = identityTraits),
			(this.identityFeatures = new IdentityFeaturesList(...identityFeatures)),
			(this.environmentApiKey = environmentApiKey),
			(this.identifier = identifier),
			(this.djangoID = djangoID);
	}
	get compositeKey() {
		return IdentityModel.generateCompositeKey(
			this.environmentApiKey,
			this.identifier,
		);
	}
	static generateCompositeKey(env_key, identifier) {
		return `${env_key}_${identifier}`;
	}
	updateTraits(traits) {
		let existingTraits = new Map();
		for (let trait of this.identityTraits)
			existingTraits.set(trait.traitKey, trait);
		for (let trait of traits)
			if (trait.traitValue) existingTraits.set(trait.traitKey, trait);
			else existingTraits.delete(trait.traitKey);
		this.identityTraits = [];
		for (let [k, v] of existingTraits.entries()) this.identityTraits.push(v);
	}
}
class TraitModel {
	traitKey;
	traitValue;
	constructor(key, value) {
		(this.traitKey = key), (this.traitValue = value);
	}
}
var semver = __toESM(require_semver2(), 1);
function buildFeatureModel(featuresModelJSON) {
	return new FeatureModel(
		featuresModelJSON.id,
		featuresModelJSON.name,
		featuresModelJSON.type,
	);
}
function buildFeatureStateModel(featuresStateModelJSON) {
	let featureStateModel = new FeatureStateModel(
		buildFeatureModel(featuresStateModelJSON.feature),
		featuresStateModelJSON.enabled,
		featuresStateModelJSON.django_id,
		featuresStateModelJSON.feature_state_value,
		featuresStateModelJSON.featurestate_uuid,
	);
	featureStateModel.featureSegment = featuresStateModelJSON.feature_segment
		? buildFeatureSegment(featuresStateModelJSON.feature_segment)
		: void 0;
	let multivariateFeatureStateValues =
		featuresStateModelJSON.multivariate_feature_state_values
			? featuresStateModelJSON.multivariate_feature_state_values.map((fsv) => {
					let featureOption = new MultivariateFeatureOptionModel(
						fsv.multivariate_feature_option.value,
						fsv.multivariate_feature_option.id,
					);
					return new MultivariateFeatureStateValueModel(
						featureOption,
						fsv.percentage_allocation,
						fsv.id,
						fsv.mv_fs_value_uuid,
					);
				})
			: [];
	return (
		(featureStateModel.multivariateFeatureStateValues =
			multivariateFeatureStateValues),
		featureStateModel
	);
}
function buildFeatureSegment(featureSegmentJSON) {
	return new FeatureSegment(featureSegmentJSON.priority);
}
function buildSegmentConditionModel(segmentConditionJSON) {
	return new SegmentConditionModel(
		segmentConditionJSON.operator,
		segmentConditionJSON.value,
		segmentConditionJSON.property_,
	);
}
function buildSegmentRuleModel(ruleModelJSON) {
	let ruleModel = new SegmentRuleModel(ruleModelJSON.type);
	return (
		(ruleModel.rules = ruleModelJSON.rules.map((r) =>
			buildSegmentRuleModel(r),
		)),
		(ruleModel.conditions = ruleModelJSON.conditions.map((c) =>
			buildSegmentConditionModel(c),
		)),
		ruleModel
	);
}
function buildSegmentModel(segmentModelJSON) {
	let model = new SegmentModel(segmentModelJSON.id, segmentModelJSON.name);
	return (
		(model.featureStates = segmentModelJSON.feature_states.map((fs) =>
			buildFeatureStateModel(fs),
		)),
		(model.rules = segmentModelJSON.rules.map((r) => buildSegmentRuleModel(r))),
		model
	);
}
function isSemver(value) {
	return typeof value == "string" && value.endsWith(":semver");
}
function removeSemverSuffix(value) {
	return value.replace(":semver", "");
}
function getCastingFunction(traitType) {
	switch (traitType) {
		case "boolean":
			return (x) => !["False", "false"].includes(x);
		case "number":
			return (x) => parseFloat(x);
		case "semver":
			return (x) => removeSemverSuffix(x);
		default:
			return (x) => String(x);
	}
}
var all = (iterable) => iterable.filter((e) => !!e).length === iterable.length,
	any = (iterable) => iterable.filter((e) => !!e).length > 0,
	matchingFunctions = {
		[CONDITION_OPERATORS.EQUAL]: (thisValue, otherValue) =>
			thisValue == otherValue,
		[CONDITION_OPERATORS.GREATER_THAN]: (thisValue, otherValue) =>
			otherValue > thisValue,
		[CONDITION_OPERATORS.GREATER_THAN_INCLUSIVE]: (thisValue, otherValue) =>
			otherValue >= thisValue,
		[CONDITION_OPERATORS.LESS_THAN]: (thisValue, otherValue) =>
			thisValue > otherValue,
		[CONDITION_OPERATORS.LESS_THAN_INCLUSIVE]: (thisValue, otherValue) =>
			thisValue >= otherValue,
		[CONDITION_OPERATORS.NOT_EQUAL]: (thisValue, otherValue) =>
			thisValue != otherValue,
		[CONDITION_OPERATORS.CONTAINS]: (thisValue, otherValue) =>
			!!otherValue && otherValue.includes(thisValue),
	},
	semverMatchingFunction = {
		...matchingFunctions,
		[CONDITION_OPERATORS.EQUAL]: (thisValue, otherValue) =>
			semver.eq(thisValue, otherValue),
		[CONDITION_OPERATORS.GREATER_THAN]: (thisValue, otherValue) =>
			semver.gt(otherValue, thisValue),
		[CONDITION_OPERATORS.GREATER_THAN_INCLUSIVE]: (thisValue, otherValue) =>
			semver.gte(otherValue, thisValue),
		[CONDITION_OPERATORS.LESS_THAN]: (thisValue, otherValue) =>
			semver.gt(thisValue, otherValue),
		[CONDITION_OPERATORS.LESS_THAN_INCLUSIVE]: (thisValue, otherValue) =>
			semver.gte(thisValue, otherValue),
	},
	getMatchingFunctions = (semver2) =>
		semver2 ? semverMatchingFunction : matchingFunctions;
class SegmentConditionModel {
	EXCEPTION_OPERATOR_METHODS = {
		[NOT_CONTAINS]: "evaluateNotContains",
		[REGEX]: "evaluateRegex",
		[MODULO]: "evaluateModulo",
		[IN]: "evaluateIn",
	};
	operator;
	value;
	property_;
	constructor(operator, value, property) {
		(this.operator = operator),
			(this.value = value),
			(this.property_ = property);
	}
	matchesTraitValue(traitValue) {
		let evaluators = {
			evaluateNotContains: (traitValue2) => {
				return (
					typeof traitValue2 == "string" &&
					!!this.value &&
					!traitValue2.includes(this.value?.toString())
				);
			},
			evaluateRegex: (traitValue2) => {
				return (
					!!this.value &&
					!!traitValue2?.toString().match(new RegExp(this.value))
				);
			},
			evaluateModulo: (traitValue2) => {
				if (isNaN(parseFloat(traitValue2)) || !this.value) return !1;
				let parts = this.value.split("|"),
					[divisor, reminder] = [parseFloat(parts[0]), parseFloat(parts[1])];
				return traitValue2 % divisor === reminder;
			},
			evaluateIn: (traitValue2) => {
				return this.value?.split(",").includes(traitValue2.toString());
			},
		};
		if (this.EXCEPTION_OPERATOR_METHODS[this.operator]) {
			let evaluatorFunction =
				evaluators[this.EXCEPTION_OPERATOR_METHODS[this.operator]];
			return evaluatorFunction(traitValue);
		}
		let defaultFunction = (x, y) => !1,
			matchingFunction =
				getMatchingFunctions(isSemver(this.value))[this.operator] ||
				defaultFunction,
			traitType = isSemver(this.value) ? "semver" : typeof traitValue,
			castToTypeOfTraitValue = getCastingFunction(traitType);
		return matchingFunction(castToTypeOfTraitValue(this.value), traitValue);
	}
}
class SegmentRuleModel {
	type;
	rules = [];
	conditions = [];
	constructor(type2) {
		this.type = type2;
	}
	static none(iterable) {
		return iterable.filter((e) => !!e).length === 0;
	}
	matchingFunction() {
		return {
			[ANY_RULE]: any,
			[ALL_RULE]: all,
			[NONE_RULE]: SegmentRuleModel.none,
		}[this.type];
	}
}
class SegmentModel {
	id;
	name;
	rules = [];
	featureStates = [];
	constructor(id, name) {
		(this.id = id), (this.name = name);
	}
}
class OrganisationModel {
	id;
	name;
	featureAnalytics;
	stopServingFlags;
	persistTraitData;
	constructor(id, name, featureAnalytics, stopServingFlags, persistTraitData) {
		(this.id = id),
			(this.name = name),
			(this.featureAnalytics = featureAnalytics),
			(this.stopServingFlags = stopServingFlags),
			(this.persistTraitData = persistTraitData);
	}
	get uniqueSlug() {
		return this.id.toString() + "-" + this.name;
	}
}
function getIdentityFeatureStatesDict(environment, identity, overrideTraits) {
	let featureStates = {};
	for (let fs of environment.featureStates) featureStates[fs.feature.id] = fs;
	let identitySegments = getIdentitySegments(
		environment,
		identity,
		overrideTraits,
	);
	for (let matchingSegment of identitySegments)
		for (let featureState of matchingSegment.featureStates) {
			if (featureStates[featureState.feature.id]) {
				if (
					featureStates[featureState.feature.id].isHigherSegmentPriority(
						featureState,
					)
				)
					continue;
			}
			featureStates[featureState.feature.id] = featureState;
		}
	for (let fs of identity.identityFeatures)
		if (featureStates[fs.feature.id]) featureStates[fs.feature.id] = fs;
	return featureStates;
}
function getIdentityFeatureStates(environment, identity, overrideTraits) {
	let featureStates = Object.values(
		getIdentityFeatureStatesDict(environment, identity, overrideTraits),
	);
	if (environment.project.hideDisabledFlags)
		return featureStates.filter((fs) => !!fs.enabled);
	return featureStates;
}
function getEnvironmentFeatureStates(environment) {
	if (environment.project.hideDisabledFlags)
		return environment.featureStates.filter((fs) => !!fs.enabled);
	return environment.featureStates;
}
function buildTraitModel(traitJSON) {
	return new TraitModel(traitJSON.trait_key, traitJSON.trait_value);
}
function buildIdentityModel(identityJSON) {
	let featureList = identityJSON.identity_features
			? new IdentityFeaturesList(
					...identityJSON.identity_features.map((f) =>
						buildFeatureStateModel(f),
					),
				)
			: [],
		model = new IdentityModel(
			identityJSON.created_date,
			identityJSON.identity_traits
				? identityJSON.identity_traits.map((trait) => buildTraitModel(trait))
				: [],
			featureList,
			identityJSON.environment_api_key,
			identityJSON.identifier,
			identityJSON.identity_uuid,
		);
	return (model.djangoID = identityJSON.django_id), model;
}
function buildOrganizationModel(organizationJSON) {
	return new OrganisationModel(
		organizationJSON.id,
		organizationJSON.name,
		organizationJSON.feature_analytics,
		organizationJSON.stop_serving_flags,
		organizationJSON.persist_trait_data,
	);
}
class ProjectModel {
	id;
	name;
	organisation;
	hideDisabledFlags;
	segments = [];
	constructor(id, name, hideDisabledFlags, organization) {
		(this.id = id),
			(this.name = name),
			(this.hideDisabledFlags = hideDisabledFlags),
			(this.organisation = organization);
	}
}
function buildProjectModel(projectJSON) {
	let segments = projectJSON.segments
			? projectJSON.segments.map((s) => buildSegmentModel(s))
			: [],
		model = new ProjectModel(
			projectJSON.id,
			projectJSON.name,
			projectJSON.hide_disabled_flags,
			buildOrganizationModel(projectJSON.organisation),
		);
	return (model.segments = segments), model;
}
function buildEnvironmentModel(environmentJSON) {
	let project = buildProjectModel(environmentJSON.project),
		featureStates = environmentJSON.feature_states.map((fs) =>
			buildFeatureStateModel(fs),
		),
		environmentModel = new EnvironmentModel(
			environmentJSON.id,
			environmentJSON.api_key,
			project,
		);
	if (
		((environmentModel.featureStates = featureStates),
		environmentJSON.identity_overrides)
	)
		environmentModel.identityOverrides = environmentJSON.identity_overrides.map(
			(identityData) => buildIdentityModel(identityData),
		);
	return environmentModel;
}
var import_pino = __toESM(require_pino(), 1),
	ANALYTICS_ENDPOINT = "./analytics/flags/",
	ANALYTICS_TIMER = 10,
	DEFAULT_REQUEST_TIMEOUT_MS = 3000;
class AnalyticsProcessor {
	analyticsUrl;
	environmentKey;
	lastFlushed;
	analyticsData;
	requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT_MS;
	logger;
	currentFlush;
	customFetch;
	constructor(data) {
		(this.analyticsUrl =
			data.analyticsUrl || data.baseApiUrl + ANALYTICS_ENDPOINT),
			(this.environmentKey = data.environmentKey),
			(this.lastFlushed = Date.now()),
			(this.analyticsData = {}),
			(this.requestTimeoutMs = data.requestTimeoutMs || this.requestTimeoutMs),
			(this.logger = data.logger || import_pino.pino()),
			(this.customFetch = data.fetch ?? fetch);
	}
	async flush() {
		if (this.currentFlush || !Object.keys(this.analyticsData).length) return;
		try {
			(this.currentFlush = this.customFetch(this.analyticsUrl, {
				method: "POST",
				body: JSON.stringify(this.analyticsData),
				signal: AbortSignal.timeout(this.requestTimeoutMs),
				headers: {
					"Content-Type": "application/json",
					"X-Environment-Key": this.environmentKey,
				},
			})),
				await this.currentFlush;
		} catch (error2) {
			this.logger.warn(
				"Failed to post analytics to Flagsmith API. Not clearing data, will retry.",
			);
			return;
		} finally {
			this.currentFlush = void 0;
		}
		(this.analyticsData = {}), (this.lastFlushed = Date.now());
	}
	trackFeature(featureName) {
		if (
			((this.analyticsData[featureName] =
				(this.analyticsData[featureName] || 0) + 1),
			Date.now() - this.lastFlushed > ANALYTICS_TIMER * 1000)
		)
			this.flush();
	}
}
class FlagsmithAPIError extends Error {}
class BaseFlag {
	enabled;
	value;
	isDefault;
	constructor(value, enabled, isDefault) {
		(this.value = value),
			(this.enabled = enabled),
			(this.isDefault = isDefault);
	}
}
class Flag extends BaseFlag {
	featureId;
	featureName;
	constructor(params) {
		super(params.value, params.enabled, !!params.isDefault);
		(this.featureId = params.featureId),
			(this.featureName = params.featureName);
	}
	static fromFeatureStateModel(fsm, identityId) {
		return new Flag({
			value: fsm.getValue(identityId),
			enabled: fsm.enabled,
			featureId: fsm.feature.id,
			featureName: fsm.feature.name,
		});
	}
	static fromAPIFlag(flagData) {
		return new Flag({
			enabled: flagData.enabled,
			value: flagData.feature_state_value ?? flagData.value,
			featureId: flagData.feature.id,
			featureName: flagData.feature.name,
		});
	}
}
class Flags {
	flags = {};
	defaultFlagHandler;
	analyticsProcessor;
	constructor(data) {
		(this.flags = data.flags),
			(this.defaultFlagHandler = data.defaultFlagHandler),
			(this.analyticsProcessor = data.analyticsProcessor);
	}
	static fromFeatureStateModels(data) {
		let flags = {};
		for (let fs of data.featureStates)
			flags[fs.feature.name] = Flag.fromFeatureStateModel(fs, data.identityID);
		return new Flags({
			flags,
			defaultFlagHandler: data.defaultFlagHandler,
			analyticsProcessor: data.analyticsProcessor,
		});
	}
	static fromAPIFlags(data) {
		let flags = {};
		for (let flagData of data.apiFlags)
			flags[flagData.feature.name] = Flag.fromAPIFlag(flagData);
		return new Flags({
			flags,
			defaultFlagHandler: data.defaultFlagHandler,
			analyticsProcessor: data.analyticsProcessor,
		});
	}
	allFlags() {
		return Object.values(this.flags);
	}
	getFlag(featureName) {
		let flag = this.flags[featureName];
		if (!flag) {
			if (this.defaultFlagHandler) return this.defaultFlagHandler(featureName);
			return { enabled: !1, isDefault: !0, value: void 0 };
		}
		if (this.analyticsProcessor && flag.featureId)
			this.analyticsProcessor.trackFeature(flag.featureName);
		return flag;
	}
	getFeatureValue(featureName) {
		return this.getFlag(featureName).value;
	}
	isFeatureEnabled(featureName) {
		return this.getFlag(featureName).enabled;
	}
}
class EnvironmentDataPollingManager {
	interval;
	main;
	refreshIntervalSeconds;
	constructor(main, refreshIntervalSeconds) {
		(this.main = main), (this.refreshIntervalSeconds = refreshIntervalSeconds);
	}
	start() {
		(() => {
			if (this.interval) clearInterval(this.interval);
			this.interval = setInterval(async () => {
				await this.main.updateEnvironment();
			}, this.refreshIntervalSeconds * 1000);
		})();
	}
	stop() {
		if (!this.interval) return;
		clearInterval(this.interval);
	}
}
function isTraitConfig(traitValue) {
	return (
		!!traitValue && typeof traitValue == "object" && traitValue.value !== void 0
	);
}
function generateIdentitiesData(identifier, traits, transient) {
	let traitsGenerated = Object.entries(traits).map(([key, value]) => {
		if (isTraitConfig(value))
			return {
				trait_key: key,
				trait_value: value?.value,
				transient: value?.transient,
			};
		else return { trait_key: key, trait_value: value };
	});
	if (transient) return { identifier, traits: traitsGenerated, transient: !0 };
	return { identifier, traits: traitsGenerated };
}
var delay = (ms) =>
		new Promise((resolve) => setTimeout(() => resolve(void 0), ms)),
	retryFetch = (
		url,
		fetchOptions,
		retries = 3,
		timeoutMs = 10,
		customFetch,
	) => {
		return new Promise((resolve, reject) => {
			let retryWrapper = (n) => {
				customFetch(url, {
					...fetchOptions,
					signal: AbortSignal.timeout(timeoutMs),
				})
					.then((res) => resolve(res))
					.catch(async (err) => {
						if (n > 0) await delay(1000), retryWrapper(--n);
						else reject(err);
					});
			};
			retryWrapper(retries);
		});
	};
var import_pino2 = __toESM(require_pino(), 1),
	DEFAULT_API_URL = "https://edge.api.flagsmith.com/api/v1/",
	DEFAULT_REQUEST_TIMEOUT_SECONDS = 10;
class Flagsmith {
	environmentKey = void 0;
	apiUrl = void 0;
	analyticsUrl = void 0;
	customHeaders;
	agent;
	requestTimeoutMs;
	enableLocalEvaluation = !1;
	environmentRefreshIntervalSeconds = 60;
	retries;
	enableAnalytics = !1;
	defaultFlagHandler;
	environmentFlagsUrl;
	identitiesUrl;
	environmentUrl;
	environmentDataPollingManager;
	environment;
	offlineMode = !1;
	offlineHandler = void 0;
	identitiesWithOverridesByIdentifier;
	cache;
	onEnvironmentChange;
	analyticsProcessor;
	logger;
	customFetch;
	constructor(data = {}) {
		if (
			((this.agent = data.agent),
			(this.customFetch = data.fetch ?? fetch),
			(this.environmentKey = data.environmentKey),
			(this.apiUrl = data.apiUrl || this.apiUrl),
			(this.customHeaders = data.customHeaders),
			(this.requestTimeoutMs =
				1000 * (data.requestTimeoutSeconds ?? DEFAULT_REQUEST_TIMEOUT_SECONDS)),
			(this.enableLocalEvaluation = data.enableLocalEvaluation),
			(this.environmentRefreshIntervalSeconds =
				data.environmentRefreshIntervalSeconds ||
				this.environmentRefreshIntervalSeconds),
			(this.retries = data.retries),
			(this.enableAnalytics = data.enableAnalytics || !1),
			(this.defaultFlagHandler = data.defaultFlagHandler),
			(this.onEnvironmentChange = data.onEnvironmentChange),
			(this.logger = data.logger || import_pino2.pino()),
			(this.offlineMode = data.offlineMode || !1),
			(this.offlineHandler = data.offlineHandler),
			this.offlineMode && !this.offlineHandler)
		)
			throw new Error(
				"ValueError: offlineHandler must be provided to use offline mode.",
			);
		else if (this.defaultFlagHandler && this.offlineHandler)
			throw new Error(
				"ValueError: Cannot use both defaultFlagHandler and offlineHandler.",
			);
		if (this.offlineHandler)
			this.environment = this.offlineHandler.getEnvironment();
		if (data.cache) this.cache = data.cache;
		if (!this.offlineMode) {
			if (!this.environmentKey)
				throw new Error("ValueError: environmentKey is required.");
			let apiUrl = data.apiUrl || DEFAULT_API_URL;
			if (
				((this.apiUrl = apiUrl.endsWith("/") ? apiUrl : `${apiUrl}/`),
				(this.analyticsUrl =
					this.analyticsUrl ||
					new URL(ANALYTICS_ENDPOINT, new Request(this.apiUrl).url).href),
				(this.environmentFlagsUrl = `${this.apiUrl}flags/`),
				(this.identitiesUrl = `${this.apiUrl}identities/`),
				(this.environmentUrl = `${this.apiUrl}environment-document/`),
				this.enableLocalEvaluation)
			) {
				if (!this.environmentKey.startsWith("ser."))
					console.error(
						"In order to use local evaluation, please generate a server key in the environment settings page.",
					);
				(this.environmentDataPollingManager = new EnvironmentDataPollingManager(
					this,
					this.environmentRefreshIntervalSeconds,
				)),
					this.environmentDataPollingManager.start(),
					this.updateEnvironment();
			}
			if (data.enableAnalytics)
				this.analyticsProcessor = new AnalyticsProcessor({
					environmentKey: this.environmentKey,
					analyticsUrl: this.analyticsUrl,
					requestTimeoutMs: this.requestTimeoutMs,
					logger: this.logger,
				});
		}
	}
	async getEnvironmentFlags() {
		let cachedItem = !!this.cache && (await this.cache.get("flags"));
		if (cachedItem) return cachedItem;
		if (this.enableLocalEvaluation && !this.offlineMode)
			return new Promise((resolve, reject) =>
				this.environmentPromise
					.then(() => {
						resolve(this.getEnvironmentFlagsFromDocument());
					})
					.catch((e) => reject(e)),
			);
		if (this.environment) return this.getEnvironmentFlagsFromDocument();
		return this.getEnvironmentFlagsFromApi();
	}
	async getIdentityFlags(identifier, traits, transient = !1) {
		if (!identifier)
			throw new Error("`identifier` argument is missing or invalid.");
		let cachedItem =
			!!this.cache && (await this.cache.get(`flags-${identifier}`));
		if (cachedItem) return cachedItem;
		if (((traits = traits || {}), this.enableLocalEvaluation))
			return new Promise((resolve, reject) =>
				this.environmentPromise
					.then(() => {
						resolve(
							this.getIdentityFlagsFromDocument(identifier, traits || {}),
						);
					})
					.catch((e) => reject(e)),
			);
		if (this.offlineMode)
			return this.getIdentityFlagsFromDocument(identifier, traits || {});
		return this.getIdentityFlagsFromApi(identifier, traits, transient);
	}
	getIdentitySegments(identifier, traits) {
		if (!identifier)
			throw new Error("`identifier` argument is missing or invalid.");
		if (((traits = traits || {}), this.enableLocalEvaluation))
			return new Promise((resolve, reject) => {
				return this.environmentPromise
					.then(() => {
						let identityModel = this.getIdentityModel(
								identifier,
								Object.keys(traits || {}).map((key) => ({
									key,
									value: traits?.[key],
								})),
							),
							segments = getIdentitySegments(this.environment, identityModel);
						return resolve(segments);
					})
					.catch((e) => reject(e));
			});
		return (
			console.error("This function is only permitted with local evaluation."),
			Promise.resolve([])
		);
	}
	async updateEnvironment() {
		try {
			let request = this.getEnvironmentFromApi();
			if (!this.environmentPromise)
				(this.environmentPromise = request.then((res) => {
					this.environment = res;
				})),
					await this.environmentPromise;
			else this.environment = await request;
			if (this.environment.identityOverrides?.length)
				this.identitiesWithOverridesByIdentifier = new Map(
					this.environment.identityOverrides.map((identity) => [
						identity.identifier,
						identity,
					]),
				);
			if (this.onEnvironmentChange)
				this.onEnvironmentChange(null, this.environment);
		} catch (e) {
			if (this.onEnvironmentChange)
				this.onEnvironmentChange(e, this.environment);
		}
	}
	async close() {
		this.environmentDataPollingManager?.stop();
	}
	async getJSONResponse(url, method, body) {
		let headers = { "Content-Type": "application/json" };
		if (this.environmentKey) headers["X-Environment-Key"] = this.environmentKey;
		if (this.customHeaders)
			for (let [k, v] of Object.entries(this.customHeaders)) headers[k] = v;
		let data = await retryFetch(
			url,
			{ dispatcher: this.agent, method, body: JSON.stringify(body), headers },
			this.retries,
			this.requestTimeoutMs,
			this.customFetch,
		);
		if (data.status !== 200)
			throw new FlagsmithAPIError(
				`Invalid request made to Flagsmith API. Response status code: ${data.status}`,
			);
		return data.json();
	}
	environmentPromise;
	async getEnvironmentFromApi() {
		if (!this.environmentUrl)
			throw new Error("`apiUrl` argument is missing or invalid.");
		let environment_data = await this.getJSONResponse(
			this.environmentUrl,
			"GET",
		);
		return buildEnvironmentModel(environment_data);
	}
	async getEnvironmentFlagsFromDocument() {
		let flags = Flags.fromFeatureStateModels({
			featureStates: getEnvironmentFeatureStates(this.environment),
			analyticsProcessor: this.analyticsProcessor,
			defaultFlagHandler: this.defaultFlagHandler,
		});
		if (this.cache) await this.cache.set("flags", flags);
		return flags;
	}
	async getIdentityFlagsFromDocument(identifier, traits) {
		let identityModel = this.getIdentityModel(
				identifier,
				Object.keys(traits).map((key) => ({ key, value: traits[key] })),
			),
			featureStates = getIdentityFeatureStates(this.environment, identityModel),
			flags = Flags.fromFeatureStateModels({
				featureStates,
				analyticsProcessor: this.analyticsProcessor,
				defaultFlagHandler: this.defaultFlagHandler,
				identityID: identityModel.djangoID || identityModel.compositeKey,
			});
		if (this.cache) await this.cache.set(`flags-${identifier}`, flags);
		return flags;
	}
	async getEnvironmentFlagsFromApi() {
		if (!this.environmentFlagsUrl)
			throw new Error("`apiUrl` argument is missing or invalid.");
		try {
			let apiFlags = await this.getJSONResponse(
					this.environmentFlagsUrl,
					"GET",
				),
				flags = Flags.fromAPIFlags({
					apiFlags,
					analyticsProcessor: this.analyticsProcessor,
					defaultFlagHandler: this.defaultFlagHandler,
				});
			if (this.cache) await this.cache.set("flags", flags);
			return flags;
		} catch (e) {
			if (this.offlineHandler) return this.getEnvironmentFlagsFromDocument();
			if (this.defaultFlagHandler)
				return new Flags({
					flags: {},
					defaultFlagHandler: this.defaultFlagHandler,
				});
			throw e;
		}
	}
	async getIdentityFlagsFromApi(identifier, traits, transient = !1) {
		if (!this.identitiesUrl)
			throw new Error("`apiUrl` argument is missing or invalid.");
		try {
			let data = generateIdentitiesData(identifier, traits, transient),
				jsonResponse = await this.getJSONResponse(
					this.identitiesUrl,
					"POST",
					data,
				),
				flags = Flags.fromAPIFlags({
					apiFlags: jsonResponse.flags,
					analyticsProcessor: this.analyticsProcessor,
					defaultFlagHandler: this.defaultFlagHandler,
				});
			if (this.cache) await this.cache.set(`flags-${identifier}`, flags);
			return flags;
		} catch (e) {
			if (this.offlineHandler)
				return this.getIdentityFlagsFromDocument(identifier, traits);
			if (this.defaultFlagHandler)
				return new Flags({
					flags: {},
					defaultFlagHandler: this.defaultFlagHandler,
				});
			throw e;
		}
	}
	getIdentityModel(identifier, traits) {
		let traitModels = traits.map(
				(trait) => new TraitModel(trait.key, trait.value),
			),
			identityWithOverrides =
				this.identitiesWithOverridesByIdentifier?.get(identifier);
		if (identityWithOverrides)
			return (
				identityWithOverrides.updateTraits(traitModels), identityWithOverrides
			);
		return new IdentityModel(
			"0",
			traitModels,
			[],
			this.environment.apiKey,
			identifier,
		);
	}
}
var flagsmith = new Flagsmith({
		environmentKey: process.env.FLAGSMITH_ENV_KEY,
	}),
	flagsmith_default = flagsmith;
var marker = "vercel.ai.error",
	symbol = Symbol.for(marker),
	_a,
	_AISDKError = class _AISDKError2 extends Error {
		constructor({ name: name14, message, cause }) {
			super(message);
			(this[_a] = !0), (this.name = name14), (this.cause = cause);
		}
		static isInstance(error2) {
			return _AISDKError2.hasMarker(error2, marker);
		}
		static hasMarker(error2, marker15) {
			let markerSymbol = Symbol.for(marker15);
			return (
				error2 != null &&
				typeof error2 === "object" &&
				markerSymbol in error2 &&
				typeof error2[markerSymbol] === "boolean" &&
				error2[markerSymbol] === !0
			);
		}
	};
_a = symbol;
var AISDKError = _AISDKError,
	name = "AI_APICallError",
	marker2 = `vercel.ai.error.${name}`,
	symbol2 = Symbol.for(marker2),
	_a2,
	APICallError = class extends AISDKError {
		constructor({
			message,
			url,
			requestBodyValues,
			statusCode,
			responseHeaders,
			responseBody,
			cause,
			isRetryable = statusCode != null &&
				(statusCode === 408 ||
					statusCode === 409 ||
					statusCode === 429 ||
					statusCode >= 500),
			data,
		}) {
			super({ name, message, cause });
			(this[_a2] = !0),
				(this.url = url),
				(this.requestBodyValues = requestBodyValues),
				(this.statusCode = statusCode),
				(this.responseHeaders = responseHeaders),
				(this.responseBody = responseBody),
				(this.isRetryable = isRetryable),
				(this.data = data);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker2);
		}
	};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError",
	marker3 = `vercel.ai.error.${name2}`,
	symbol3 = Symbol.for(marker3),
	_a3,
	EmptyResponseBodyError = class extends AISDKError {
		constructor({ message = "Empty response body" } = {}) {
			super({ name: name2, message });
			this[_a3] = !0;
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker3);
		}
	};
_a3 = symbol3;
function getErrorMessage(error2) {
	if (error2 == null) return "unknown error";
	if (typeof error2 === "string") return error2;
	if (error2 instanceof Error) return error2.message;
	return JSON.stringify(error2);
}
var name3 = "AI_InvalidArgumentError",
	marker4 = `vercel.ai.error.${name3}`,
	symbol4 = Symbol.for(marker4),
	_a4,
	InvalidArgumentError = class extends AISDKError {
		constructor({ message, cause, argument }) {
			super({ name: name3, message, cause });
			(this[_a4] = !0), (this.argument = argument);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker4);
		}
	};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError",
	marker5 = `vercel.ai.error.${name4}`,
	symbol5 = Symbol.for(marker5),
	_a5,
	InvalidPromptError = class extends AISDKError {
		constructor({ prompt, message, cause }) {
			super({ name: name4, message: `Invalid prompt: ${message}`, cause });
			(this[_a5] = !0), (this.prompt = prompt);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker5);
		}
	};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError",
	marker6 = `vercel.ai.error.${name5}`,
	symbol6 = Symbol.for(marker6),
	_a6,
	InvalidResponseDataError = class extends AISDKError {
		constructor({
			data,
			message = `Invalid response data: ${JSON.stringify(data)}.`,
		}) {
			super({ name: name5, message });
			(this[_a6] = !0), (this.data = data);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker6);
		}
	};
_a6 = symbol6;
var name6 = "AI_JSONParseError",
	marker7 = `vercel.ai.error.${name6}`,
	symbol7 = Symbol.for(marker7),
	_a7,
	JSONParseError = class extends AISDKError {
		constructor({ text, cause }) {
			super({
				name: name6,
				message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
				cause,
			});
			(this[_a7] = !0), (this.text = text);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker7);
		}
	};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError",
	marker8 = `vercel.ai.error.${name7}`,
	symbol8 = Symbol.for(marker8),
	_a8,
	LoadAPIKeyError = class extends AISDKError {
		constructor({ message }) {
			super({ name: name7, message });
			this[_a8] = !0;
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker8);
		}
	};
_a8 = symbol8;
var name8 = "AI_LoadSettingError",
	marker9 = `vercel.ai.error.${name8}`,
	symbol9 = Symbol.for(marker9),
	_a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError",
	marker10 = `vercel.ai.error.${name9}`,
	symbol10 = Symbol.for(marker10),
	_a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError",
	marker11 = `vercel.ai.error.${name10}`,
	symbol11 = Symbol.for(marker11),
	_a11,
	NoSuchModelError = class extends AISDKError {
		constructor({
			errorName = name10,
			modelId,
			modelType,
			message = `No such ${modelType}: ${modelId}`,
		}) {
			super({ name: errorName, message });
			(this[_a11] = !0), (this.modelId = modelId), (this.modelType = modelType);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker11);
		}
	};
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError",
	marker12 = `vercel.ai.error.${name11}`,
	symbol12 = Symbol.for(marker12),
	_a12;
_a12 = symbol12;
var name12 = "AI_TypeValidationError",
	marker13 = `vercel.ai.error.${name12}`,
	symbol13 = Symbol.for(marker13),
	_a13,
	_TypeValidationError = class _TypeValidationError2 extends AISDKError {
		constructor({ value, cause }) {
			super({
				name: name12,
				message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
				cause,
			});
			(this[_a13] = !0), (this.value = value);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker13);
		}
		static wrap({ value, cause }) {
			return _TypeValidationError2.isInstance(cause) && cause.value === value
				? cause
				: new _TypeValidationError2({ value, cause });
		}
	};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError,
	name13 = "AI_UnsupportedFunctionalityError",
	marker14 = `vercel.ai.error.${name13}`,
	symbol14 = Symbol.for(marker14),
	_a14,
	UnsupportedFunctionalityError = class extends AISDKError {
		constructor({
			functionality,
			message = `'${functionality}' functionality not supported.`,
		}) {
			super({ name: name13, message });
			(this[_a14] = !0), (this.functionality = functionality);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker14);
		}
	};
_a14 = symbol14;
var customAlphabet = (alphabet, defaultSize = 21) => {
	return (size = defaultSize) => {
		let id = "",
			i = size | 0;
		while (i--) id += alphabet[(Math.random() * alphabet.length) | 0];
		return id;
	};
};
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);
var __defProp2 = Object.defineProperty,
	__defNormalProp = (obj, key, value) =>
		key in obj
			? __defProp2(obj, key, {
					enumerable: !0,
					configurable: !0,
					writable: !0,
					value,
				})
			: (obj[key] = value),
	__publicField = (obj, key, value) =>
		__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value);
class ParseError3 extends Error {
	constructor(message, options) {
		super(message),
			__publicField(this, "type"),
			__publicField(this, "field"),
			__publicField(this, "value"),
			__publicField(this, "line"),
			(this.name = "ParseError"),
			(this.type = options.type),
			(this.field = options.field),
			(this.value = options.value),
			(this.line = options.line);
	}
}
function noop(_arg) {}
function createParser(callbacks) {
	let { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks,
		incompleteLine = "",
		isFirstChunk = !0,
		id,
		data = "",
		eventType = "";
	function feed(newChunk) {
		let chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk,
			[complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
		for (let line of complete) parseLine(line);
		(incompleteLine = incomplete), (isFirstChunk = !1);
	}
	function parseLine(line) {
		if (line === "") {
			dispatchEvent();
			return;
		}
		if (line.startsWith(":")) {
			onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
			return;
		}
		let fieldSeparatorIndex = line.indexOf(":");
		if (fieldSeparatorIndex !== -1) {
			let field = line.slice(0, fieldSeparatorIndex),
				offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1,
				value = line.slice(fieldSeparatorIndex + offset);
			processField(field, value, line);
			return;
		}
		processField(line, "", line);
	}
	function processField(field, value, line) {
		switch (field) {
			case "event":
				eventType = value;
				break;
			case "data":
				data = `${data}${value}
`;
				break;
			case "id":
				id = value.includes("\x00") ? void 0 : value;
				break;
			case "retry":
				/^\d+$/.test(value)
					? onRetry(parseInt(value, 10))
					: onError(
							new ParseError3(`Invalid \`retry\` value: "${value}"`, {
								type: "invalid-retry",
								value,
								line,
							}),
						);
				break;
			default:
				onError(
					new ParseError3(
						`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}…` : field}"`,
						{ type: "unknown-field", field, value, line },
					),
				);
				break;
		}
	}
	function dispatchEvent() {
		data.length > 0 &&
			onEvent({
				id,
				event: eventType || void 0,
				data: data.endsWith(`
`)
					? data.slice(0, -1)
					: data,
			}),
			(id = void 0),
			(data = ""),
			(eventType = "");
	}
	function reset(options = {}) {
		incompleteLine && options.consume && parseLine(incompleteLine),
			(id = void 0),
			(data = ""),
			(eventType = ""),
			(incompleteLine = "");
	}
	return { feed, reset };
}
function splitLines(chunk) {
	let lines = [],
		incompleteLine = "",
		totalLength = chunk.length;
	for (let i = 0; i < totalLength; i++) {
		let char = chunk[i];
		char === "\r" &&
		chunk[i + 1] ===
			`
`
			? (lines.push(incompleteLine), (incompleteLine = ""), i++)
			: char === "\r" ||
					char ===
						`
`
				? (lines.push(incompleteLine), (incompleteLine = ""))
				: (incompleteLine += char);
	}
	return [lines, incompleteLine];
}
class EventSourceParserStream extends TransformStream {
	constructor({ onError, onRetry, onComment } = {}) {
		let parser;
		super({
			start(controller) {
				parser = createParser({
					onEvent: (event) => {
						controller.enqueue(event);
					},
					onError(error2) {
						onError === "terminate"
							? controller.error(error2)
							: typeof onError == "function" && onError(error2);
					},
					onRetry,
					onComment,
				});
			},
			transform(chunk) {
				parser.feed(chunk);
			},
		});
	}
}
function combineHeaders(...headers) {
	return headers.reduce(
		(combinedHeaders, currentHeaders) => ({
			...combinedHeaders,
			...(currentHeaders != null ? currentHeaders : {}),
		}),
		{},
	);
}
function convertAsyncIteratorToReadableStream(iterator) {
	return new ReadableStream({
		async pull(controller) {
			try {
				let { value, done } = await iterator.next();
				if (done) controller.close();
				else controller.enqueue(value);
			} catch (error2) {
				controller.error(error2);
			}
		},
		cancel() {},
	});
}
async function delay2(delayInMs) {
	return delayInMs == null
		? Promise.resolve()
		: new Promise((resolve2) => setTimeout(resolve2, delayInMs));
}
function extractResponseHeaders(response) {
	let headers = {};
	return (
		response.headers.forEach((value, key) => {
			headers[key] = value;
		}),
		headers
	);
}
var createIdGenerator = ({
		prefix,
		size: defaultSize = 16,
		alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
		separator = "-",
	} = {}) => {
		let generator = customAlphabet(alphabet, defaultSize);
		if (prefix == null) return generator;
		if (alphabet.includes(separator))
			throw new InvalidArgumentError({
				argument: "separator",
				message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`,
			});
		return (size) => `${prefix}${separator}${generator(size)}`;
	},
	generateId = createIdGenerator();
function getErrorMessage2(error2) {
	if (error2 == null) return "unknown error";
	if (typeof error2 === "string") return error2;
	if (error2 instanceof Error) return error2.message;
	return JSON.stringify(error2);
}
function removeUndefinedEntries(record) {
	return Object.fromEntries(
		Object.entries(record).filter(([_key, value]) => value != null),
	);
}
function isAbortError(error2) {
	return (
		error2 instanceof Error &&
		(error2.name === "AbortError" || error2.name === "TimeoutError")
	);
}
function loadApiKey({
	apiKey,
	environmentVariableName,
	apiKeyParameterName = "apiKey",
	description,
}) {
	if (typeof apiKey === "string") return apiKey;
	if (apiKey != null)
		throw new LoadAPIKeyError({
			message: `${description} API key must be a string.`,
		});
	if (typeof process === "undefined")
		throw new LoadAPIKeyError({
			message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,
		});
	if (((apiKey = process.env[environmentVariableName]), apiKey == null))
		throw new LoadAPIKeyError({
			message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,
		});
	if (typeof apiKey !== "string")
		throw new LoadAPIKeyError({
			message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,
		});
	return apiKey;
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
	return { [validatorSymbol]: !0, validate };
}
function isValidator(value) {
	return (
		typeof value === "object" &&
		value !== null &&
		validatorSymbol in value &&
		value[validatorSymbol] === !0 &&
		"validate" in value
	);
}
function asValidator(value) {
	return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema) {
	return validator((value) => {
		let result = zodSchema.safeParse(value);
		return result.success
			? { success: !0, value: result.data }
			: { success: !1, error: result.error };
	});
}
function validateTypes({ value, schema: inputSchema }) {
	let result = safeValidateTypes({ value, schema: inputSchema });
	if (!result.success)
		throw TypeValidationError.wrap({ value, cause: result.error });
	return result.value;
}
function safeValidateTypes({ value, schema }) {
	let validator2 = asValidator(schema);
	try {
		if (validator2.validate == null) return { success: !0, value };
		let result = validator2.validate(value);
		if (result.success) return result;
		return {
			success: !1,
			error: TypeValidationError.wrap({ value, cause: result.error }),
		};
	} catch (error2) {
		return {
			success: !1,
			error: TypeValidationError.wrap({ value, cause: error2 }),
		};
	}
}
function parseJSON({ text, schema }) {
	try {
		let value = import_secure_json_parse.default.parse(text);
		if (schema == null) return value;
		return validateTypes({ value, schema });
	} catch (error2) {
		if (
			JSONParseError.isInstance(error2) ||
			TypeValidationError.isInstance(error2)
		)
			throw error2;
		throw new JSONParseError({ text, cause: error2 });
	}
}
function safeParseJSON({ text, schema }) {
	try {
		let value = import_secure_json_parse.default.parse(text);
		if (schema == null) return { success: !0, value, rawValue: value };
		let validationResult = safeValidateTypes({ value, schema });
		return validationResult.success
			? { ...validationResult, rawValue: value }
			: validationResult;
	} catch (error2) {
		return {
			success: !1,
			error: JSONParseError.isInstance(error2)
				? error2
				: new JSONParseError({ text, cause: error2 }),
		};
	}
}
function isParsableJson(input) {
	try {
		return import_secure_json_parse.default.parse(input), !0;
	} catch (e) {
		return !1;
	}
}
var getOriginalFetch2 = () => globalThis.fetch,
	postJsonToApi = async ({
		url,
		headers,
		body,
		failedResponseHandler,
		successfulResponseHandler,
		abortSignal,
		fetch: fetch2,
	}) =>
		postToApi({
			url,
			headers: { "Content-Type": "application/json", ...headers },
			body: { content: JSON.stringify(body), values: body },
			failedResponseHandler,
			successfulResponseHandler,
			abortSignal,
			fetch: fetch2,
		}),
	postToApi = async ({
		url,
		headers = {},
		body,
		successfulResponseHandler,
		failedResponseHandler,
		abortSignal,
		fetch: fetch2 = getOriginalFetch2(),
	}) => {
		try {
			let response = await fetch2(url, {
					method: "POST",
					headers: removeUndefinedEntries(headers),
					body: body.content,
					signal: abortSignal,
				}),
				responseHeaders = extractResponseHeaders(response);
			if (!response.ok) {
				let errorInformation;
				try {
					errorInformation = await failedResponseHandler({
						response,
						url,
						requestBodyValues: body.values,
					});
				} catch (error2) {
					if (isAbortError(error2) || APICallError.isInstance(error2))
						throw error2;
					throw new APICallError({
						message: "Failed to process error response",
						cause: error2,
						statusCode: response.status,
						url,
						responseHeaders,
						requestBodyValues: body.values,
					});
				}
				throw errorInformation.value;
			}
			try {
				return await successfulResponseHandler({
					response,
					url,
					requestBodyValues: body.values,
				});
			} catch (error2) {
				if (error2 instanceof Error) {
					if (isAbortError(error2) || APICallError.isInstance(error2))
						throw error2;
				}
				throw new APICallError({
					message: "Failed to process successful response",
					cause: error2,
					statusCode: response.status,
					url,
					responseHeaders,
					requestBodyValues: body.values,
				});
			}
		} catch (error2) {
			if (isAbortError(error2)) throw error2;
			if (error2 instanceof TypeError && error2.message === "fetch failed") {
				let cause = error2.cause;
				if (cause != null)
					throw new APICallError({
						message: `Cannot connect to API: ${cause.message}`,
						cause,
						url,
						requestBodyValues: body.values,
						isRetryable: !0,
					});
			}
			throw error2;
		}
	};
var createJsonErrorResponseHandler =
		({ errorSchema, errorToMessage, isRetryable }) =>
		async ({ response, url, requestBodyValues }) => {
			let responseBody = await response.text(),
				responseHeaders = extractResponseHeaders(response);
			if (responseBody.trim() === "")
				return {
					responseHeaders,
					value: new APICallError({
						message: response.statusText,
						url,
						requestBodyValues,
						statusCode: response.status,
						responseHeaders,
						responseBody,
						isRetryable: isRetryable == null ? void 0 : isRetryable(response),
					}),
				};
			try {
				let parsedError = parseJSON({
					text: responseBody,
					schema: errorSchema,
				});
				return {
					responseHeaders,
					value: new APICallError({
						message: errorToMessage(parsedError),
						url,
						requestBodyValues,
						statusCode: response.status,
						responseHeaders,
						responseBody,
						data: parsedError,
						isRetryable:
							isRetryable == null ? void 0 : isRetryable(response, parsedError),
					}),
				};
			} catch (parseError) {
				return {
					responseHeaders,
					value: new APICallError({
						message: response.statusText,
						url,
						requestBodyValues,
						statusCode: response.status,
						responseHeaders,
						responseBody,
						isRetryable: isRetryable == null ? void 0 : isRetryable(response),
					}),
				};
			}
		},
	createEventSourceResponseHandler =
		(chunkSchema) =>
		async ({ response }) => {
			let responseHeaders = extractResponseHeaders(response);
			if (response.body == null) throw new EmptyResponseBodyError({});
			return {
				responseHeaders,
				value: response.body
					.pipeThrough(new TextDecoderStream())
					.pipeThrough(new EventSourceParserStream())
					.pipeThrough(
						new TransformStream({
							transform({ data }, controller) {
								if (data === "[DONE]") return;
								controller.enqueue(
									safeParseJSON({ text: data, schema: chunkSchema }),
								);
							},
						}),
					),
			};
		};
var createJsonResponseHandler =
	(responseSchema) =>
	async ({ response, url, requestBodyValues }) => {
		let responseBody = await response.text(),
			parsedResult = safeParseJSON({
				text: responseBody,
				schema: responseSchema,
			}),
			responseHeaders = extractResponseHeaders(response);
		if (!parsedResult.success)
			throw new APICallError({
				message: "Invalid JSON response",
				cause: parsedResult.error,
				statusCode: response.status,
				responseHeaders,
				responseBody,
				url,
				requestBodyValues,
			});
		return {
			responseHeaders,
			value: parsedResult.value,
			rawValue: parsedResult.rawValue,
		};
	};
var { btoa, atob: atob2 } = globalThis;
function convertBase64ToUint8Array(base64String) {
	let base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/"),
		latin1string = atob2(base64Url);
	return Uint8Array.from(latin1string, (byte2) => byte2.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
	let latin1string = "";
	for (let i = 0; i < array.length; i++)
		latin1string += String.fromCodePoint(array[i]);
	return btoa(latin1string);
}
function withoutTrailingSlash(url) {
	return url == null ? void 0 : url.replace(/\/$/, "");
}
var util;
(function (util2) {
	util2.assertEqual = (val) => val;
	function assertIs(_arg) {}
	util2.assertIs = assertIs;
	function assertNever(_x) {
		throw new Error();
	}
	(util2.assertNever = assertNever),
		(util2.arrayToEnum = (items) => {
			let obj = {};
			for (let item of items) obj[item] = item;
			return obj;
		}),
		(util2.getValidEnumValues = (obj) => {
			let validKeys = util2
					.objectKeys(obj)
					.filter((k) => typeof obj[obj[k]] !== "number"),
				filtered = {};
			for (let k of validKeys) filtered[k] = obj[k];
			return util2.objectValues(filtered);
		}),
		(util2.objectValues = (obj) => {
			return util2.objectKeys(obj).map(function (e) {
				return obj[e];
			});
		}),
		(util2.objectKeys =
			typeof Object.keys === "function"
				? (obj) => Object.keys(obj)
				: (object) => {
						let keys = [];
						for (let key in object)
							if (Object.prototype.hasOwnProperty.call(object, key))
								keys.push(key);
						return keys;
					}),
		(util2.find = (arr, checker) => {
			for (let item of arr) if (checker(item)) return item;
			return;
		}),
		(util2.isInteger =
			typeof Number.isInteger === "function"
				? (val) => Number.isInteger(val)
				: (val) =>
						typeof val === "number" &&
						isFinite(val) &&
						Math.floor(val) === val);
	function joinValues(array, separator = " | ") {
		return array
			.map((val) => (typeof val === "string" ? `'${val}'` : val))
			.join(separator);
	}
	(util2.joinValues = joinValues),
		(util2.jsonStringifyReplacer = (_, value) => {
			if (typeof value === "bigint") return value.toString();
			return value;
		});
})(util || (util = {}));
var objectUtil;
(function (objectUtil2) {
	objectUtil2.mergeShapes = (first, second) => {
		return { ...first, ...second };
	};
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
		"string",
		"nan",
		"number",
		"integer",
		"float",
		"boolean",
		"date",
		"bigint",
		"symbol",
		"function",
		"undefined",
		"null",
		"array",
		"object",
		"unknown",
		"promise",
		"void",
		"never",
		"map",
		"set",
	]),
	getParsedType = (data) => {
		switch (typeof data) {
			case "undefined":
				return ZodParsedType.undefined;
			case "string":
				return ZodParsedType.string;
			case "number":
				return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
			case "boolean":
				return ZodParsedType.boolean;
			case "function":
				return ZodParsedType.function;
			case "bigint":
				return ZodParsedType.bigint;
			case "symbol":
				return ZodParsedType.symbol;
			case "object":
				if (Array.isArray(data)) return ZodParsedType.array;
				if (data === null) return ZodParsedType.null;
				if (
					data.then &&
					typeof data.then === "function" &&
					data.catch &&
					typeof data.catch === "function"
				)
					return ZodParsedType.promise;
				if (typeof Map !== "undefined" && data instanceof Map)
					return ZodParsedType.map;
				if (typeof Set !== "undefined" && data instanceof Set)
					return ZodParsedType.set;
				if (typeof Date !== "undefined" && data instanceof Date)
					return ZodParsedType.date;
				return ZodParsedType.object;
			default:
				return ZodParsedType.unknown;
		}
	},
	ZodIssueCode = util.arrayToEnum([
		"invalid_type",
		"invalid_literal",
		"custom",
		"invalid_union",
		"invalid_union_discriminator",
		"invalid_enum_value",
		"unrecognized_keys",
		"invalid_arguments",
		"invalid_return_type",
		"invalid_date",
		"invalid_string",
		"too_small",
		"too_big",
		"invalid_intersection_types",
		"not_multiple_of",
		"not_finite",
	]),
	quotelessJson = (obj) => {
		return JSON.stringify(obj, null, 2).replace(/"([^"]+)":/g, "$1:");
	};
class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		(this.issues = []),
			(this.addIssue = (sub) => {
				this.issues = [...this.issues, sub];
			}),
			(this.addIssues = (subs = []) => {
				this.issues = [...this.issues, ...subs];
			});
		let actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		(this.name = "ZodError"), (this.issues = issues);
	}
	format(_mapper) {
		let mapper =
				_mapper ||
				function (issue) {
					return issue.message;
				},
			fieldErrors = { _errors: [] },
			processError = (error2) => {
				for (let issue of error2.issues)
					if (issue.code === "invalid_union")
						issue.unionErrors.map(processError);
					else if (issue.code === "invalid_return_type")
						processError(issue.returnTypeError);
					else if (issue.code === "invalid_arguments")
						processError(issue.argumentsError);
					else if (issue.path.length === 0)
						fieldErrors._errors.push(mapper(issue));
					else {
						let curr = fieldErrors,
							i = 0;
						while (i < issue.path.length) {
							let el = issue.path[i];
							if (i !== issue.path.length - 1)
								curr[el] = curr[el] || { _errors: [] };
							else
								(curr[el] = curr[el] || { _errors: [] }),
									curr[el]._errors.push(mapper(issue));
							(curr = curr[el]), i++;
						}
					}
			};
		return processError(this), fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError))
			throw new Error(`Not a ZodError: ${value}`);
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		let fieldErrors = {},
			formErrors = [];
		for (let sub of this.issues)
			if (sub.path.length > 0)
				(fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || []),
					fieldErrors[sub.path[0]].push(mapper(sub));
			else formErrors.push(mapper(sub));
		return { formErrors, fieldErrors };
	}
	get formErrors() {
		return this.flatten();
	}
}
ZodError.create = (issues) => {
	return new ZodError(issues);
};
var errorMap = (issue, _ctx) => {
		let message;
		switch (issue.code) {
			case ZodIssueCode.invalid_type:
				if (issue.received === ZodParsedType.undefined) message = "Required";
				else message = `Expected ${issue.expected}, received ${issue.received}`;
				break;
			case ZodIssueCode.invalid_literal:
				message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
				break;
			case ZodIssueCode.unrecognized_keys:
				message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
				break;
			case ZodIssueCode.invalid_union:
				message = "Invalid input";
				break;
			case ZodIssueCode.invalid_union_discriminator:
				message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
				break;
			case ZodIssueCode.invalid_enum_value:
				message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
				break;
			case ZodIssueCode.invalid_arguments:
				message = "Invalid function arguments";
				break;
			case ZodIssueCode.invalid_return_type:
				message = "Invalid function return type";
				break;
			case ZodIssueCode.invalid_date:
				message = "Invalid date";
				break;
			case ZodIssueCode.invalid_string:
				if (typeof issue.validation === "object")
					if ("includes" in issue.validation) {
						if (
							((message = `Invalid input: must include "${issue.validation.includes}"`),
							typeof issue.validation.position === "number")
						)
							message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
					} else if ("startsWith" in issue.validation)
						message = `Invalid input: must start with "${issue.validation.startsWith}"`;
					else if ("endsWith" in issue.validation)
						message = `Invalid input: must end with "${issue.validation.endsWith}"`;
					else util.assertNever(issue.validation);
				else if (issue.validation !== "regex")
					message = `Invalid ${issue.validation}`;
				else message = "Invalid";
				break;
			case ZodIssueCode.too_small:
				if (issue.type === "array")
					message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)`;
				else if (issue.type === "string")
					message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)`;
				else if (issue.type === "number")
					message = `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}`;
				else if (issue.type === "date")
					message = `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}`;
				else message = "Invalid input";
				break;
			case ZodIssueCode.too_big:
				if (issue.type === "array")
					message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)`;
				else if (issue.type === "string")
					message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)`;
				else if (issue.type === "number")
					message = `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}`;
				else if (issue.type === "bigint")
					message = `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}`;
				else if (issue.type === "date")
					message = `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}`;
				else message = "Invalid input";
				break;
			case ZodIssueCode.custom:
				message = "Invalid input";
				break;
			case ZodIssueCode.invalid_intersection_types:
				message = "Intersection results could not be merged";
				break;
			case ZodIssueCode.not_multiple_of:
				message = `Number must be a multiple of ${issue.multipleOf}`;
				break;
			case ZodIssueCode.not_finite:
				message = "Number must be finite";
				break;
			default:
				(message = _ctx.defaultError), util.assertNever(issue);
		}
		return { message };
	},
	overrideErrorMap = errorMap;
function setErrorMap(map3) {
	overrideErrorMap = map3;
}
function getErrorMap() {
	return overrideErrorMap;
}
var makeIssue = (params) => {
		let { data, path, errorMaps, issueData } = params,
			fullPath = [...path, ...(issueData.path || [])],
			fullIssue = { ...issueData, path: fullPath };
		if (issueData.message !== void 0)
			return { ...issueData, path: fullPath, message: issueData.message };
		let errorMessage = "",
			maps = errorMaps
				.filter((m) => !!m)
				.slice()
				.reverse();
		for (let map3 of maps)
			errorMessage = map3(fullIssue, {
				data,
				defaultError: errorMessage,
			}).message;
		return { ...issueData, path: fullPath, message: errorMessage };
	},
	EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
	let overrideMap = getErrorMap(),
		issue = makeIssue({
			issueData,
			data: ctx.data,
			path: ctx.path,
			errorMaps: [
				ctx.common.contextualErrorMap,
				ctx.schemaErrorMap,
				overrideMap,
				overrideMap === errorMap ? void 0 : errorMap,
			].filter((x) => !!x),
		});
	ctx.common.issues.push(issue);
}
class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		let arrayValue = [];
		for (let s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status.dirty();
			arrayValue.push(s.value);
		}
		return { status: status.value, value: arrayValue };
	}
	static async mergeObjectAsync(status, pairs) {
		let syncPairs = [];
		for (let pair of pairs) {
			let key = await pair.key,
				value = await pair.value;
			syncPairs.push({ key, value });
		}
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		let finalObject = {};
		for (let pair of pairs) {
			let { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (
				key.value !== "__proto__" &&
				(typeof value.value !== "undefined" || pair.alwaysSet)
			)
				finalObject[key.value] = value.value;
		}
		return { status: status.value, value: finalObject };
	}
}
var INVALID = Object.freeze({ status: "aborted" }),
	DIRTY = (value) => ({ status: "dirty", value }),
	OK = (value) => ({ status: "valid", value }),
	isAborted = (x) => x.status === "aborted",
	isDirty = (x) => x.status === "dirty",
	isValid = (x) => x.status === "valid",
	isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet2(receiver, state, kind, f) {
	if (kind === "a" && !f)
		throw new TypeError("Private accessor was defined without a getter");
	if (
		typeof state === "function"
			? receiver !== state || !f
			: !state.has(receiver)
	)
		throw new TypeError(
			"Cannot read private member from an object whose class did not declare it",
		);
	return kind === "m"
		? f
		: kind === "a"
			? f.call(receiver)
			: f
				? f.value
				: state.get(receiver);
}
function __classPrivateFieldSet2(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f)
		throw new TypeError("Private accessor was defined without a setter");
	if (
		typeof state === "function"
			? receiver !== state || !f
			: !state.has(receiver)
	)
		throw new TypeError(
			"Cannot write private member to an object whose class did not declare it",
		);
	return (
		kind === "a"
			? f.call(receiver, value)
			: f
				? (f.value = value)
				: state.set(receiver, value),
		value
	);
}
var errorUtil;
(function (errorUtil2) {
	(errorUtil2.errToObj = (message) =>
		typeof message === "string" ? { message } : message || {}),
		(errorUtil2.toString = (message) =>
			typeof message === "string"
				? message
				: message === null || message === void 0
					? void 0
					: message.message);
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
	constructor(parent, value, path, key) {
		(this._cachedPath = []),
			(this.parent = parent),
			(this.data = value),
			(this._path = path),
			(this._key = key);
	}
	get path() {
		if (!this._cachedPath.length)
			if (this._key instanceof Array)
				this._cachedPath.push(...this._path, ...this._key);
			else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
}
var handleResult = (ctx, result) => {
	if (isValid(result)) return { success: !0, data: result.value };
	else {
		if (!ctx.common.issues.length)
			throw new Error("Validation failed but no issues detected.");
		return {
			success: !1,
			get error() {
				if (this._error) return this._error;
				let error2 = new ZodError(ctx.common.issues);
				return (this._error = error2), this._error;
			},
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	let {
		errorMap: errorMap2,
		invalid_type_error,
		required_error,
		description,
	} = params;
	if (errorMap2 && (invalid_type_error || required_error))
		throw new Error(
			`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
		);
	if (errorMap2) return { errorMap: errorMap2, description };
	return {
		errorMap: (iss, ctx) => {
			var _a15, _b;
			let { message } = params;
			if (iss.code === "invalid_enum_value")
				return {
					message:
						message !== null && message !== void 0 ? message : ctx.defaultError,
				};
			if (typeof ctx.data === "undefined")
				return {
					message:
						(_a15 =
							message !== null && message !== void 0
								? message
								: required_error) !== null && _a15 !== void 0
							? _a15
							: ctx.defaultError,
				};
			if (iss.code !== "invalid_type") return { message: ctx.defaultError };
			return {
				message:
					(_b =
						message !== null && message !== void 0
							? message
							: invalid_type_error) !== null && _b !== void 0
						? _b
						: ctx.defaultError,
			};
		},
		description,
	};
}
class ZodType {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return (
			ctx || {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent,
			}
		);
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent,
			},
		};
	}
	_parseSync(input) {
		let result = this._parse(input);
		if (isAsync2(result))
			throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		let result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		let result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		var _a15;
		let ctx = {
				common: {
					issues: [],
					async:
						(_a15 =
							params === null || params === void 0 ? void 0 : params.async) !==
							null && _a15 !== void 0
							? _a15
							: !1,
					contextualErrorMap:
						params === null || params === void 0 ? void 0 : params.errorMap,
				},
				path:
					(params === null || params === void 0 ? void 0 : params.path) || [],
				schemaErrorMap: this._def.errorMap,
				parent: null,
				data,
				parsedType: getParsedType(data),
			},
			result = this._parseSync({ data, path: ctx.path, parent: ctx });
		return handleResult(ctx, result);
	}
	"~validate"(data) {
		var _a15, _b;
		let ctx = {
			common: { issues: [], async: !!this["~standard"].async },
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data),
		};
		if (!this["~standard"].async)
			try {
				let result = this._parseSync({ data, path: [], parent: ctx });
				return isValid(result)
					? { value: result.value }
					: { issues: ctx.common.issues };
			} catch (err) {
				if (
					(_b =
						(_a15 = err === null || err === void 0 ? void 0 : err.message) ===
							null || _a15 === void 0
							? void 0
							: _a15.toLowerCase()) === null || _b === void 0
						? void 0
						: _b.includes("encountered")
				)
					this["~standard"].async = !0;
				ctx.common = { issues: [], async: !0 };
			}
		return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>
			isValid(result) ? { value: result.value } : { issues: ctx.common.issues },
		);
	}
	async parseAsync(data, params) {
		let result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		let ctx = {
				common: {
					issues: [],
					contextualErrorMap:
						params === null || params === void 0 ? void 0 : params.errorMap,
					async: !0,
				},
				path:
					(params === null || params === void 0 ? void 0 : params.path) || [],
				schemaErrorMap: this._def.errorMap,
				parent: null,
				data,
				parsedType: getParsedType(data),
			},
			maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }),
			result = await (isAsync2(maybeAsyncResult)
				? maybeAsyncResult
				: Promise.resolve(maybeAsyncResult));
		return handleResult(ctx, result);
	}
	refine(check2, message) {
		let getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined")
				return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			let result = check2(val),
				setError = () =>
					ctx.addIssue({
						code: ZodIssueCode.custom,
						...getIssueProperties(val),
					});
			if (typeof Promise !== "undefined" && result instanceof Promise)
				return result.then((data) => {
					if (!data) return setError(), !1;
					else return !0;
				});
			if (!result) return setError(), !1;
			else return !0;
		});
	}
	refinement(check2, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check2(val))
				return (
					ctx.addIssue(
						typeof refinementData === "function"
							? refinementData(val, ctx)
							: refinementData,
					),
					!1
				);
			else return !0;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: { type: "refinement", refinement },
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		(this.spa = this.safeParseAsync),
			(this._def = def),
			(this.parse = this.parse.bind(this)),
			(this.safeParse = this.safeParse.bind(this)),
			(this.parseAsync = this.parseAsync.bind(this)),
			(this.safeParseAsync = this.safeParseAsync.bind(this)),
			(this.spa = this.spa.bind(this)),
			(this.refine = this.refine.bind(this)),
			(this.refinement = this.refinement.bind(this)),
			(this.superRefine = this.superRefine.bind(this)),
			(this.optional = this.optional.bind(this)),
			(this.nullable = this.nullable.bind(this)),
			(this.nullish = this.nullish.bind(this)),
			(this.array = this.array.bind(this)),
			(this.promise = this.promise.bind(this)),
			(this.or = this.or.bind(this)),
			(this.and = this.and.bind(this)),
			(this.transform = this.transform.bind(this)),
			(this.brand = this.brand.bind(this)),
			(this.default = this.default.bind(this)),
			(this.catch = this.catch.bind(this)),
			(this.describe = this.describe.bind(this)),
			(this.pipe = this.pipe.bind(this)),
			(this.readonly = this.readonly.bind(this)),
			(this.isNullable = this.isNullable.bind(this)),
			(this.isOptional = this.isOptional.bind(this)),
			(this["~standard"] = {
				version: 1,
				vendor: "zod",
				validate: (data) => this["~validate"](data),
			});
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform2) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: { type: "transform", transform: transform2 },
		});
	}
	default(def) {
		let defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault,
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def),
		});
	}
	catch(def) {
		let catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch,
		});
	}
	describe(description) {
		return new this.constructor({ ...this._def, description });
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
}
var cuidRegex = /^c[^\s-]{8,}$/i,
	cuid2Regex = /^[0-9a-z]+$/,
	ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
	uuidRegex =
		/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
	nanoidRegex = /^[a-z0-9_-]{21}$/i,
	jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
	durationRegex =
		/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
	emailRegex =
		/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
	_emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
	emojiRegex,
	ipv4Regex =
		/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
	ipv4CidrRegex =
		/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
	ipv6Regex =
		/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
	ipv6CidrRegex =
		/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
	base64Regex =
		/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
	base64urlRegex =
		/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
	dateRegexSource =
		"((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
	dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let regex2 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
	if (args.precision) regex2 = `${regex2}\\.\\d{${args.precision}}`;
	else if (args.precision == null) regex2 = `${regex2}(\\.\\d+)?`;
	return regex2;
}
function timeRegex(args) {
	return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`,
		opts = [];
	if ((opts.push(args.local ? "Z?" : "Z"), args.offset))
		opts.push("([+-]\\d{2}:?\\d{2})");
	return (regex2 = `${regex2}(${opts.join("|")})`), new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
	if ((version === "v4" || !version) && ipv4Regex.test(ip)) return !0;
	if ((version === "v6" || !version) && ipv6Regex.test(ip)) return !0;
	return !1;
}
function isValidJWT(jwt, alg) {
	if (!jwtRegex.test(jwt)) return !1;
	try {
		let [header] = jwt.split("."),
			base64 = header
				.replace(/-/g, "+")
				.replace(/_/g, "/")
				.padEnd(header.length + ((4 - (header.length % 4)) % 4), "="),
			decoded = JSON.parse(atob(base64));
		if (typeof decoded !== "object" || decoded === null) return !1;
		if (!decoded.typ || !decoded.alg) return !1;
		if (alg && decoded.alg !== alg) return !1;
		return !0;
	} catch (_a15) {
		return !1;
	}
}
function isValidCidr(ip, version) {
	if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return !0;
	if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return !0;
	return !1;
}
class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			let ctx2 = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx2, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.string,
					received: ctx2.parsedType,
				}),
				INVALID
			);
		}
		let status = new ParseStatus(),
			ctx = void 0;
		for (let check2 of this._def.checks)
			if (check2.kind === "min") {
				if (input.data.length < check2.value)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							minimum: check2.value,
							type: "string",
							inclusive: !0,
							exact: !1,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "max") {
				if (input.data.length > check2.value)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							maximum: check2.value,
							type: "string",
							inclusive: !0,
							exact: !1,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "length") {
				let tooBig = input.data.length > check2.value,
					tooSmall = input.data.length < check2.value;
				if (tooBig || tooSmall) {
					if (((ctx = this._getOrReturnCtx(input, ctx)), tooBig))
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							maximum: check2.value,
							type: "string",
							inclusive: !0,
							exact: !0,
							message: check2.message,
						});
					else if (tooSmall)
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							minimum: check2.value,
							type: "string",
							inclusive: !0,
							exact: !0,
							message: check2.message,
						});
					status.dirty();
				}
			} else if (check2.kind === "email") {
				if (!emailRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "email",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "emoji") {
				if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
				if (!emojiRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "emoji",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "uuid") {
				if (!uuidRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "uuid",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "nanoid") {
				if (!nanoidRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "nanoid",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "cuid") {
				if (!cuidRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "cuid",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "cuid2") {
				if (!cuid2Regex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "cuid2",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "ulid") {
				if (!ulidRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "ulid",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "url")
				try {
					new URL(input.data);
				} catch (_a15) {
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "url",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
				}
			else if (check2.kind === "regex") {
				if (((check2.regex.lastIndex = 0), !check2.regex.test(input.data)))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "regex",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "trim") input.data = input.data.trim();
			else if (check2.kind === "includes") {
				if (!input.data.includes(check2.value, check2.position))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: { includes: check2.value, position: check2.position },
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "toLowerCase")
				input.data = input.data.toLowerCase();
			else if (check2.kind === "toUpperCase")
				input.data = input.data.toUpperCase();
			else if (check2.kind === "startsWith") {
				if (!input.data.startsWith(check2.value))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: { startsWith: check2.value },
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "endsWith") {
				if (!input.data.endsWith(check2.value))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: { endsWith: check2.value },
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "datetime") {
				if (!datetimeRegex(check2).test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: "datetime",
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "date") {
				if (!dateRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: "date",
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "time") {
				if (!timeRegex(check2).test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_string,
							validation: "time",
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "duration") {
				if (!durationRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "duration",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "ip") {
				if (!isValidIP(input.data, check2.version))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "ip",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "jwt") {
				if (!isValidJWT(input.data, check2.alg))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "jwt",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "cidr") {
				if (!isValidCidr(input.data, check2.version))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "cidr",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "base64") {
				if (!base64Regex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "base64",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "base64url") {
				if (!base64urlRegex.test(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							validation: "base64url",
							code: ZodIssueCode.invalid_string,
							message: check2.message,
						}),
						status.dirty();
			} else util.assertNever(check2);
		return { status: status.value, value: input.data };
	}
	_regex(regex2, validation, message) {
		return this.refinement((data) => regex2.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message),
		});
	}
	_addCheck(check2) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	email(message) {
		return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
	}
	url(message) {
		return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
	}
	emoji(message) {
		return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
	}
	uuid(message) {
		return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
	}
	nanoid(message) {
		return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
	}
	cuid(message) {
		return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
	}
	cuid2(message) {
		return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
	}
	ulid(message) {
		return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
	}
	base64(message) {
		return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message),
		});
	}
	jwt(options) {
		return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
	}
	ip(options) {
		return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
	}
	cidr(options) {
		return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
	}
	datetime(options) {
		var _a15, _b;
		if (typeof options === "string")
			return this._addCheck({
				kind: "datetime",
				precision: null,
				offset: !1,
				local: !1,
				message: options,
			});
		return this._addCheck({
			kind: "datetime",
			precision:
				typeof (options === null || options === void 0
					? void 0
					: options.precision) === "undefined"
					? null
					: options === null || options === void 0
						? void 0
						: options.precision,
			offset:
				(_a15 =
					options === null || options === void 0 ? void 0 : options.offset) !==
					null && _a15 !== void 0
					? _a15
					: !1,
			local:
				(_b =
					options === null || options === void 0 ? void 0 : options.local) !==
					null && _b !== void 0
					? _b
					: !1,
			...errorUtil.errToObj(
				options === null || options === void 0 ? void 0 : options.message,
			),
		});
	}
	date(message) {
		return this._addCheck({ kind: "date", message });
	}
	time(options) {
		if (typeof options === "string")
			return this._addCheck({
				kind: "time",
				precision: null,
				message: options,
			});
		return this._addCheck({
			kind: "time",
			precision:
				typeof (options === null || options === void 0
					? void 0
					: options.precision) === "undefined"
					? null
					: options === null || options === void 0
						? void 0
						: options.precision,
			...errorUtil.errToObj(
				options === null || options === void 0 ? void 0 : options.message,
			),
		});
	}
	duration(message) {
		return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
	}
	regex(regex2, message) {
		return this._addCheck({
			kind: "regex",
			regex: regex2,
			...errorUtil.errToObj(message),
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position:
				options === null || options === void 0 ? void 0 : options.position,
			...errorUtil.errToObj(
				options === null || options === void 0 ? void 0 : options.message,
			),
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message),
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message),
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message),
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message),
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message),
		});
	}
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }],
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }],
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }],
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min = null;
		for (let ch of this._def.checks)
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		return min;
	}
	get maxLength() {
		let max = null;
		for (let ch of this._def.checks)
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		return max;
	}
}
ZodString.create = (params) => {
	var _a15;
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce:
			(_a15 = params === null || params === void 0 ? void 0 : params.coerce) !==
				null && _a15 !== void 0
				? _a15
				: !1,
		...processCreateParams(params),
	});
};
function floatSafeRemainder(val, step) {
	let valDecCount = (val.toString().split(".")[1] || "").length,
		stepDecCount = (step.toString().split(".")[1] || "").length,
		decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount,
		valInt = parseInt(val.toFixed(decCount).replace(".", "")),
		stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
	return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		(this.min = this.gte), (this.max = this.lte), (this.step = this.multipleOf);
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			let ctx2 = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx2, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.number,
					received: ctx2.parsedType,
				}),
				INVALID
			);
		}
		let ctx = void 0,
			status = new ParseStatus();
		for (let check2 of this._def.checks)
			if (check2.kind === "int") {
				if (!util.isInteger(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_type,
							expected: "integer",
							received: "float",
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "min") {
				if (
					check2.inclusive
						? input.data < check2.value
						: input.data <= check2.value
				)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							minimum: check2.value,
							type: "number",
							inclusive: check2.inclusive,
							exact: !1,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "max") {
				if (
					check2.inclusive
						? input.data > check2.value
						: input.data >= check2.value
				)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							maximum: check2.value,
							type: "number",
							inclusive: check2.inclusive,
							exact: !1,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "multipleOf") {
				if (floatSafeRemainder(input.data, check2.value) !== 0)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.not_multiple_of,
							multipleOf: check2.value,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "finite") {
				if (!Number.isFinite(input.data))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.not_finite,
							message: check2.message,
						}),
						status.dirty();
			} else util.assertNever(check2);
		return { status: status.value, value: input.data };
	}
	gte(value, message) {
		return this.setLimit("min", value, !0, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, !1, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, !0, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, !1, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [
				...this._def.checks,
				{ kind, value, inclusive, message: errorUtil.toString(message) },
			],
		});
	}
	_addCheck(check2) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message),
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: !1,
			message: errorUtil.toString(message),
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: !1,
			message: errorUtil.toString(message),
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: !0,
			message: errorUtil.toString(message),
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: !0,
			message: errorUtil.toString(message),
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message),
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message),
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: !0,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message),
		})._addCheck({
			kind: "max",
			inclusive: !0,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message),
		});
	}
	get minValue() {
		let min = null;
		for (let ch of this._def.checks)
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		return min;
	}
	get maxValue() {
		let max = null;
		for (let ch of this._def.checks)
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find(
			(ch) =>
				ch.kind === "int" ||
				(ch.kind === "multipleOf" && util.isInteger(ch.value)),
		);
	}
	get isFinite() {
		let max = null,
			min = null;
		for (let ch of this._def.checks)
			if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
				return !0;
			else if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			} else if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		return Number.isFinite(min) && Number.isFinite(max);
	}
}
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce:
			(params === null || params === void 0 ? void 0 : params.coerce) || !1,
		...processCreateParams(params),
	});
};
class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		(this.min = this.gte), (this.max = this.lte);
	}
	_parse(input) {
		if (this._def.coerce)
			try {
				input.data = BigInt(input.data);
			} catch (_a15) {
				return this._getInvalidInput(input);
			}
		if (this._getType(input) !== ZodParsedType.bigint)
			return this._getInvalidInput(input);
		let ctx = void 0,
			status = new ParseStatus();
		for (let check2 of this._def.checks)
			if (check2.kind === "min") {
				if (
					check2.inclusive
						? input.data < check2.value
						: input.data <= check2.value
				)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							type: "bigint",
							minimum: check2.value,
							inclusive: check2.inclusive,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "max") {
				if (
					check2.inclusive
						? input.data > check2.value
						: input.data >= check2.value
				)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							type: "bigint",
							maximum: check2.value,
							inclusive: check2.inclusive,
							message: check2.message,
						}),
						status.dirty();
			} else if (check2.kind === "multipleOf") {
				if (input.data % check2.value !== BigInt(0))
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.not_multiple_of,
							multipleOf: check2.value,
							message: check2.message,
						}),
						status.dirty();
			} else util.assertNever(check2);
		return { status: status.value, value: input.data };
	}
	_getInvalidInput(input) {
		let ctx = this._getOrReturnCtx(input);
		return (
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.bigint,
				received: ctx.parsedType,
			}),
			INVALID
		);
	}
	gte(value, message) {
		return this.setLimit("min", value, !0, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, !1, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, !0, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, !1, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [
				...this._def.checks,
				{ kind, value, inclusive, message: errorUtil.toString(message) },
			],
		});
	}
	_addCheck(check2) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: !1,
			message: errorUtil.toString(message),
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: !1,
			message: errorUtil.toString(message),
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: !0,
			message: errorUtil.toString(message),
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: !0,
			message: errorUtil.toString(message),
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message),
		});
	}
	get minValue() {
		let min = null;
		for (let ch of this._def.checks)
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		return min;
	}
	get maxValue() {
		let max = null;
		for (let ch of this._def.checks)
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		return max;
	}
}
ZodBigInt.create = (params) => {
	var _a15;
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce:
			(_a15 = params === null || params === void 0 ? void 0 : params.coerce) !==
				null && _a15 !== void 0
				? _a15
				: !1,
		...processCreateParams(params),
	});
};
class ZodBoolean extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.boolean,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
}
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce:
			(params === null || params === void 0 ? void 0 : params.coerce) || !1,
		...processCreateParams(params),
	});
};
class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			let ctx2 = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx2, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.date,
					received: ctx2.parsedType,
				}),
				INVALID
			);
		}
		if (isNaN(input.data.getTime())) {
			let ctx2 = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx2, { code: ZodIssueCode.invalid_date }), INVALID
			);
		}
		let status = new ParseStatus(),
			ctx = void 0;
		for (let check2 of this._def.checks)
			if (check2.kind === "min") {
				if (input.data.getTime() < check2.value)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							message: check2.message,
							inclusive: !0,
							exact: !1,
							minimum: check2.value,
							type: "date",
						}),
						status.dirty();
			} else if (check2.kind === "max") {
				if (input.data.getTime() > check2.value)
					(ctx = this._getOrReturnCtx(input, ctx)),
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							message: check2.message,
							inclusive: !0,
							exact: !1,
							maximum: check2.value,
							type: "date",
						}),
						status.dirty();
			} else util.assertNever(check2);
		return { status: status.value, value: new Date(input.data.getTime()) };
	}
	_addCheck(check2) {
		return new ZodDate({ ...this._def, checks: [...this._def.checks, check2] });
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message),
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message),
		});
	}
	get minDate() {
		let min = null;
		for (let ch of this._def.checks)
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (let ch of this._def.checks)
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		return max != null ? new Date(max) : null;
	}
}
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce:
			(params === null || params === void 0 ? void 0 : params.coerce) || !1,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params),
	});
};
class ZodSymbol extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.symbol,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
}
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params),
	});
};
class ZodUndefined extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.undefined,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
}
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params),
	});
};
class ZodNull extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.null,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
}
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params),
	});
};
class ZodAny extends ZodType {
	constructor() {
		super(...arguments);
		this._any = !0;
	}
	_parse(input) {
		return OK(input.data);
	}
}
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params),
	});
};
class ZodUnknown extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = !0;
	}
	_parse(input) {
		return OK(input.data);
	}
}
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params),
	});
};
class ZodNever extends ZodType {
	_parse(input) {
		let ctx = this._getOrReturnCtx(input);
		return (
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.never,
				received: ctx.parsedType,
			}),
			INVALID
		);
	}
}
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params),
	});
};
class ZodVoid extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.void,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
}
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params),
	});
};
class ZodArray extends ZodType {
	_parse(input) {
		let { ctx, status } = this._processInputParams(input),
			def = this._def;
		if (ctx.parsedType !== ZodParsedType.array)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.array,
					received: ctx.parsedType,
				}),
				INVALID
			);
		if (def.exactLength !== null) {
			let tooBig = ctx.data.length > def.exactLength.value,
				tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall)
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: !0,
					exact: !0,
					message: def.exactLength.message,
				}),
					status.dirty();
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value)
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: !0,
					exact: !1,
					message: def.minLength.message,
				}),
					status.dirty();
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value)
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: !0,
					exact: !1,
					message: def.maxLength.message,
				}),
					status.dirty();
		}
		if (ctx.common.async)
			return Promise.all(
				[...ctx.data].map((item, i) => {
					return def.type._parseAsync(
						new ParseInputLazyPath(ctx, item, ctx.path, i),
					);
				}),
			).then((result2) => {
				return ParseStatus.mergeArray(status, result2);
			});
		let result = [...ctx.data].map((item, i) => {
			return def.type._parseSync(
				new ParseInputLazyPath(ctx, item, ctx.path, i),
			);
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: { value: minLength, message: errorUtil.toString(message) },
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: { value: maxLength, message: errorUtil.toString(message) },
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: { value: len, message: errorUtil.toString(message) },
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
}
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params),
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		let newShape = {};
		for (let key in schema.shape) {
			let fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({ ...schema._def, shape: () => newShape });
	} else if (schema instanceof ZodArray)
		return new ZodArray({
			...schema._def,
			type: deepPartialify(schema.element),
		});
	else if (schema instanceof ZodOptional)
		return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable)
		return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple)
		return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		(this._cached = null),
			(this.nonstrict = this.passthrough),
			(this.augment = this.extend);
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		let shape = this._def.shape(),
			keys = util.objectKeys(shape);
		return (this._cached = { shape, keys });
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			let ctx2 = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx2, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.object,
					received: ctx2.parsedType,
				}),
				INVALID
			);
		}
		let { status, ctx } = this._processInputParams(input),
			{ shape, keys: shapeKeys } = this._getCached(),
			extraKeys = [];
		if (
			!(
				this._def.catchall instanceof ZodNever &&
				this._def.unknownKeys === "strip"
			)
		) {
			for (let key in ctx.data)
				if (!shapeKeys.includes(key)) extraKeys.push(key);
		}
		let pairs = [];
		for (let key of shapeKeys) {
			let keyValidator = shape[key],
				value = ctx.data[key];
			pairs.push({
				key: { status: "valid", value: key },
				value: keyValidator._parse(
					new ParseInputLazyPath(ctx, value, ctx.path, key),
				),
				alwaysSet: key in ctx.data,
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			let unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough")
				for (let key of extraKeys)
					pairs.push({
						key: { status: "valid", value: key },
						value: { status: "valid", value: ctx.data[key] },
					});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0)
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys,
					}),
						status.dirty();
			} else if (unknownKeys === "strip");
			else
				throw new Error("Internal ZodObject error: invalid unknownKeys value.");
		} else {
			let catchall = this._def.catchall;
			for (let key of extraKeys) {
				let value = ctx.data[key];
				pairs.push({
					key: { status: "valid", value: key },
					value: catchall._parse(
						new ParseInputLazyPath(ctx, value, ctx.path, key),
					),
					alwaysSet: key in ctx.data,
				});
			}
		}
		if (ctx.common.async)
			return Promise.resolve()
				.then(async () => {
					let syncPairs = [];
					for (let pair of pairs) {
						let key = await pair.key,
							value = await pair.value;
						syncPairs.push({ key, value, alwaysSet: pair.alwaysSet });
					}
					return syncPairs;
				})
				.then((syncPairs) => {
					return ParseStatus.mergeObjectSync(status, syncPairs);
				});
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		return (
			errorUtil.errToObj,
			new ZodObject({
				...this._def,
				unknownKeys: "strict",
				...(message !== void 0
					? {
							errorMap: (issue, ctx) => {
								var _a15, _b, _c, _d;
								let defaultError =
									(_c =
										(_b = (_a15 = this._def).errorMap) === null || _b === void 0
											? void 0
											: _b.call(_a15, issue, ctx).message) !== null &&
									_c !== void 0
										? _c
										: ctx.defaultError;
								if (issue.code === "unrecognized_keys")
									return {
										message:
											(_d = errorUtil.errToObj(message).message) !== null &&
											_d !== void 0
												? _d
												: defaultError,
									};
								return { message: defaultError };
							},
						}
					: {}),
			})
		);
	}
	strip() {
		return new ZodObject({ ...this._def, unknownKeys: "strip" });
	}
	passthrough() {
		return new ZodObject({ ...this._def, unknownKeys: "passthrough" });
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({ ...this._def.shape(), ...augmentation }),
		});
	}
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({ ...this._def.shape(), ...merging._def.shape() }),
			typeName: ZodFirstPartyTypeKind.ZodObject,
		});
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({ ...this._def, catchall: index });
	}
	pick(mask2) {
		let shape = {};
		return (
			util.objectKeys(mask2).forEach((key) => {
				if (mask2[key] && this.shape[key]) shape[key] = this.shape[key];
			}),
			new ZodObject({ ...this._def, shape: () => shape })
		);
	}
	omit(mask2) {
		let shape = {};
		return (
			util.objectKeys(this.shape).forEach((key) => {
				if (!mask2[key]) shape[key] = this.shape[key];
			}),
			new ZodObject({ ...this._def, shape: () => shape })
		);
	}
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask2) {
		let newShape = {};
		return (
			util.objectKeys(this.shape).forEach((key) => {
				let fieldSchema = this.shape[key];
				if (mask2 && !mask2[key]) newShape[key] = fieldSchema;
				else newShape[key] = fieldSchema.optional();
			}),
			new ZodObject({ ...this._def, shape: () => newShape })
		);
	}
	required(mask2) {
		let newShape = {};
		return (
			util.objectKeys(this.shape).forEach((key) => {
				if (mask2 && !mask2[key]) newShape[key] = this.shape[key];
				else {
					let newField = this.shape[key];
					while (newField instanceof ZodOptional)
						newField = newField._def.innerType;
					newShape[key] = newField;
				}
			}),
			new ZodObject({ ...this._def, shape: () => newShape })
		);
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
}
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};
class ZodUnion extends ZodType {
	_parse(input) {
		let { ctx } = this._processInputParams(input),
			options = this._def.options;
		function handleResults(results) {
			for (let result of results)
				if (result.result.status === "valid") return result.result;
			for (let result of results)
				if (result.result.status === "dirty")
					return (
						ctx.common.issues.push(...result.ctx.common.issues), result.result
					);
			let unionErrors = results.map(
				(result) => new ZodError(result.ctx.common.issues),
			);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_union,
					unionErrors,
				}),
				INVALID
			);
		}
		if (ctx.common.async)
			return Promise.all(
				options.map(async (option) => {
					let childCtx = {
						...ctx,
						common: { ...ctx.common, issues: [] },
						parent: null,
					};
					return {
						result: await option._parseAsync({
							data: ctx.data,
							path: ctx.path,
							parent: childCtx,
						}),
						ctx: childCtx,
					};
				}),
			).then(handleResults);
		else {
			let dirty = void 0,
				issues = [];
			for (let option of options) {
				let childCtx = {
						...ctx,
						common: { ...ctx.common, issues: [] },
						parent: null,
					},
					result = option._parseSync({
						data: ctx.data,
						path: ctx.path,
						parent: childCtx,
					});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty)
					dirty = { result, ctx: childCtx };
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty)
				return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
			let unionErrors = issues.map((issues2) => new ZodError(issues2));
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_union,
					unionErrors,
				}),
				INVALID
			);
		}
	}
	get options() {
		return this._def.options;
	}
}
ZodUnion.create = (types, params) => {
	return new ZodUnion({
		options: types,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params),
	});
};
var getDiscriminator = (type2) => {
	if (type2 instanceof ZodLazy) return getDiscriminator(type2.schema);
	else if (type2 instanceof ZodEffects)
		return getDiscriminator(type2.innerType());
	else if (type2 instanceof ZodLiteral) return [type2.value];
	else if (type2 instanceof ZodEnum) return type2.options;
	else if (type2 instanceof ZodNativeEnum) return util.objectValues(type2.enum);
	else if (type2 instanceof ZodDefault)
		return getDiscriminator(type2._def.innerType);
	else if (type2 instanceof ZodUndefined) return [void 0];
	else if (type2 instanceof ZodNull) return [null];
	else if (type2 instanceof ZodOptional)
		return [void 0, ...getDiscriminator(type2.unwrap())];
	else if (type2 instanceof ZodNullable)
		return [null, ...getDiscriminator(type2.unwrap())];
	else if (type2 instanceof ZodBranded) return getDiscriminator(type2.unwrap());
	else if (type2 instanceof ZodReadonly)
		return getDiscriminator(type2.unwrap());
	else if (type2 instanceof ZodCatch)
		return getDiscriminator(type2._def.innerType);
	else return [];
};
class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		let { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.object,
					received: ctx.parsedType,
				}),
				INVALID
			);
		let discriminator = this.discriminator,
			discriminatorValue = ctx.data[discriminator],
			option = this.optionsMap.get(discriminatorValue);
		if (!option)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_union_discriminator,
					options: Array.from(this.optionsMap.keys()),
					path: [discriminator],
				}),
				INVALID
			);
		if (ctx.common.async)
			return option._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx,
			});
		else
			return option._parseSync({ data: ctx.data, path: ctx.path, parent: ctx });
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	static create(discriminator, options, params) {
		let optionsMap = new Map();
		for (let type2 of options) {
			let discriminatorValues = getDiscriminator(type2.shape[discriminator]);
			if (!discriminatorValues.length)
				throw new Error(
					`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`,
				);
			for (let value of discriminatorValues) {
				if (optionsMap.has(value))
					throw new Error(
						`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`,
					);
				optionsMap.set(value, type2);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params),
		});
	}
}
function mergeValues(a, b) {
	let aType = getParsedType(a),
		bType = getParsedType(b);
	if (a === b) return { valid: !0, data: a };
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		let bKeys = util.objectKeys(b),
			sharedKeys = util
				.objectKeys(a)
				.filter((key) => bKeys.indexOf(key) !== -1),
			newObj = { ...a, ...b };
		for (let key of sharedKeys) {
			let sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return { valid: !1 };
			newObj[key] = sharedValue.data;
		}
		return { valid: !0, data: newObj };
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) return { valid: !1 };
		let newArray = [];
		for (let index = 0; index < a.length; index++) {
			let itemA = a[index],
				itemB = b[index],
				sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: !1 };
			newArray.push(sharedValue.data);
		}
		return { valid: !0, data: newArray };
	} else if (
		aType === ZodParsedType.date &&
		bType === ZodParsedType.date &&
		+a === +b
	)
		return { valid: !0, data: a };
	else return { valid: !1 };
}
class ZodIntersection extends ZodType {
	_parse(input) {
		let { status, ctx } = this._processInputParams(input),
			handleParsed = (parsedLeft, parsedRight) => {
				if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
				let merged = mergeValues(parsedLeft.value, parsedRight.value);
				if (!merged.valid)
					return (
						addIssueToContext(ctx, {
							code: ZodIssueCode.invalid_intersection_types,
						}),
						INVALID
					);
				if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
				return { status: status.value, value: merged.data };
			};
		if (ctx.common.async)
			return Promise.all([
				this._def.left._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
				this._def.right._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
			]).then(([left, right]) => handleParsed(left, right));
		else
			return handleParsed(
				this._def.left._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
				this._def.right._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
			);
	}
}
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params),
	});
};
class ZodTuple extends ZodType {
	_parse(input) {
		let { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.array,
					received: ctx.parsedType,
				}),
				INVALID
			);
		if (ctx.data.length < this._def.items.length)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: this._def.items.length,
					inclusive: !0,
					exact: !1,
					type: "array",
				}),
				INVALID
			);
		if (!this._def.rest && ctx.data.length > this._def.items.length)
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: !0,
				exact: !1,
				type: "array",
			}),
				status.dirty();
		let items = [...ctx.data]
			.map((item, itemIndex) => {
				let schema = this._def.items[itemIndex] || this._def.rest;
				if (!schema) return null;
				return schema._parse(
					new ParseInputLazyPath(ctx, item, ctx.path, itemIndex),
				);
			})
			.filter((x) => !!x);
		if (ctx.common.async)
			return Promise.all(items).then((results) => {
				return ParseStatus.mergeArray(status, results);
			});
		else return ParseStatus.mergeArray(status, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({ ...this._def, rest });
	}
}
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas))
		throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params),
	});
};
class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		let { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.object,
					received: ctx.parsedType,
				}),
				INVALID
			);
		let pairs = [],
			keyType = this._def.keyType,
			valueType = this._def.valueType;
		for (let key in ctx.data)
			pairs.push({
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
				value: valueType._parse(
					new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key),
				),
				alwaysSet: key in ctx.data,
			});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType)
			return new ZodRecord({
				keyType: first,
				valueType: second,
				typeName: ZodFirstPartyTypeKind.ZodRecord,
				...processCreateParams(third),
			});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second),
		});
	}
}
class ZodMap extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		let { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.map,
					received: ctx.parsedType,
				}),
				INVALID
			);
		let keyType = this._def.keyType,
			valueType = this._def.valueType,
			pairs = [...ctx.data.entries()].map(([key, value], index) => {
				return {
					key: keyType._parse(
						new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"]),
					),
					value: valueType._parse(
						new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]),
					),
				};
			});
		if (ctx.common.async) {
			let finalMap = new Map();
			return Promise.resolve().then(async () => {
				for (let pair of pairs) {
					let key = await pair.key,
						value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted")
						return INVALID;
					if (key.status === "dirty" || value.status === "dirty")
						status.dirty();
					finalMap.set(key.value, value.value);
				}
				return { status: status.value, value: finalMap };
			});
		} else {
			let finalMap = new Map();
			for (let pair of pairs) {
				let { key, value } = pair;
				if (key.status === "aborted" || value.status === "aborted")
					return INVALID;
				if (key.status === "dirty" || value.status === "dirty") status.dirty();
				finalMap.set(key.value, value.value);
			}
			return { status: status.value, value: finalMap };
		}
	}
}
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params),
	});
};
class ZodSet extends ZodType {
	_parse(input) {
		let { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.set,
					received: ctx.parsedType,
				}),
				INVALID
			);
		let def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value)
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: !0,
					exact: !1,
					message: def.minSize.message,
				}),
					status.dirty();
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value)
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: !0,
					exact: !1,
					message: def.maxSize.message,
				}),
					status.dirty();
		}
		let valueType = this._def.valueType;
		function finalizeSet(elements2) {
			let parsedSet = new Set();
			for (let element of elements2) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return { status: status.value, value: parsedSet };
		}
		let elements = [...ctx.data.values()].map((item, i) =>
			valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)),
		);
		if (ctx.common.async)
			return Promise.all(elements).then((elements2) => finalizeSet(elements2));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: { value: minSize, message: errorUtil.toString(message) },
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: { value: maxSize, message: errorUtil.toString(message) },
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
}
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params),
	});
};
class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		let { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.function,
					received: ctx.parsedType,
				}),
				INVALID
			);
		function makeArgsIssue(args, error2) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap,
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error2,
				},
			});
		}
		function makeReturnsIssue(returns, error2) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap,
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error2,
				},
			});
		}
		let params = { errorMap: ctx.common.contextualErrorMap },
			fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			let me = this;
			return OK(async function (...args) {
				let error2 = new ZodError([]),
					parsedArgs = await me._def.args
						.parseAsync(args, params)
						.catch((e) => {
							throw (error2.addIssue(makeArgsIssue(args, e)), error2);
						}),
					result = await Reflect.apply(fn, this, parsedArgs);
				return await me._def.returns._def.type
					.parseAsync(result, params)
					.catch((e) => {
						throw (error2.addIssue(makeReturnsIssue(result, e)), error2);
					});
			});
		} else {
			let me = this;
			return OK(function (...args) {
				let parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success)
					throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				let result = Reflect.apply(fn, this, parsedArgs.data),
					parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success)
					throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create()),
		});
	}
	returns(returnType) {
		return new ZodFunction({ ...this._def, returns: returnType });
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params),
		});
	}
}
class ZodLazy extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		let { ctx } = this._processInputParams(input);
		return this._def
			.getter()
			._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	}
}
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params),
	});
};
class ZodLiteral extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					received: ctx.data,
					code: ZodIssueCode.invalid_literal,
					expected: this._def.value,
				}),
				INVALID
			);
		}
		return { status: "valid", value: input.data };
	}
	get value() {
		return this._def.value;
	}
}
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params),
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params),
	});
}
class ZodEnum extends ZodType {
	constructor() {
		super(...arguments);
		_ZodEnum_cache.set(this, void 0);
	}
	_parse(input) {
		if (typeof input.data !== "string") {
			let ctx = this._getOrReturnCtx(input),
				expectedValues = this._def.values;
			return (
				addIssueToContext(ctx, {
					expected: util.joinValues(expectedValues),
					received: ctx.parsedType,
					code: ZodIssueCode.invalid_type,
				}),
				INVALID
			);
		}
		if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f"))
			__classPrivateFieldSet2(
				this,
				_ZodEnum_cache,
				new Set(this._def.values),
				"f",
			);
		if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f").has(input.data)) {
			let ctx = this._getOrReturnCtx(input),
				expectedValues = this._def.values;
			return (
				addIssueToContext(ctx, {
					received: ctx.data,
					code: ZodIssueCode.invalid_enum_value,
					options: expectedValues,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		let enumValues = {};
		for (let val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		let enumValues = {};
		for (let val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		let enumValues = {};
		for (let val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values, newDef = this._def) {
		return ZodEnum.create(values, { ...this._def, ...newDef });
	}
	exclude(values, newDef = this._def) {
		return ZodEnum.create(
			this.options.filter((opt) => !values.includes(opt)),
			{ ...this._def, ...newDef },
		);
	}
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
	constructor() {
		super(...arguments);
		_ZodNativeEnum_cache.set(this, void 0);
	}
	_parse(input) {
		let nativeEnumValues = util.getValidEnumValues(this._def.values),
			ctx = this._getOrReturnCtx(input);
		if (
			ctx.parsedType !== ZodParsedType.string &&
			ctx.parsedType !== ZodParsedType.number
		) {
			let expectedValues = util.objectValues(nativeEnumValues);
			return (
				addIssueToContext(ctx, {
					expected: util.joinValues(expectedValues),
					received: ctx.parsedType,
					code: ZodIssueCode.invalid_type,
				}),
				INVALID
			);
		}
		if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f"))
			__classPrivateFieldSet2(
				this,
				_ZodNativeEnum_cache,
				new Set(util.getValidEnumValues(this._def.values)),
				"f",
			);
		if (
			!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f").has(input.data)
		) {
			let expectedValues = util.objectValues(nativeEnumValues);
			return (
				addIssueToContext(ctx, {
					received: ctx.data,
					code: ZodIssueCode.invalid_enum_value,
					options: expectedValues,
				}),
				INVALID
			);
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params),
	});
};
class ZodPromise extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		let { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.promise,
					received: ctx.parsedType,
				}),
				INVALID
			);
		let promisified =
			ctx.parsedType === ZodParsedType.promise
				? ctx.data
				: Promise.resolve(ctx.data);
		return OK(
			promisified.then((data) => {
				return this._def.type.parseAsync(data, {
					path: ctx.path,
					errorMap: ctx.common.contextualErrorMap,
				});
			}),
		);
	}
}
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params),
	});
};
class ZodEffects extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
			? this._def.schema.sourceType()
			: this._def.schema;
	}
	_parse(input) {
		let { status, ctx } = this._processInputParams(input),
			effect = this._def.effect || null,
			checkCtx = {
				addIssue: (arg) => {
					if ((addIssueToContext(ctx, arg), arg.fatal)) status.abort();
					else status.dirty();
				},
				get path() {
					return ctx.path;
				},
			};
		if (
			((checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx)),
			effect.type === "preprocess")
		) {
			let processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async)
				return Promise.resolve(processed).then(async (processed2) => {
					if (status.value === "aborted") return INVALID;
					let result = await this._def.schema._parseAsync({
						data: processed2,
						path: ctx.path,
						parent: ctx,
					});
					if (result.status === "aborted") return INVALID;
					if (result.status === "dirty") return DIRTY(result.value);
					if (status.value === "dirty") return DIRTY(result.value);
					return result;
				});
			else {
				if (status.value === "aborted") return INVALID;
				let result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx,
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			let executeRefinement = (acc) => {
				let result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise)
					throw new Error(
						"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
					);
				return acc;
			};
			if (ctx.common.async === !1) {
				let inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				return (
					executeRefinement(inner.value),
					{ status: status.value, value: inner.value }
				);
			} else
				return this._def.schema
					._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
					.then((inner) => {
						if (inner.status === "aborted") return INVALID;
						if (inner.status === "dirty") status.dirty();
						return executeRefinement(inner.value).then(() => {
							return { status: status.value, value: inner.value };
						});
					});
		}
		if (effect.type === "transform")
			if (ctx.common.async === !1) {
				let base = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (!isValid(base)) return base;
				let result = effect.transform(base.value, checkCtx);
				if (result instanceof Promise)
					throw new Error(
						"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
					);
				return { status: status.value, value: result };
			} else
				return this._def.schema
					._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
					.then((base) => {
						if (!isValid(base)) return base;
						return Promise.resolve(effect.transform(base.value, checkCtx)).then(
							(result) => ({ status: status.value, value: result }),
						);
					});
		util.assertNever(effect);
	}
}
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params),
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: { type: "preprocess", transform: preprocess },
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params),
	});
};
class ZodOptional extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodOptional.create = (type2, params) => {
	return new ZodOptional({
		innerType: type2,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params),
	});
};
class ZodNullable extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodNullable.create = (type2, params) => {
	return new ZodNullable({
		innerType: type2,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params),
	});
};
class ZodDefault extends ZodType {
	_parse(input) {
		let { ctx } = this._processInputParams(input),
			data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined)
			data = this._def.defaultValue();
		return this._def.innerType._parse({ data, path: ctx.path, parent: ctx });
	}
	removeDefault() {
		return this._def.innerType;
	}
}
ZodDefault.create = (type2, params) => {
	return new ZodDefault({
		innerType: type2,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue:
			typeof params.default === "function"
				? params.default
				: () => params.default,
		...processCreateParams(params),
	});
};
class ZodCatch extends ZodType {
	_parse(input) {
		let { ctx } = this._processInputParams(input),
			newCtx = { ...ctx, common: { ...ctx.common, issues: [] } },
			result = this._def.innerType._parse({
				data: newCtx.data,
				path: newCtx.path,
				parent: { ...newCtx },
			});
		if (isAsync2(result))
			return result.then((result2) => {
				return {
					status: "valid",
					value:
						result2.status === "valid"
							? result2.value
							: this._def.catchValue({
									get error() {
										return new ZodError(newCtx.common.issues);
									},
									input: newCtx.data,
								}),
				};
			});
		else
			return {
				status: "valid",
				value:
					result.status === "valid"
						? result.value
						: this._def.catchValue({
								get error() {
									return new ZodError(newCtx.common.issues);
								},
								input: newCtx.data,
							}),
			};
	}
	removeCatch() {
		return this._def.innerType;
	}
}
ZodCatch.create = (type2, params) => {
	return new ZodCatch({
		innerType: type2,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue:
			typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params),
	});
};
class ZodNaN extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			let ctx = this._getOrReturnCtx(input);
			return (
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: ZodParsedType.nan,
					received: ctx.parsedType,
				}),
				INVALID
			);
		}
		return { status: "valid", value: input.data };
	}
}
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params),
	});
};
var BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
	_parse(input) {
		let { ctx } = this._processInputParams(input),
			data = ctx.data;
		return this._def.type._parse({ data, path: ctx.path, parent: ctx });
	}
	unwrap() {
		return this._def.type;
	}
}
class ZodPipeline extends ZodType {
	_parse(input) {
		let { status, ctx } = this._processInputParams(input);
		if (ctx.common.async)
			return (async () => {
				let inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty")
					return status.dirty(), DIRTY(inResult.value);
				else
					return this._def.out._parseAsync({
						data: inResult.value,
						path: ctx.path,
						parent: ctx,
					});
			})();
		else {
			let inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx,
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty")
				return status.dirty(), { status: "dirty", value: inResult.value };
			else
				return this._def.out._parseSync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx,
				});
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline,
		});
	}
}
class ZodReadonly extends ZodType {
	_parse(input) {
		let result = this._def.innerType._parse(input),
			freeze = (data) => {
				if (isValid(data)) data.value = Object.freeze(data.value);
				return data;
			};
		return isAsync2(result)
			? result.then((data) => freeze(data))
			: freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodReadonly.create = (type2, params) => {
	return new ZodReadonly({
		innerType: type2,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params),
	});
};
function cleanParams(params, data) {
	let p =
		typeof params === "function"
			? params(data)
			: typeof params === "string"
				? { message: params }
				: params;
	return typeof p === "string" ? { message: p } : p;
}
function custom(check2, _params = {}, fatal) {
	if (check2)
		return ZodAny.create().superRefine((data, ctx) => {
			var _a15, _b;
			let r = check2(data);
			if (r instanceof Promise)
				return r.then((r2) => {
					var _a16, _b2;
					if (!r2) {
						let params = cleanParams(_params, data),
							_fatal =
								(_b2 =
									(_a16 = params.fatal) !== null && _a16 !== void 0
										? _a16
										: fatal) !== null && _b2 !== void 0
									? _b2
									: !0;
						ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
					}
				});
			if (!r) {
				let params = cleanParams(_params, data),
					_fatal =
						(_b =
							(_a15 = params.fatal) !== null && _a15 !== void 0
								? _a15
								: fatal) !== null && _b !== void 0
							? _b
							: !0;
				ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
			}
			return;
		});
	return ZodAny.create();
}
var late = { object: ZodObject.lazycreate },
	ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind2) {
	(ZodFirstPartyTypeKind2.ZodString = "ZodString"),
		(ZodFirstPartyTypeKind2.ZodNumber = "ZodNumber"),
		(ZodFirstPartyTypeKind2.ZodNaN = "ZodNaN"),
		(ZodFirstPartyTypeKind2.ZodBigInt = "ZodBigInt"),
		(ZodFirstPartyTypeKind2.ZodBoolean = "ZodBoolean"),
		(ZodFirstPartyTypeKind2.ZodDate = "ZodDate"),
		(ZodFirstPartyTypeKind2.ZodSymbol = "ZodSymbol"),
		(ZodFirstPartyTypeKind2.ZodUndefined = "ZodUndefined"),
		(ZodFirstPartyTypeKind2.ZodNull = "ZodNull"),
		(ZodFirstPartyTypeKind2.ZodAny = "ZodAny"),
		(ZodFirstPartyTypeKind2.ZodUnknown = "ZodUnknown"),
		(ZodFirstPartyTypeKind2.ZodNever = "ZodNever"),
		(ZodFirstPartyTypeKind2.ZodVoid = "ZodVoid"),
		(ZodFirstPartyTypeKind2.ZodArray = "ZodArray"),
		(ZodFirstPartyTypeKind2.ZodObject = "ZodObject"),
		(ZodFirstPartyTypeKind2.ZodUnion = "ZodUnion"),
		(ZodFirstPartyTypeKind2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
		(ZodFirstPartyTypeKind2.ZodIntersection = "ZodIntersection"),
		(ZodFirstPartyTypeKind2.ZodTuple = "ZodTuple"),
		(ZodFirstPartyTypeKind2.ZodRecord = "ZodRecord"),
		(ZodFirstPartyTypeKind2.ZodMap = "ZodMap"),
		(ZodFirstPartyTypeKind2.ZodSet = "ZodSet"),
		(ZodFirstPartyTypeKind2.ZodFunction = "ZodFunction"),
		(ZodFirstPartyTypeKind2.ZodLazy = "ZodLazy"),
		(ZodFirstPartyTypeKind2.ZodLiteral = "ZodLiteral"),
		(ZodFirstPartyTypeKind2.ZodEnum = "ZodEnum"),
		(ZodFirstPartyTypeKind2.ZodEffects = "ZodEffects"),
		(ZodFirstPartyTypeKind2.ZodNativeEnum = "ZodNativeEnum"),
		(ZodFirstPartyTypeKind2.ZodOptional = "ZodOptional"),
		(ZodFirstPartyTypeKind2.ZodNullable = "ZodNullable"),
		(ZodFirstPartyTypeKind2.ZodDefault = "ZodDefault"),
		(ZodFirstPartyTypeKind2.ZodCatch = "ZodCatch"),
		(ZodFirstPartyTypeKind2.ZodPromise = "ZodPromise"),
		(ZodFirstPartyTypeKind2.ZodBranded = "ZodBranded"),
		(ZodFirstPartyTypeKind2.ZodPipeline = "ZodPipeline"),
		(ZodFirstPartyTypeKind2.ZodReadonly = "ZodReadonly");
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (
		cls,
		params = { message: `Input not instance of ${cls.name}` },
	) => custom((data) => data instanceof cls, params),
	stringType = ZodString.create,
	numberType = ZodNumber.create,
	nanType = ZodNaN.create,
	bigIntType = ZodBigInt.create,
	booleanType = ZodBoolean.create,
	dateType = ZodDate.create,
	symbolType = ZodSymbol.create,
	undefinedType = ZodUndefined.create,
	nullType = ZodNull.create,
	anyType = ZodAny.create,
	unknownType = ZodUnknown.create,
	neverType = ZodNever.create,
	voidType = ZodVoid.create,
	arrayType = ZodArray.create,
	objectType = ZodObject.create,
	strictObjectType = ZodObject.strictCreate,
	unionType = ZodUnion.create,
	discriminatedUnionType = ZodDiscriminatedUnion.create,
	intersectionType = ZodIntersection.create,
	tupleType = ZodTuple.create,
	recordType = ZodRecord.create,
	mapType = ZodMap.create,
	setType = ZodSet.create,
	functionType = ZodFunction.create,
	lazyType = ZodLazy.create,
	literalType = ZodLiteral.create,
	enumType = ZodEnum.create,
	nativeEnumType = ZodNativeEnum.create,
	promiseType = ZodPromise.create,
	effectsType = ZodEffects.create,
	optionalType = ZodOptional.create,
	nullableType = ZodNullable.create,
	preprocessType = ZodEffects.createWithPreprocess,
	pipelineType = ZodPipeline.create,
	ostring = () => stringType().optional(),
	onumber = () => numberType().optional(),
	oboolean = () => booleanType().optional(),
	coerce = {
		string: (arg) => ZodString.create({ ...arg, coerce: !0 }),
		number: (arg) => ZodNumber.create({ ...arg, coerce: !0 }),
		boolean: (arg) => ZodBoolean.create({ ...arg, coerce: !0 }),
		bigint: (arg) => ZodBigInt.create({ ...arg, coerce: !0 }),
		date: (arg) => ZodDate.create({ ...arg, coerce: !0 }),
	},
	NEVER = INVALID,
	z = Object.freeze({
		__proto__: null,
		defaultErrorMap: errorMap,
		setErrorMap,
		getErrorMap,
		makeIssue,
		EMPTY_PATH,
		addIssueToContext,
		ParseStatus,
		INVALID,
		DIRTY,
		OK,
		isAborted,
		isDirty,
		isValid,
		isAsync: isAsync2,
		get util() {
			return util;
		},
		get objectUtil() {
			return objectUtil;
		},
		ZodParsedType,
		getParsedType,
		ZodType,
		datetimeRegex,
		ZodString,
		ZodNumber,
		ZodBigInt,
		ZodBoolean,
		ZodDate,
		ZodSymbol,
		ZodUndefined,
		ZodNull,
		ZodAny,
		ZodUnknown,
		ZodNever,
		ZodVoid,
		ZodArray,
		ZodObject,
		ZodUnion,
		ZodDiscriminatedUnion,
		ZodIntersection,
		ZodTuple,
		ZodRecord,
		ZodMap,
		ZodSet,
		ZodFunction,
		ZodLazy,
		ZodLiteral,
		ZodEnum,
		ZodNativeEnum,
		ZodPromise,
		ZodEffects,
		ZodTransformer: ZodEffects,
		ZodOptional,
		ZodNullable,
		ZodDefault,
		ZodCatch,
		ZodNaN,
		BRAND,
		ZodBranded,
		ZodPipeline,
		ZodReadonly,
		custom,
		Schema: ZodType,
		ZodSchema: ZodType,
		late,
		get ZodFirstPartyTypeKind() {
			return ZodFirstPartyTypeKind;
		},
		coerce,
		any: anyType,
		array: arrayType,
		bigint: bigIntType,
		boolean: booleanType,
		date: dateType,
		discriminatedUnion: discriminatedUnionType,
		effect: effectsType,
		enum: enumType,
		function: functionType,
		instanceof: instanceOfType,
		intersection: intersectionType,
		lazy: lazyType,
		literal: literalType,
		map: mapType,
		nan: nanType,
		nativeEnum: nativeEnumType,
		never: neverType,
		null: nullType,
		nullable: nullableType,
		number: numberType,
		object: objectType,
		oboolean,
		onumber,
		optional: optionalType,
		ostring,
		pipeline: pipelineType,
		preprocess: preprocessType,
		promise: promiseType,
		record: recordType,
		set: setType,
		strictObject: strictObjectType,
		string: stringType,
		symbol: symbolType,
		transformer: effectsType,
		tuple: tupleType,
		undefined: undefinedType,
		union: unionType,
		unknown: unknownType,
		void: voidType,
		NEVER,
		ZodIssueCode,
		quotelessJson,
		ZodError,
	});
function convertToGroqChatMessages(prompt) {
	let messages = [];
	for (let { role, content } of prompt)
		switch (role) {
			case "system": {
				messages.push({ role: "system", content });
				break;
			}
			case "user": {
				if (content.length === 1 && content[0].type === "text") {
					messages.push({ role: "user", content: content[0].text });
					break;
				}
				messages.push({
					role: "user",
					content: content.map((part) => {
						var _a15;
						switch (part.type) {
							case "text":
								return { type: "text", text: part.text };
							case "image":
								return {
									type: "image_url",
									image_url: {
										url:
											part.image instanceof URL
												? part.image.toString()
												: `data:${((_a15 = part.mimeType)) != null ? _a15 : "image/jpeg"};base64,${convertUint8ArrayToBase64(part.image)}`,
									},
								};
							case "file":
								throw new UnsupportedFunctionalityError({
									functionality: "File content parts in user messages",
								});
						}
					}),
				});
				break;
			}
			case "assistant": {
				let text = "",
					toolCalls = [];
				for (let part of content)
					switch (part.type) {
						case "text": {
							text += part.text;
							break;
						}
						case "redacted-reasoning":
						case "reasoning":
							break;
						case "tool-call": {
							toolCalls.push({
								id: part.toolCallId,
								type: "function",
								function: {
									name: part.toolName,
									arguments: JSON.stringify(part.args),
								},
							});
							break;
						}
						default:
							throw new Error(`Unsupported part: ${part}`);
					}
				messages.push({
					role: "assistant",
					content: text,
					tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
				});
				break;
			}
			case "tool": {
				for (let toolResponse of content)
					messages.push({
						role: "tool",
						tool_call_id: toolResponse.toolCallId,
						content: JSON.stringify(toolResponse.result),
					});
				break;
			}
			default:
				throw new Error(`Unsupported role: ${role}`);
		}
	return messages;
}
function getResponseMetadata({ id, model, created }) {
	return {
		id: id != null ? id : void 0,
		modelId: model != null ? model : void 0,
		timestamp: created != null ? new Date(created * 1000) : void 0,
	};
}
var groqErrorDataSchema = z.object({
		error: z.object({ message: z.string(), type: z.string() }),
	}),
	groqFailedResponseHandler = createJsonErrorResponseHandler({
		errorSchema: groqErrorDataSchema,
		errorToMessage: (data) => data.error.message,
	});
function prepareTools({ mode }) {
	var _a15;
	let tools = ((_a15 = mode.tools) == null ? void 0 : _a15.length)
			? mode.tools
			: void 0,
		toolWarnings = [];
	if (tools == null)
		return { tools: void 0, tool_choice: void 0, toolWarnings };
	let toolChoice = mode.toolChoice,
		groqTools = [];
	for (let tool of tools)
		if (tool.type === "provider-defined")
			toolWarnings.push({ type: "unsupported-tool", tool });
		else
			groqTools.push({
				type: "function",
				function: {
					name: tool.name,
					description: tool.description,
					parameters: tool.parameters,
				},
			});
	if (toolChoice == null)
		return { tools: groqTools, tool_choice: void 0, toolWarnings };
	let type2 = toolChoice.type;
	switch (type2) {
		case "auto":
		case "none":
		case "required":
			return { tools: groqTools, tool_choice: type2, toolWarnings };
		case "tool":
			return {
				tools: groqTools,
				tool_choice: {
					type: "function",
					function: { name: toolChoice.toolName },
				},
				toolWarnings,
			};
		default:
			throw new UnsupportedFunctionalityError({
				functionality: `Unsupported tool choice type: ${type2}`,
			});
	}
}
function mapGroqFinishReason(finishReason) {
	switch (finishReason) {
		case "stop":
			return "stop";
		case "length":
			return "length";
		case "content_filter":
			return "content-filter";
		case "function_call":
		case "tool_calls":
			return "tool-calls";
		default:
			return "unknown";
	}
}
var GroqChatLanguageModel = class {
		constructor(modelId, settings, config) {
			(this.specificationVersion = "v1"),
				(this.supportsStructuredOutputs = !1),
				(this.defaultObjectGenerationMode = "json"),
				(this.modelId = modelId),
				(this.settings = settings),
				(this.config = config);
		}
		get provider() {
			return this.config.provider;
		}
		get supportsImageUrls() {
			return !this.settings.downloadImages;
		}
		getArgs({
			mode,
			prompt,
			maxTokens,
			temperature,
			topP,
			topK,
			frequencyPenalty,
			presencePenalty,
			stopSequences,
			responseFormat,
			seed,
			stream,
		}) {
			let type2 = mode.type,
				warnings = [];
			if (topK != null)
				warnings.push({ type: "unsupported-setting", setting: "topK" });
			if (
				responseFormat != null &&
				responseFormat.type === "json" &&
				responseFormat.schema != null
			)
				warnings.push({
					type: "unsupported-setting",
					setting: "responseFormat",
					details: "JSON response format schema is not supported",
				});
			let baseArgs = {
				model: this.modelId,
				user: this.settings.user,
				parallel_tool_calls: this.settings.parallelToolCalls,
				max_tokens: maxTokens,
				temperature,
				top_p: topP,
				frequency_penalty: frequencyPenalty,
				presence_penalty: presencePenalty,
				stop: stopSequences,
				seed,
				response_format:
					stream === !1 &&
					(responseFormat == null ? void 0 : responseFormat.type) === "json"
						? { type: "json_object" }
						: void 0,
				messages: convertToGroqChatMessages(prompt),
			};
			switch (type2) {
				case "regular": {
					let { tools, tool_choice, toolWarnings } = prepareTools({ mode });
					return {
						args: { ...baseArgs, tools, tool_choice },
						warnings: [...warnings, ...toolWarnings],
					};
				}
				case "object-json":
					return {
						args: {
							...baseArgs,
							response_format: stream === !1 ? { type: "json_object" } : void 0,
						},
						warnings,
					};
				case "object-tool":
					return {
						args: {
							...baseArgs,
							tool_choice: {
								type: "function",
								function: { name: mode.tool.name },
							},
							tools: [
								{
									type: "function",
									function: {
										name: mode.tool.name,
										description: mode.tool.description,
										parameters: mode.tool.parameters,
									},
								},
							],
						},
						warnings,
					};
				default:
					throw new Error(`Unsupported type: ${type2}`);
			}
		}
		async doGenerate(options) {
			var _a15, _b, _c, _d, _e, _f;
			let { args, warnings } = this.getArgs({ ...options, stream: !1 }),
				body = JSON.stringify(args),
				{
					responseHeaders,
					value: response,
					rawValue: rawResponse,
				} = await postJsonToApi({
					url: this.config.url({
						path: "/chat/completions",
						modelId: this.modelId,
					}),
					headers: combineHeaders(this.config.headers(), options.headers),
					body: args,
					failedResponseHandler: groqFailedResponseHandler,
					successfulResponseHandler: createJsonResponseHandler(
						groqChatResponseSchema,
					),
					abortSignal: options.abortSignal,
					fetch: this.config.fetch,
				}),
				{ messages: rawPrompt, ...rawSettings } = args,
				choice = response.choices[0];
			return {
				text: (_a15 = choice.message.content) != null ? _a15 : void 0,
				toolCalls:
					(_b = choice.message.tool_calls) == null
						? void 0
						: _b.map((toolCall) => {
								var _a22;
								return {
									toolCallType: "function",
									toolCallId:
										(_a22 = toolCall.id) != null ? _a22 : generateId(),
									toolName: toolCall.function.name,
									args: toolCall.function.arguments,
								};
							}),
				finishReason: mapGroqFinishReason(choice.finish_reason),
				usage: {
					promptTokens:
						(_d = (_c = response.usage) == null ? void 0 : _c.prompt_tokens) !=
						null
							? _d
							: NaN,
					completionTokens:
						(_f =
							(_e = response.usage) == null ? void 0 : _e.completion_tokens) !=
						null
							? _f
							: NaN,
				},
				rawCall: { rawPrompt, rawSettings },
				rawResponse: { headers: responseHeaders, body: rawResponse },
				response: getResponseMetadata(response),
				warnings,
				request: { body },
			};
		}
		async doStream(options) {
			let { args, warnings } = this.getArgs({ ...options, stream: !0 }),
				body = JSON.stringify({ ...args, stream: !0 }),
				{ responseHeaders, value: response } = await postJsonToApi({
					url: this.config.url({
						path: "/chat/completions",
						modelId: this.modelId,
					}),
					headers: combineHeaders(this.config.headers(), options.headers),
					body: { ...args, stream: !0 },
					failedResponseHandler: groqFailedResponseHandler,
					successfulResponseHandler:
						createEventSourceResponseHandler(groqChatChunkSchema),
					abortSignal: options.abortSignal,
					fetch: this.config.fetch,
				}),
				{ messages: rawPrompt, ...rawSettings } = args,
				toolCalls = [],
				finishReason = "unknown",
				usage = { promptTokens: void 0, completionTokens: void 0 },
				isFirstChunk = !0,
				providerMetadata;
			return {
				stream: response.pipeThrough(
					new TransformStream({
						transform(chunk, controller) {
							var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
							if (!chunk.success) {
								(finishReason = "error"),
									controller.enqueue({ type: "error", error: chunk.error });
								return;
							}
							let value = chunk.value;
							if ("error" in value) {
								(finishReason = "error"),
									controller.enqueue({ type: "error", error: value.error });
								return;
							}
							if (isFirstChunk)
								(isFirstChunk = !1),
									controller.enqueue({
										type: "response-metadata",
										...getResponseMetadata(value),
									});
							if (((_a15 = value.x_groq) == null ? void 0 : _a15.usage) != null)
								usage = {
									promptTokens:
										(_b = value.x_groq.usage.prompt_tokens) != null
											? _b
											: void 0,
									completionTokens:
										(_c = value.x_groq.usage.completion_tokens) != null
											? _c
											: void 0,
								};
							let choice = value.choices[0];
							if ((choice == null ? void 0 : choice.finish_reason) != null)
								finishReason = mapGroqFinishReason(choice.finish_reason);
							if ((choice == null ? void 0 : choice.delta) == null) return;
							let delta2 = choice.delta;
							if (delta2.content != null)
								controller.enqueue({
									type: "text-delta",
									textDelta: delta2.content,
								});
							if (delta2.tool_calls != null)
								for (let toolCallDelta of delta2.tool_calls) {
									let index = toolCallDelta.index;
									if (toolCalls[index] == null) {
										if (toolCallDelta.type !== "function")
											throw new InvalidResponseDataError({
												data: toolCallDelta,
												message: "Expected 'function' type.",
											});
										if (toolCallDelta.id == null)
											throw new InvalidResponseDataError({
												data: toolCallDelta,
												message: "Expected 'id' to be a string.",
											});
										if (
											((_d = toolCallDelta.function) == null
												? void 0
												: _d.name) == null
										)
											throw new InvalidResponseDataError({
												data: toolCallDelta,
												message: "Expected 'function.name' to be a string.",
											});
										toolCalls[index] = {
											id: toolCallDelta.id,
											type: "function",
											function: {
												name: toolCallDelta.function.name,
												arguments:
													(_e = toolCallDelta.function.arguments) != null
														? _e
														: "",
											},
											hasFinished: !1,
										};
										let toolCall2 = toolCalls[index];
										if (
											((_f = toolCall2.function) == null ? void 0 : _f.name) !=
												null &&
											((_g = toolCall2.function) == null
												? void 0
												: _g.arguments) != null
										) {
											if (toolCall2.function.arguments.length > 0)
												controller.enqueue({
													type: "tool-call-delta",
													toolCallType: "function",
													toolCallId: toolCall2.id,
													toolName: toolCall2.function.name,
													argsTextDelta: toolCall2.function.arguments,
												});
											if (isParsableJson(toolCall2.function.arguments))
												controller.enqueue({
													type: "tool-call",
													toolCallType: "function",
													toolCallId:
														(_h = toolCall2.id) != null ? _h : generateId(),
													toolName: toolCall2.function.name,
													args: toolCall2.function.arguments,
												}),
													(toolCall2.hasFinished = !0);
										}
										continue;
									}
									let toolCall = toolCalls[index];
									if (toolCall.hasFinished) continue;
									if (
										((_i = toolCallDelta.function) == null
											? void 0
											: _i.arguments) != null
									)
										toolCall.function.arguments +=
											(_k =
												(_j = toolCallDelta.function) == null
													? void 0
													: _j.arguments) != null
												? _k
												: "";
									if (
										(controller.enqueue({
											type: "tool-call-delta",
											toolCallType: "function",
											toolCallId: toolCall.id,
											toolName: toolCall.function.name,
											argsTextDelta:
												(_l = toolCallDelta.function.arguments) != null
													? _l
													: "",
										}),
										((_m = toolCall.function) == null ? void 0 : _m.name) !=
											null &&
											((_n = toolCall.function) == null
												? void 0
												: _n.arguments) != null &&
											isParsableJson(toolCall.function.arguments))
									)
										controller.enqueue({
											type: "tool-call",
											toolCallType: "function",
											toolCallId:
												(_o = toolCall.id) != null ? _o : generateId(),
											toolName: toolCall.function.name,
											args: toolCall.function.arguments,
										}),
											(toolCall.hasFinished = !0);
								}
						},
						flush(controller) {
							var _a15, _b;
							controller.enqueue({
								type: "finish",
								finishReason,
								usage: {
									promptTokens:
										(_a15 = usage.promptTokens) != null ? _a15 : NaN,
									completionTokens:
										(_b = usage.completionTokens) != null ? _b : NaN,
								},
								...(providerMetadata != null ? { providerMetadata } : {}),
							});
						},
					}),
				),
				rawCall: { rawPrompt, rawSettings },
				rawResponse: { headers: responseHeaders },
				warnings,
				request: { body },
			};
		}
	},
	groqChatResponseSchema = z.object({
		id: z.string().nullish(),
		created: z.number().nullish(),
		model: z.string().nullish(),
		choices: z.array(
			z.object({
				message: z.object({
					role: z.literal("assistant").nullish(),
					content: z.string().nullish(),
					tool_calls: z
						.array(
							z.object({
								id: z.string().nullish(),
								type: z.literal("function"),
								function: z.object({ name: z.string(), arguments: z.string() }),
							}),
						)
						.nullish(),
				}),
				index: z.number(),
				finish_reason: z.string().nullish(),
			}),
		),
		usage: z
			.object({
				prompt_tokens: z.number().nullish(),
				completion_tokens: z.number().nullish(),
			})
			.nullish(),
	}),
	groqChatChunkSchema = z.union([
		z.object({
			id: z.string().nullish(),
			created: z.number().nullish(),
			model: z.string().nullish(),
			choices: z.array(
				z.object({
					delta: z
						.object({
							role: z.enum(["assistant"]).nullish(),
							content: z.string().nullish(),
							tool_calls: z
								.array(
									z.object({
										index: z.number(),
										id: z.string().nullish(),
										type: z.literal("function").optional(),
										function: z.object({
											name: z.string().nullish(),
											arguments: z.string().nullish(),
										}),
									}),
								)
								.nullish(),
						})
						.nullish(),
					finish_reason: z.string().nullable().optional(),
					index: z.number(),
				}),
			),
			x_groq: z
				.object({
					usage: z
						.object({
							prompt_tokens: z.number().nullish(),
							completion_tokens: z.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
		}),
		groqErrorDataSchema,
	]);
function createGroq(options = {}) {
	var _a15;
	let baseURL =
			(_a15 = withoutTrailingSlash(options.baseURL)) != null
				? _a15
				: "https://api.groq.com/openai/v1",
		getHeaders = () => ({
			Authorization: `Bearer ${loadApiKey({ apiKey: options.apiKey, environmentVariableName: "GROQ_API_KEY", description: "Groq" })}`,
			...options.headers,
		}),
		createChatModel = (modelId, settings = {}) =>
			new GroqChatLanguageModel(modelId, settings, {
				provider: "groq.chat",
				url: ({ path }) => `${baseURL}${path}`,
				headers: getHeaders,
				fetch: options.fetch,
			}),
		createLanguageModel = (modelId, settings) => {
			if (new.target)
				throw new Error(
					"The Groq model function cannot be called with the new keyword.",
				);
			return createChatModel(modelId, settings);
		},
		provider = function (modelId, settings) {
			return createLanguageModel(modelId, settings);
		};
	return (
		(provider.languageModel = createLanguageModel),
		(provider.chat = createChatModel),
		(provider.textEmbeddingModel = (modelId) => {
			throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
		}),
		provider
	);
}
var groq = createGroq();
var ignoreOverride = Symbol(
	"Let zodToJsonSchema decide on which parser to use",
);
var defaultOptions = {
		name: void 0,
		$refStrategy: "root",
		basePath: ["#"],
		effectStrategy: "input",
		pipeStrategy: "all",
		dateStrategy: "format:date-time",
		mapStrategy: "entries",
		removeAdditionalStrategy: "passthrough",
		allowedAdditionalProperties: !0,
		rejectedAdditionalProperties: !1,
		definitionPath: "definitions",
		target: "jsonSchema7",
		strictUnions: !1,
		definitions: {},
		errorMessages: !1,
		markdownDescription: !1,
		patternStrategy: "escape",
		applyRegexFlags: !1,
		emailStrategy: "format:email",
		base64Strategy: "contentEncoding:base64",
		nameStrategy: "ref",
	},
	getDefaultOptions = (options) =>
		typeof options === "string"
			? { ...defaultOptions, name: options }
			: { ...defaultOptions, ...options };
var getRefs = (options) => {
	let _options = getDefaultOptions(options),
		currentPath =
			_options.name !== void 0
				? [..._options.basePath, _options.definitionPath, _options.name]
				: _options.basePath;
	return {
		..._options,
		currentPath,
		propertyPath: void 0,
		seen: new Map(
			Object.entries(_options.definitions).map(([name14, def]) => [
				def._def,
				{
					def: def._def,
					path: [..._options.basePath, _options.definitionPath, name14],
					jsonSchema: void 0,
				},
			]),
		),
	};
};
function addErrorMessage(res, key, errorMessage, refs) {
	if (!refs?.errorMessages) return;
	if (errorMessage)
		res.errorMessage = { ...res.errorMessage, [key]: errorMessage };
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
	(res[key] = value), addErrorMessage(res, key, errorMessage, refs);
}
function parseAnyDef() {
	return {};
}
function parseArrayDef(def, refs) {
	let res = { type: "array" };
	if (
		def.type?._def &&
		def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny
	)
		res.items = parseDef(def.type._def, {
			...refs,
			currentPath: [...refs.currentPath, "items"],
		});
	if (def.minLength)
		setResponseValueAndErrors(
			res,
			"minItems",
			def.minLength.value,
			def.minLength.message,
			refs,
		);
	if (def.maxLength)
		setResponseValueAndErrors(
			res,
			"maxItems",
			def.maxLength.value,
			def.maxLength.message,
			refs,
		);
	if (def.exactLength)
		setResponseValueAndErrors(
			res,
			"minItems",
			def.exactLength.value,
			def.exactLength.message,
			refs,
		),
			setResponseValueAndErrors(
				res,
				"maxItems",
				def.exactLength.value,
				def.exactLength.message,
				refs,
			);
	return res;
}
function parseBigintDef(def, refs) {
	let res = { type: "integer", format: "int64" };
	if (!def.checks) return res;
	for (let check2 of def.checks)
		switch (check2.kind) {
			case "min":
				if (refs.target === "jsonSchema7")
					if (check2.inclusive)
						setResponseValueAndErrors(
							res,
							"minimum",
							check2.value,
							check2.message,
							refs,
						);
					else
						setResponseValueAndErrors(
							res,
							"exclusiveMinimum",
							check2.value,
							check2.message,
							refs,
						);
				else {
					if (!check2.inclusive) res.exclusiveMinimum = !0;
					setResponseValueAndErrors(
						res,
						"minimum",
						check2.value,
						check2.message,
						refs,
					);
				}
				break;
			case "max":
				if (refs.target === "jsonSchema7")
					if (check2.inclusive)
						setResponseValueAndErrors(
							res,
							"maximum",
							check2.value,
							check2.message,
							refs,
						);
					else
						setResponseValueAndErrors(
							res,
							"exclusiveMaximum",
							check2.value,
							check2.message,
							refs,
						);
				else {
					if (!check2.inclusive) res.exclusiveMaximum = !0;
					setResponseValueAndErrors(
						res,
						"maximum",
						check2.value,
						check2.message,
						refs,
					);
				}
				break;
			case "multipleOf":
				setResponseValueAndErrors(
					res,
					"multipleOf",
					check2.value,
					check2.message,
					refs,
				);
				break;
		}
	return res;
}
function parseBooleanDef() {
	return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
	return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
	let strategy = overrideDateStrategy ?? refs.dateStrategy;
	if (Array.isArray(strategy))
		return { anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)) };
	switch (strategy) {
		case "string":
		case "format:date-time":
			return { type: "string", format: "date-time" };
		case "format:date":
			return { type: "string", format: "date" };
		case "integer":
			return integerDateParser(def, refs);
	}
}
var integerDateParser = (def, refs) => {
	let res = { type: "integer", format: "unix-time" };
	if (refs.target === "openApi3") return res;
	for (let check2 of def.checks)
		switch (check2.kind) {
			case "min":
				setResponseValueAndErrors(
					res,
					"minimum",
					check2.value,
					check2.message,
					refs,
				);
				break;
			case "max":
				setResponseValueAndErrors(
					res,
					"maximum",
					check2.value,
					check2.message,
					refs,
				);
				break;
		}
	return res;
};
function parseDefaultDef(_def, refs) {
	return {
		...parseDef(_def.innerType._def, refs),
		default: _def.defaultValue(),
	};
}
function parseEffectsDef(_def, refs) {
	return refs.effectStrategy === "input"
		? parseDef(_def.schema._def, refs)
		: {};
}
function parseEnumDef(def) {
	return { type: "string", enum: Array.from(def.values) };
}
var isJsonSchema7AllOfType = (type2) => {
	if ("type" in type2 && type2.type === "string") return !1;
	return "allOf" in type2;
};
function parseIntersectionDef(def, refs) {
	let allOf = [
			parseDef(def.left._def, {
				...refs,
				currentPath: [...refs.currentPath, "allOf", "0"],
			}),
			parseDef(def.right._def, {
				...refs,
				currentPath: [...refs.currentPath, "allOf", "1"],
			}),
		].filter((x) => !!x),
		unevaluatedProperties =
			refs.target === "jsonSchema2019-09"
				? { unevaluatedProperties: !1 }
				: void 0,
		mergedAllOf = [];
	return (
		allOf.forEach((schema) => {
			if (isJsonSchema7AllOfType(schema)) {
				if (
					(mergedAllOf.push(...schema.allOf),
					schema.unevaluatedProperties === void 0)
				)
					unevaluatedProperties = void 0;
			} else {
				let nestedSchema = schema;
				if (
					"additionalProperties" in schema &&
					schema.additionalProperties === !1
				) {
					let { additionalProperties, ...rest } = schema;
					nestedSchema = rest;
				} else unevaluatedProperties = void 0;
				mergedAllOf.push(nestedSchema);
			}
		}),
		mergedAllOf.length
			? { allOf: mergedAllOf, ...unevaluatedProperties }
			: void 0
	);
}
function parseLiteralDef(def, refs) {
	let parsedType = typeof def.value;
	if (
		parsedType !== "bigint" &&
		parsedType !== "number" &&
		parsedType !== "boolean" &&
		parsedType !== "string"
	)
		return { type: Array.isArray(def.value) ? "array" : "object" };
	if (refs.target === "openApi3")
		return {
			type: parsedType === "bigint" ? "integer" : parsedType,
			enum: [def.value],
		};
	return {
		type: parsedType === "bigint" ? "integer" : parsedType,
		const: def.value,
	};
}
var emojiRegex2 = void 0,
	zodPatterns = {
		cuid: /^[cC][^\s-]{8,}$/,
		cuid2: /^[0-9a-z]+$/,
		ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
		email:
			/^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
		emoji: () => {
			if (emojiRegex2 === void 0)
				emojiRegex2 = RegExp(
					"^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
					"u",
				);
			return emojiRegex2;
		},
		uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
		ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
		ipv4Cidr:
			/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
		ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
		ipv6Cidr:
			/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
		base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
		base64url:
			/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
		nanoid: /^[a-zA-Z0-9_-]{21}$/,
		jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
	};
function parseStringDef(def, refs) {
	let res = { type: "string" };
	if (def.checks)
		for (let check2 of def.checks)
			switch (check2.kind) {
				case "min":
					setResponseValueAndErrors(
						res,
						"minLength",
						typeof res.minLength === "number"
							? Math.max(res.minLength, check2.value)
							: check2.value,
						check2.message,
						refs,
					);
					break;
				case "max":
					setResponseValueAndErrors(
						res,
						"maxLength",
						typeof res.maxLength === "number"
							? Math.min(res.maxLength, check2.value)
							: check2.value,
						check2.message,
						refs,
					);
					break;
				case "email":
					switch (refs.emailStrategy) {
						case "format:email":
							addFormat(res, "email", check2.message, refs);
							break;
						case "format:idn-email":
							addFormat(res, "idn-email", check2.message, refs);
							break;
						case "pattern:zod":
							addPattern(res, zodPatterns.email, check2.message, refs);
							break;
					}
					break;
				case "url":
					addFormat(res, "uri", check2.message, refs);
					break;
				case "uuid":
					addFormat(res, "uuid", check2.message, refs);
					break;
				case "regex":
					addPattern(res, check2.regex, check2.message, refs);
					break;
				case "cuid":
					addPattern(res, zodPatterns.cuid, check2.message, refs);
					break;
				case "cuid2":
					addPattern(res, zodPatterns.cuid2, check2.message, refs);
					break;
				case "startsWith":
					addPattern(
						res,
						RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`),
						check2.message,
						refs,
					);
					break;
				case "endsWith":
					addPattern(
						res,
						RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`),
						check2.message,
						refs,
					);
					break;
				case "datetime":
					addFormat(res, "date-time", check2.message, refs);
					break;
				case "date":
					addFormat(res, "date", check2.message, refs);
					break;
				case "time":
					addFormat(res, "time", check2.message, refs);
					break;
				case "duration":
					addFormat(res, "duration", check2.message, refs);
					break;
				case "length":
					setResponseValueAndErrors(
						res,
						"minLength",
						typeof res.minLength === "number"
							? Math.max(res.minLength, check2.value)
							: check2.value,
						check2.message,
						refs,
					),
						setResponseValueAndErrors(
							res,
							"maxLength",
							typeof res.maxLength === "number"
								? Math.min(res.maxLength, check2.value)
								: check2.value,
							check2.message,
							refs,
						);
					break;
				case "includes": {
					addPattern(
						res,
						RegExp(escapeLiteralCheckValue(check2.value, refs)),
						check2.message,
						refs,
					);
					break;
				}
				case "ip": {
					if (check2.version !== "v6")
						addFormat(res, "ipv4", check2.message, refs);
					if (check2.version !== "v4")
						addFormat(res, "ipv6", check2.message, refs);
					break;
				}
				case "base64url":
					addPattern(res, zodPatterns.base64url, check2.message, refs);
					break;
				case "jwt":
					addPattern(res, zodPatterns.jwt, check2.message, refs);
					break;
				case "cidr": {
					if (check2.version !== "v6")
						addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
					if (check2.version !== "v4")
						addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
					break;
				}
				case "emoji":
					addPattern(res, zodPatterns.emoji(), check2.message, refs);
					break;
				case "ulid": {
					addPattern(res, zodPatterns.ulid, check2.message, refs);
					break;
				}
				case "base64": {
					switch (refs.base64Strategy) {
						case "format:binary": {
							addFormat(res, "binary", check2.message, refs);
							break;
						}
						case "contentEncoding:base64": {
							setResponseValueAndErrors(
								res,
								"contentEncoding",
								"base64",
								check2.message,
								refs,
							);
							break;
						}
						case "pattern:zod": {
							addPattern(res, zodPatterns.base64, check2.message, refs);
							break;
						}
					}
					break;
				}
				case "nanoid":
					addPattern(res, zodPatterns.nanoid, check2.message, refs);
				case "toLowerCase":
				case "toUpperCase":
				case "trim":
					break;
				default:
					((_) => {})(check2);
			}
	return res;
}
function escapeLiteralCheckValue(literal, refs) {
	return refs.patternStrategy === "escape"
		? escapeNonAlphaNumeric(literal)
		: literal;
}
var ALPHA_NUMERIC = new Set(
	"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789",
);
function escapeNonAlphaNumeric(source) {
	let result = "";
	for (let i = 0; i < source.length; i++) {
		if (!ALPHA_NUMERIC.has(source[i])) result += "\\";
		result += source[i];
	}
	return result;
}
function addFormat(schema, value, message, refs) {
	if (schema.format || schema.anyOf?.some((x) => x.format)) {
		if (!schema.anyOf) schema.anyOf = [];
		if (schema.format) {
			if (
				(schema.anyOf.push({
					format: schema.format,
					...(schema.errorMessage &&
						refs.errorMessages && {
							errorMessage: { format: schema.errorMessage.format },
						}),
				}),
				delete schema.format,
				schema.errorMessage)
			) {
				if (
					(delete schema.errorMessage.format,
					Object.keys(schema.errorMessage).length === 0)
				)
					delete schema.errorMessage;
			}
		}
		schema.anyOf.push({
			format: value,
			...(message &&
				refs.errorMessages && { errorMessage: { format: message } }),
		});
	} else setResponseValueAndErrors(schema, "format", value, message, refs);
}
function addPattern(schema, regex2, message, refs) {
	if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
		if (!schema.allOf) schema.allOf = [];
		if (schema.pattern) {
			if (
				(schema.allOf.push({
					pattern: schema.pattern,
					...(schema.errorMessage &&
						refs.errorMessages && {
							errorMessage: { pattern: schema.errorMessage.pattern },
						}),
				}),
				delete schema.pattern,
				schema.errorMessage)
			) {
				if (
					(delete schema.errorMessage.pattern,
					Object.keys(schema.errorMessage).length === 0)
				)
					delete schema.errorMessage;
			}
		}
		schema.allOf.push({
			pattern: stringifyRegExpWithFlags(regex2, refs),
			...(message &&
				refs.errorMessages && { errorMessage: { pattern: message } }),
		});
	} else
		setResponseValueAndErrors(
			schema,
			"pattern",
			stringifyRegExpWithFlags(regex2, refs),
			message,
			refs,
		);
}
function stringifyRegExpWithFlags(regex2, refs) {
	if (!refs.applyRegexFlags || !regex2.flags) return regex2.source;
	let flags = {
			i: regex2.flags.includes("i"),
			m: regex2.flags.includes("m"),
			s: regex2.flags.includes("s"),
		},
		source = flags.i ? regex2.source.toLowerCase() : regex2.source,
		pattern = "",
		isEscaped = !1,
		inCharGroup = !1,
		inCharRange = !1;
	for (let i = 0; i < source.length; i++) {
		if (isEscaped) {
			(pattern += source[i]), (isEscaped = !1);
			continue;
		}
		if (flags.i) {
			if (inCharGroup) {
				if (source[i].match(/[a-z]/)) {
					if (inCharRange)
						(pattern += source[i]),
							(pattern += `${source[i - 2]}-${source[i]}`.toUpperCase()),
							(inCharRange = !1);
					else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/))
						(pattern += source[i]), (inCharRange = !0);
					else pattern += `${source[i]}${source[i].toUpperCase()}`;
					continue;
				}
			} else if (source[i].match(/[a-z]/)) {
				pattern += `[${source[i]}${source[i].toUpperCase()}]`;
				continue;
			}
		}
		if (flags.m) {
			if (source[i] === "^") {
				pattern += `(^|(?<=[\r
]))`;
				continue;
			} else if (source[i] === "$") {
				pattern += `($|(?=[\r
]))`;
				continue;
			}
		}
		if (flags.s && source[i] === ".") {
			pattern += inCharGroup
				? `${source[i]}\r
`
				: `[${source[i]}\r
]`;
			continue;
		}
		if (((pattern += source[i]), source[i] === "\\")) isEscaped = !0;
		else if (inCharGroup && source[i] === "]") inCharGroup = !1;
		else if (!inCharGroup && source[i] === "[") inCharGroup = !0;
	}
	try {
		new RegExp(pattern);
	} catch {
		return (
			console.warn(
				`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`,
			),
			regex2.source
		);
	}
	return pattern;
}
function parseRecordDef(def, refs) {
	if (refs.target === "openAi")
		console.warn(
			"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.",
		);
	if (
		refs.target === "openApi3" &&
		def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum
	)
		return {
			type: "object",
			required: def.keyType._def.values,
			properties: def.keyType._def.values.reduce(
				(acc, key) => ({
					...acc,
					[key]:
						parseDef(def.valueType._def, {
							...refs,
							currentPath: [...refs.currentPath, "properties", key],
						}) ?? {},
				}),
				{},
			),
			additionalProperties: refs.rejectedAdditionalProperties,
		};
	let schema = {
		type: "object",
		additionalProperties:
			parseDef(def.valueType._def, {
				...refs,
				currentPath: [...refs.currentPath, "additionalProperties"],
			}) ?? refs.allowedAdditionalProperties,
	};
	if (refs.target === "openApi3") return schema;
	if (
		def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&
		def.keyType._def.checks?.length
	) {
		let { type: type2, ...keyType } = parseStringDef(def.keyType._def, refs);
		return { ...schema, propertyNames: keyType };
	} else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum)
		return { ...schema, propertyNames: { enum: def.keyType._def.values } };
	else if (
		def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&
		def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&
		def.keyType._def.type._def.checks?.length
	) {
		let { type: type2, ...keyType } = parseBrandedDef(def.keyType._def, refs);
		return { ...schema, propertyNames: keyType };
	}
	return schema;
}
function parseMapDef(def, refs) {
	if (refs.mapStrategy === "record") return parseRecordDef(def, refs);
	let keys =
			parseDef(def.keyType._def, {
				...refs,
				currentPath: [...refs.currentPath, "items", "items", "0"],
			}) || {},
		values =
			parseDef(def.valueType._def, {
				...refs,
				currentPath: [...refs.currentPath, "items", "items", "1"],
			}) || {};
	return {
		type: "array",
		maxItems: 125,
		items: { type: "array", items: [keys, values], minItems: 2, maxItems: 2 },
	};
}
function parseNativeEnumDef(def) {
	let object = def.values,
		actualValues = Object.keys(def.values)
			.filter((key) => {
				return typeof object[object[key]] !== "number";
			})
			.map((key) => object[key]),
		parsedTypes = Array.from(
			new Set(actualValues.map((values) => typeof values)),
		);
	return {
		type:
			parsedTypes.length === 1
				? parsedTypes[0] === "string"
					? "string"
					: "number"
				: ["string", "number"],
		enum: actualValues,
	};
}
function parseNeverDef() {
	return { not: {} };
}
function parseNullDef(refs) {
	return refs.target === "openApi3"
		? { enum: ["null"], nullable: !0 }
		: { type: "null" };
}
var primitiveMappings = {
	ZodString: "string",
	ZodNumber: "number",
	ZodBigInt: "integer",
	ZodBoolean: "boolean",
	ZodNull: "null",
};
function parseUnionDef(def, refs) {
	if (refs.target === "openApi3") return asAnyOf(def, refs);
	let options =
		def.options instanceof Map ? Array.from(def.options.values()) : def.options;
	if (
		options.every(
			(x) =>
				x._def.typeName in primitiveMappings &&
				(!x._def.checks || !x._def.checks.length),
		)
	) {
		let types = options.reduce((types2, x) => {
			let type2 = primitiveMappings[x._def.typeName];
			return type2 && !types2.includes(type2) ? [...types2, type2] : types2;
		}, []);
		return { type: types.length > 1 ? types : types[0] };
	} else if (
		options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)
	) {
		let types = options.reduce((acc, x) => {
			let type2 = typeof x._def.value;
			switch (type2) {
				case "string":
				case "number":
				case "boolean":
					return [...acc, type2];
				case "bigint":
					return [...acc, "integer"];
				case "object":
					if (x._def.value === null) return [...acc, "null"];
				case "symbol":
				case "undefined":
				case "function":
				default:
					return acc;
			}
		}, []);
		if (types.length === options.length) {
			let uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
			return {
				type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
				enum: options.reduce((acc, x) => {
					return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
				}, []),
			};
		}
	} else if (options.every((x) => x._def.typeName === "ZodEnum"))
		return {
			type: "string",
			enum: options.reduce(
				(acc, x) => [
					...acc,
					...x._def.values.filter((x2) => !acc.includes(x2)),
				],
				[],
			),
		};
	return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
	let anyOf = (
		def.options instanceof Map ? Array.from(def.options.values()) : def.options
	)
		.map((x, i) =>
			parseDef(x._def, {
				...refs,
				currentPath: [...refs.currentPath, "anyOf", `${i}`],
			}),
		)
		.filter(
			(x) =>
				!!x &&
				(!refs.strictUnions ||
					(typeof x === "object" && Object.keys(x).length > 0)),
		);
	return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
	if (
		["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
			def.innerType._def.typeName,
		) &&
		(!def.innerType._def.checks || !def.innerType._def.checks.length)
	) {
		if (refs.target === "openApi3")
			return {
				type: primitiveMappings[def.innerType._def.typeName],
				nullable: !0,
			};
		return { type: [primitiveMappings[def.innerType._def.typeName], "null"] };
	}
	if (refs.target === "openApi3") {
		let base2 = parseDef(def.innerType._def, {
			...refs,
			currentPath: [...refs.currentPath],
		});
		if (base2 && "$ref" in base2) return { allOf: [base2], nullable: !0 };
		return base2 && { ...base2, nullable: !0 };
	}
	let base = parseDef(def.innerType._def, {
		...refs,
		currentPath: [...refs.currentPath, "anyOf", "0"],
	});
	return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def, refs) {
	let res = { type: "number" };
	if (!def.checks) return res;
	for (let check2 of def.checks)
		switch (check2.kind) {
			case "int":
				(res.type = "integer"),
					addErrorMessage(res, "type", check2.message, refs);
				break;
			case "min":
				if (refs.target === "jsonSchema7")
					if (check2.inclusive)
						setResponseValueAndErrors(
							res,
							"minimum",
							check2.value,
							check2.message,
							refs,
						);
					else
						setResponseValueAndErrors(
							res,
							"exclusiveMinimum",
							check2.value,
							check2.message,
							refs,
						);
				else {
					if (!check2.inclusive) res.exclusiveMinimum = !0;
					setResponseValueAndErrors(
						res,
						"minimum",
						check2.value,
						check2.message,
						refs,
					);
				}
				break;
			case "max":
				if (refs.target === "jsonSchema7")
					if (check2.inclusive)
						setResponseValueAndErrors(
							res,
							"maximum",
							check2.value,
							check2.message,
							refs,
						);
					else
						setResponseValueAndErrors(
							res,
							"exclusiveMaximum",
							check2.value,
							check2.message,
							refs,
						);
				else {
					if (!check2.inclusive) res.exclusiveMaximum = !0;
					setResponseValueAndErrors(
						res,
						"maximum",
						check2.value,
						check2.message,
						refs,
					);
				}
				break;
			case "multipleOf":
				setResponseValueAndErrors(
					res,
					"multipleOf",
					check2.value,
					check2.message,
					refs,
				);
				break;
		}
	return res;
}
function parseObjectDef(def, refs) {
	let forceOptionalIntoNullable = refs.target === "openAi",
		result = { type: "object", properties: {} },
		required = [],
		shape = def.shape();
	for (let propName in shape) {
		let propDef = shape[propName];
		if (propDef === void 0 || propDef._def === void 0) continue;
		let propOptional = safeIsOptional(propDef);
		if (propOptional && forceOptionalIntoNullable) {
			if (propDef instanceof ZodOptional) propDef = propDef._def.innerType;
			if (!propDef.isNullable()) propDef = propDef.nullable();
			propOptional = !1;
		}
		let parsedDef = parseDef(propDef._def, {
			...refs,
			currentPath: [...refs.currentPath, "properties", propName],
			propertyPath: [...refs.currentPath, "properties", propName],
		});
		if (parsedDef === void 0) continue;
		if (((result.properties[propName] = parsedDef), !propOptional))
			required.push(propName);
	}
	if (required.length) result.required = required;
	let additionalProperties = decideAdditionalProperties(def, refs);
	if (additionalProperties !== void 0)
		result.additionalProperties = additionalProperties;
	return result;
}
function decideAdditionalProperties(def, refs) {
	if (def.catchall._def.typeName !== "ZodNever")
		return parseDef(def.catchall._def, {
			...refs,
			currentPath: [...refs.currentPath, "additionalProperties"],
		});
	switch (def.unknownKeys) {
		case "passthrough":
			return refs.allowedAdditionalProperties;
		case "strict":
			return refs.rejectedAdditionalProperties;
		case "strip":
			return refs.removeAdditionalStrategy === "strict"
				? refs.allowedAdditionalProperties
				: refs.rejectedAdditionalProperties;
	}
}
function safeIsOptional(schema) {
	try {
		return schema.isOptional();
	} catch {
		return !0;
	}
}
var parseOptionalDef = (def, refs) => {
	if (refs.currentPath.toString() === refs.propertyPath?.toString())
		return parseDef(def.innerType._def, refs);
	let innerSchema = parseDef(def.innerType._def, {
		...refs,
		currentPath: [...refs.currentPath, "anyOf", "1"],
	});
	return innerSchema ? { anyOf: [{ not: {} }, innerSchema] } : {};
};
var parsePipelineDef = (def, refs) => {
	if (refs.pipeStrategy === "input") return parseDef(def.in._def, refs);
	else if (refs.pipeStrategy === "output") return parseDef(def.out._def, refs);
	let a = parseDef(def.in._def, {
			...refs,
			currentPath: [...refs.currentPath, "allOf", "0"],
		}),
		b = parseDef(def.out._def, {
			...refs,
			currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"],
		});
	return { allOf: [a, b].filter((x) => x !== void 0) };
};
function parsePromiseDef(def, refs) {
	return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
	let schema = {
		type: "array",
		uniqueItems: !0,
		items: parseDef(def.valueType._def, {
			...refs,
			currentPath: [...refs.currentPath, "items"],
		}),
	};
	if (def.minSize)
		setResponseValueAndErrors(
			schema,
			"minItems",
			def.minSize.value,
			def.minSize.message,
			refs,
		);
	if (def.maxSize)
		setResponseValueAndErrors(
			schema,
			"maxItems",
			def.maxSize.value,
			def.maxSize.message,
			refs,
		);
	return schema;
}
function parseTupleDef(def, refs) {
	if (def.rest)
		return {
			type: "array",
			minItems: def.items.length,
			items: def.items
				.map((x, i) =>
					parseDef(x._def, {
						...refs,
						currentPath: [...refs.currentPath, "items", `${i}`],
					}),
				)
				.reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
			additionalItems: parseDef(def.rest._def, {
				...refs,
				currentPath: [...refs.currentPath, "additionalItems"],
			}),
		};
	else
		return {
			type: "array",
			minItems: def.items.length,
			maxItems: def.items.length,
			items: def.items
				.map((x, i) =>
					parseDef(x._def, {
						...refs,
						currentPath: [...refs.currentPath, "items", `${i}`],
					}),
				)
				.reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
		};
}
function parseUndefinedDef() {
	return { not: {} };
}
function parseUnknownDef() {
	return {};
}
var parseReadonlyDef = (def, refs) => {
	return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs) => {
	switch (typeName) {
		case ZodFirstPartyTypeKind.ZodString:
			return parseStringDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNumber:
			return parseNumberDef(def, refs);
		case ZodFirstPartyTypeKind.ZodObject:
			return parseObjectDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBigInt:
			return parseBigintDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBoolean:
			return parseBooleanDef();
		case ZodFirstPartyTypeKind.ZodDate:
			return parseDateDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUndefined:
			return parseUndefinedDef();
		case ZodFirstPartyTypeKind.ZodNull:
			return parseNullDef(refs);
		case ZodFirstPartyTypeKind.ZodArray:
			return parseArrayDef(def, refs);
		case ZodFirstPartyTypeKind.ZodUnion:
		case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
			return parseUnionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodIntersection:
			return parseIntersectionDef(def, refs);
		case ZodFirstPartyTypeKind.ZodTuple:
			return parseTupleDef(def, refs);
		case ZodFirstPartyTypeKind.ZodRecord:
			return parseRecordDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLiteral:
			return parseLiteralDef(def, refs);
		case ZodFirstPartyTypeKind.ZodEnum:
			return parseEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNativeEnum:
			return parseNativeEnumDef(def);
		case ZodFirstPartyTypeKind.ZodNullable:
			return parseNullableDef(def, refs);
		case ZodFirstPartyTypeKind.ZodOptional:
			return parseOptionalDef(def, refs);
		case ZodFirstPartyTypeKind.ZodMap:
			return parseMapDef(def, refs);
		case ZodFirstPartyTypeKind.ZodSet:
			return parseSetDef(def, refs);
		case ZodFirstPartyTypeKind.ZodLazy:
			return () => def.getter()._def;
		case ZodFirstPartyTypeKind.ZodPromise:
			return parsePromiseDef(def, refs);
		case ZodFirstPartyTypeKind.ZodNaN:
		case ZodFirstPartyTypeKind.ZodNever:
			return parseNeverDef();
		case ZodFirstPartyTypeKind.ZodEffects:
			return parseEffectsDef(def, refs);
		case ZodFirstPartyTypeKind.ZodAny:
			return parseAnyDef();
		case ZodFirstPartyTypeKind.ZodUnknown:
			return parseUnknownDef();
		case ZodFirstPartyTypeKind.ZodDefault:
			return parseDefaultDef(def, refs);
		case ZodFirstPartyTypeKind.ZodBranded:
			return parseBrandedDef(def, refs);
		case ZodFirstPartyTypeKind.ZodReadonly:
			return parseReadonlyDef(def, refs);
		case ZodFirstPartyTypeKind.ZodCatch:
			return parseCatchDef(def, refs);
		case ZodFirstPartyTypeKind.ZodPipeline:
			return parsePipelineDef(def, refs);
		case ZodFirstPartyTypeKind.ZodFunction:
		case ZodFirstPartyTypeKind.ZodVoid:
		case ZodFirstPartyTypeKind.ZodSymbol:
			return;
		default:
			return ((_) => {
				return;
			})(typeName);
	}
};
function parseDef(def, refs, forceResolution = !1) {
	let seenItem = refs.seen.get(def);
	if (refs.override) {
		let overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
		if (overrideResult !== ignoreOverride) return overrideResult;
	}
	if (seenItem && !forceResolution) {
		let seenSchema = get$ref(seenItem, refs);
		if (seenSchema !== void 0) return seenSchema;
	}
	let newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
	refs.seen.set(def, newItem);
	let jsonSchemaOrGetter = selectParser(def, def.typeName, refs),
		jsonSchema =
			typeof jsonSchemaOrGetter === "function"
				? parseDef(jsonSchemaOrGetter(), refs)
				: jsonSchemaOrGetter;
	if (jsonSchema) addMeta(def, refs, jsonSchema);
	if (refs.postProcess) {
		let postProcessResult = refs.postProcess(jsonSchema, def, refs);
		return (newItem.jsonSchema = jsonSchema), postProcessResult;
	}
	return (newItem.jsonSchema = jsonSchema), jsonSchema;
}
var get$ref = (item, refs) => {
		switch (refs.$refStrategy) {
			case "root":
				return { $ref: item.path.join("/") };
			case "relative":
				return { $ref: getRelativePath(refs.currentPath, item.path) };
			case "none":
			case "seen": {
				if (
					item.path.length < refs.currentPath.length &&
					item.path.every((value, index) => refs.currentPath[index] === value)
				)
					return (
						console.warn(
							`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`,
						),
						{}
					);
				return refs.$refStrategy === "seen" ? {} : void 0;
			}
		}
	},
	getRelativePath = (pathA, pathB) => {
		let i = 0;
		for (; i < pathA.length && i < pathB.length; i++)
			if (pathA[i] !== pathB[i]) break;
		return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
	},
	addMeta = (def, refs, jsonSchema) => {
		if (def.description) {
			if (
				((jsonSchema.description = def.description), refs.markdownDescription)
			)
				jsonSchema.markdownDescription = def.description;
		}
		return jsonSchema;
	};
var zodToJsonSchema = (schema, options) => {
	let refs = getRefs(options),
		definitions =
			typeof options === "object" && options.definitions
				? Object.entries(options.definitions).reduce(
						(acc, [name15, schema2]) => ({
							...acc,
							[name15]:
								parseDef(
									schema2._def,
									{
										...refs,
										currentPath: [
											...refs.basePath,
											refs.definitionPath,
											name15,
										],
									},
									!0,
								) ?? {},
						}),
						{},
					)
				: void 0,
		name14 =
			typeof options === "string"
				? options
				: options?.nameStrategy === "title"
					? void 0
					: options?.name,
		main =
			parseDef(
				schema._def,
				name14 === void 0
					? refs
					: {
							...refs,
							currentPath: [...refs.basePath, refs.definitionPath, name14],
						},
				!1,
			) ?? {},
		title =
			typeof options === "object" &&
			options.name !== void 0 &&
			options.nameStrategy === "title"
				? options.name
				: void 0;
	if (title !== void 0) main.title = title;
	let combined =
		name14 === void 0
			? definitions
				? { ...main, [refs.definitionPath]: definitions }
				: main
			: {
					$ref: [
						...(refs.$refStrategy === "relative" ? [] : refs.basePath),
						refs.definitionPath,
						name14,
					].join("/"),
					[refs.definitionPath]: { ...definitions, [name14]: main },
				};
	if (refs.target === "jsonSchema7")
		combined.$schema = "http://json-schema.org/draft-07/schema#";
	else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi")
		combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
	if (
		refs.target === "openAi" &&
		("anyOf" in combined ||
			"oneOf" in combined ||
			"allOf" in combined ||
			("type" in combined && Array.isArray(combined.type)))
	)
		console.warn(
			"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.",
		);
	return combined;
};
var esm_default = zodToJsonSchema;
var textStreamPart = {
		code: "0",
		name: "text",
		parse: (value) => {
			if (typeof value !== "string")
				throw new Error('"text" parts expect a string value.');
			return { type: "text", value };
		},
	},
	errorStreamPart = {
		code: "3",
		name: "error",
		parse: (value) => {
			if (typeof value !== "string")
				throw new Error('"error" parts expect a string value.');
			return { type: "error", value };
		},
	},
	assistantMessageStreamPart = {
		code: "4",
		name: "assistant_message",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("id" in value) ||
				!("role" in value) ||
				!("content" in value) ||
				typeof value.id !== "string" ||
				typeof value.role !== "string" ||
				value.role !== "assistant" ||
				!Array.isArray(value.content) ||
				!value.content.every(
					(item) =>
						item != null &&
						typeof item === "object" &&
						"type" in item &&
						item.type === "text" &&
						"text" in item &&
						item.text != null &&
						typeof item.text === "object" &&
						"value" in item.text &&
						typeof item.text.value === "string",
				)
			)
				throw new Error(
					'"assistant_message" parts expect an object with an "id", "role", and "content" property.',
				);
			return { type: "assistant_message", value };
		},
	},
	assistantControlDataStreamPart = {
		code: "5",
		name: "assistant_control_data",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("threadId" in value) ||
				!("messageId" in value) ||
				typeof value.threadId !== "string" ||
				typeof value.messageId !== "string"
			)
				throw new Error(
					'"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.',
				);
			return {
				type: "assistant_control_data",
				value: { threadId: value.threadId, messageId: value.messageId },
			};
		},
	},
	dataMessageStreamPart = {
		code: "6",
		name: "data_message",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("role" in value) ||
				!("data" in value) ||
				typeof value.role !== "string" ||
				value.role !== "data"
			)
				throw new Error(
					'"data_message" parts expect an object with a "role" and "data" property.',
				);
			return { type: "data_message", value };
		},
	},
	assistantStreamParts = [
		textStreamPart,
		errorStreamPart,
		assistantMessageStreamPart,
		assistantControlDataStreamPart,
		dataMessageStreamPart,
	],
	assistantStreamPartsByCode = {
		[textStreamPart.code]: textStreamPart,
		[errorStreamPart.code]: errorStreamPart,
		[assistantMessageStreamPart.code]: assistantMessageStreamPart,
		[assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
		[dataMessageStreamPart.code]: dataMessageStreamPart,
	},
	StreamStringPrefixes = {
		[textStreamPart.name]: textStreamPart.code,
		[errorStreamPart.name]: errorStreamPart.code,
		[assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
		[assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
		[dataMessageStreamPart.name]: dataMessageStreamPart.code,
	},
	validCodes = assistantStreamParts.map((part) => part.code);
function fixJson(input) {
	let stack = ["ROOT"],
		lastValidIndex = -1,
		literalStart = null;
	function processValueStart(char, i, swapState) {
		switch (char) {
			case '"': {
				(lastValidIndex = i),
					stack.pop(),
					stack.push(swapState),
					stack.push("INSIDE_STRING");
				break;
			}
			case "f":
			case "t":
			case "n": {
				(lastValidIndex = i),
					(literalStart = i),
					stack.pop(),
					stack.push(swapState),
					stack.push("INSIDE_LITERAL");
				break;
			}
			case "-": {
				stack.pop(), stack.push(swapState), stack.push("INSIDE_NUMBER");
				break;
			}
			case "0":
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9": {
				(lastValidIndex = i),
					stack.pop(),
					stack.push(swapState),
					stack.push("INSIDE_NUMBER");
				break;
			}
			case "{": {
				(lastValidIndex = i),
					stack.pop(),
					stack.push(swapState),
					stack.push("INSIDE_OBJECT_START");
				break;
			}
			case "[": {
				(lastValidIndex = i),
					stack.pop(),
					stack.push(swapState),
					stack.push("INSIDE_ARRAY_START");
				break;
			}
		}
	}
	function processAfterObjectValue(char, i) {
		switch (char) {
			case ",": {
				stack.pop(), stack.push("INSIDE_OBJECT_AFTER_COMMA");
				break;
			}
			case "}": {
				(lastValidIndex = i), stack.pop();
				break;
			}
		}
	}
	function processAfterArrayValue(char, i) {
		switch (char) {
			case ",": {
				stack.pop(), stack.push("INSIDE_ARRAY_AFTER_COMMA");
				break;
			}
			case "]": {
				(lastValidIndex = i), stack.pop();
				break;
			}
		}
	}
	for (let i = 0; i < input.length; i++) {
		let char = input[i];
		switch (stack[stack.length - 1]) {
			case "ROOT":
				processValueStart(char, i, "FINISH");
				break;
			case "INSIDE_OBJECT_START": {
				switch (char) {
					case '"': {
						stack.pop(), stack.push("INSIDE_OBJECT_KEY");
						break;
					}
					case "}": {
						(lastValidIndex = i), stack.pop();
						break;
					}
				}
				break;
			}
			case "INSIDE_OBJECT_AFTER_COMMA": {
				switch (char) {
					case '"': {
						stack.pop(), stack.push("INSIDE_OBJECT_KEY");
						break;
					}
				}
				break;
			}
			case "INSIDE_OBJECT_KEY": {
				switch (char) {
					case '"': {
						stack.pop(), stack.push("INSIDE_OBJECT_AFTER_KEY");
						break;
					}
				}
				break;
			}
			case "INSIDE_OBJECT_AFTER_KEY": {
				switch (char) {
					case ":": {
						stack.pop(), stack.push("INSIDE_OBJECT_BEFORE_VALUE");
						break;
					}
				}
				break;
			}
			case "INSIDE_OBJECT_BEFORE_VALUE": {
				processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
				break;
			}
			case "INSIDE_OBJECT_AFTER_VALUE": {
				processAfterObjectValue(char, i);
				break;
			}
			case "INSIDE_STRING": {
				switch (char) {
					case '"': {
						stack.pop(), (lastValidIndex = i);
						break;
					}
					case "\\": {
						stack.push("INSIDE_STRING_ESCAPE");
						break;
					}
					default:
						lastValidIndex = i;
				}
				break;
			}
			case "INSIDE_ARRAY_START": {
				switch (char) {
					case "]": {
						(lastValidIndex = i), stack.pop();
						break;
					}
					default: {
						(lastValidIndex = i),
							processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
						break;
					}
				}
				break;
			}
			case "INSIDE_ARRAY_AFTER_VALUE": {
				switch (char) {
					case ",": {
						stack.pop(), stack.push("INSIDE_ARRAY_AFTER_COMMA");
						break;
					}
					case "]": {
						(lastValidIndex = i), stack.pop();
						break;
					}
					default: {
						lastValidIndex = i;
						break;
					}
				}
				break;
			}
			case "INSIDE_ARRAY_AFTER_COMMA": {
				processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
				break;
			}
			case "INSIDE_STRING_ESCAPE": {
				stack.pop(), (lastValidIndex = i);
				break;
			}
			case "INSIDE_NUMBER": {
				switch (char) {
					case "0":
					case "1":
					case "2":
					case "3":
					case "4":
					case "5":
					case "6":
					case "7":
					case "8":
					case "9": {
						lastValidIndex = i;
						break;
					}
					case "e":
					case "E":
					case "-":
					case ".":
						break;
					case ",": {
						if (
							(stack.pop(),
							stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
						)
							processAfterArrayValue(char, i);
						if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
							processAfterObjectValue(char, i);
						break;
					}
					case "}": {
						if (
							(stack.pop(),
							stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
						)
							processAfterObjectValue(char, i);
						break;
					}
					case "]": {
						if (
							(stack.pop(),
							stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
						)
							processAfterArrayValue(char, i);
						break;
					}
					default: {
						stack.pop();
						break;
					}
				}
				break;
			}
			case "INSIDE_LITERAL": {
				let partialLiteral = input.substring(literalStart, i + 1);
				if (
					!"false".startsWith(partialLiteral) &&
					!"true".startsWith(partialLiteral) &&
					!"null".startsWith(partialLiteral)
				) {
					if (
						(stack.pop(),
						stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
					)
						processAfterObjectValue(char, i);
					else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
						processAfterArrayValue(char, i);
				} else lastValidIndex = i;
				break;
			}
		}
	}
	let result = input.slice(0, lastValidIndex + 1);
	for (let i = stack.length - 1; i >= 0; i--)
		switch (stack[i]) {
			case "INSIDE_STRING": {
				result += '"';
				break;
			}
			case "INSIDE_OBJECT_KEY":
			case "INSIDE_OBJECT_AFTER_KEY":
			case "INSIDE_OBJECT_AFTER_COMMA":
			case "INSIDE_OBJECT_START":
			case "INSIDE_OBJECT_BEFORE_VALUE":
			case "INSIDE_OBJECT_AFTER_VALUE": {
				result += "}";
				break;
			}
			case "INSIDE_ARRAY_START":
			case "INSIDE_ARRAY_AFTER_COMMA":
			case "INSIDE_ARRAY_AFTER_VALUE": {
				result += "]";
				break;
			}
			case "INSIDE_LITERAL": {
				let partialLiteral = input.substring(literalStart, input.length);
				if ("true".startsWith(partialLiteral))
					result += "true".slice(partialLiteral.length);
				else if ("false".startsWith(partialLiteral))
					result += "false".slice(partialLiteral.length);
				else if ("null".startsWith(partialLiteral))
					result += "null".slice(partialLiteral.length);
			}
		}
	return result;
}
function parsePartialJson(jsonText) {
	if (jsonText === void 0) return { value: void 0, state: "undefined-input" };
	let result = safeParseJSON({ text: jsonText });
	if (result.success) return { value: result.value, state: "successful-parse" };
	if (((result = safeParseJSON({ text: fixJson(jsonText) })), result.success))
		return { value: result.value, state: "repaired-parse" };
	return { value: void 0, state: "failed-parse" };
}
var textStreamPart2 = {
		code: "0",
		name: "text",
		parse: (value) => {
			if (typeof value !== "string")
				throw new Error('"text" parts expect a string value.');
			return { type: "text", value };
		},
	},
	dataStreamPart = {
		code: "2",
		name: "data",
		parse: (value) => {
			if (!Array.isArray(value))
				throw new Error('"data" parts expect an array value.');
			return { type: "data", value };
		},
	},
	errorStreamPart2 = {
		code: "3",
		name: "error",
		parse: (value) => {
			if (typeof value !== "string")
				throw new Error('"error" parts expect a string value.');
			return { type: "error", value };
		},
	},
	messageAnnotationsStreamPart = {
		code: "8",
		name: "message_annotations",
		parse: (value) => {
			if (!Array.isArray(value))
				throw new Error('"message_annotations" parts expect an array value.');
			return { type: "message_annotations", value };
		},
	},
	toolCallStreamPart = {
		code: "9",
		name: "tool_call",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("toolCallId" in value) ||
				typeof value.toolCallId !== "string" ||
				!("toolName" in value) ||
				typeof value.toolName !== "string" ||
				!("args" in value) ||
				typeof value.args !== "object"
			)
				throw new Error(
					'"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.',
				);
			return { type: "tool_call", value };
		},
	},
	toolResultStreamPart = {
		code: "a",
		name: "tool_result",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("toolCallId" in value) ||
				typeof value.toolCallId !== "string" ||
				!("result" in value)
			)
				throw new Error(
					'"tool_result" parts expect an object with a "toolCallId" and a "result" property.',
				);
			return { type: "tool_result", value };
		},
	},
	toolCallStreamingStartStreamPart = {
		code: "b",
		name: "tool_call_streaming_start",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("toolCallId" in value) ||
				typeof value.toolCallId !== "string" ||
				!("toolName" in value) ||
				typeof value.toolName !== "string"
			)
				throw new Error(
					'"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.',
				);
			return { type: "tool_call_streaming_start", value };
		},
	},
	toolCallDeltaStreamPart = {
		code: "c",
		name: "tool_call_delta",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("toolCallId" in value) ||
				typeof value.toolCallId !== "string" ||
				!("argsTextDelta" in value) ||
				typeof value.argsTextDelta !== "string"
			)
				throw new Error(
					'"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.',
				);
			return { type: "tool_call_delta", value };
		},
	},
	finishMessageStreamPart = {
		code: "d",
		name: "finish_message",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("finishReason" in value) ||
				typeof value.finishReason !== "string"
			)
				throw new Error(
					'"finish_message" parts expect an object with a "finishReason" property.',
				);
			let result = { finishReason: value.finishReason };
			if (
				"usage" in value &&
				value.usage != null &&
				typeof value.usage === "object" &&
				"promptTokens" in value.usage &&
				"completionTokens" in value.usage
			)
				result.usage = {
					promptTokens:
						typeof value.usage.promptTokens === "number"
							? value.usage.promptTokens
							: Number.NaN,
					completionTokens:
						typeof value.usage.completionTokens === "number"
							? value.usage.completionTokens
							: Number.NaN,
				};
			return { type: "finish_message", value: result };
		},
	},
	finishStepStreamPart = {
		code: "e",
		name: "finish_step",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("finishReason" in value) ||
				typeof value.finishReason !== "string"
			)
				throw new Error(
					'"finish_step" parts expect an object with a "finishReason" property.',
				);
			let result = { finishReason: value.finishReason, isContinued: !1 };
			if (
				"usage" in value &&
				value.usage != null &&
				typeof value.usage === "object" &&
				"promptTokens" in value.usage &&
				"completionTokens" in value.usage
			)
				result.usage = {
					promptTokens:
						typeof value.usage.promptTokens === "number"
							? value.usage.promptTokens
							: Number.NaN,
					completionTokens:
						typeof value.usage.completionTokens === "number"
							? value.usage.completionTokens
							: Number.NaN,
				};
			if ("isContinued" in value && typeof value.isContinued === "boolean")
				result.isContinued = value.isContinued;
			return { type: "finish_step", value: result };
		},
	},
	startStepStreamPart = {
		code: "f",
		name: "start_step",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("messageId" in value) ||
				typeof value.messageId !== "string"
			)
				throw new Error(
					'"start_step" parts expect an object with an "id" property.',
				);
			return { type: "start_step", value: { messageId: value.messageId } };
		},
	},
	reasoningStreamPart = {
		code: "g",
		name: "reasoning",
		parse: (value) => {
			if (typeof value !== "string")
				throw new Error('"reasoning" parts expect a string value.');
			return { type: "reasoning", value };
		},
	},
	sourcePart = {
		code: "h",
		name: "source",
		parse: (value) => {
			if (value == null || typeof value !== "object")
				throw new Error('"source" parts expect a Source object.');
			return { type: "source", value };
		},
	},
	redactedReasoningStreamPart = {
		code: "i",
		name: "redacted_reasoning",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("data" in value) ||
				typeof value.data !== "string"
			)
				throw new Error(
					'"redacted_reasoning" parts expect an object with a "data" property.',
				);
			return { type: "redacted_reasoning", value: { data: value.data } };
		},
	},
	reasoningSignatureStreamPart = {
		code: "j",
		name: "reasoning_signature",
		parse: (value) => {
			if (
				value == null ||
				typeof value !== "object" ||
				!("signature" in value) ||
				typeof value.signature !== "string"
			)
				throw new Error(
					'"reasoning_signature" parts expect an object with a "signature" property.',
				);
			return {
				type: "reasoning_signature",
				value: { signature: value.signature },
			};
		},
	},
	dataStreamParts = [
		textStreamPart2,
		dataStreamPart,
		errorStreamPart2,
		messageAnnotationsStreamPart,
		toolCallStreamPart,
		toolResultStreamPart,
		toolCallStreamingStartStreamPart,
		toolCallDeltaStreamPart,
		finishMessageStreamPart,
		finishStepStreamPart,
		startStepStreamPart,
		reasoningStreamPart,
		sourcePart,
		redactedReasoningStreamPart,
		reasoningSignatureStreamPart,
	],
	dataStreamPartsByCode = Object.fromEntries(
		dataStreamParts.map((part) => [part.code, part]),
	),
	DataStreamStringPrefixes = Object.fromEntries(
		dataStreamParts.map((part) => [part.name, part.code]),
	),
	validCodes2 = dataStreamParts.map((part) => part.code);
function formatDataStreamPart(type2, value) {
	let streamPart = dataStreamParts.find((part) => part.name === type2);
	if (!streamPart) throw new Error(`Invalid stream part type: ${type2}`);
	return `${streamPart.code}:${JSON.stringify(value)}
`;
}
function zodSchema(zodSchema2, options) {
	var _a15;
	let useReferences =
		(_a15 = options == null ? void 0 : options.useReferences) != null
			? _a15
			: !1;
	return jsonSchema(
		esm_default(zodSchema2, {
			$refStrategy: useReferences ? "root" : "none",
			target: "jsonSchema7",
		}),
		{
			validate: (value) => {
				let result = zodSchema2.safeParse(value);
				return result.success
					? { success: !0, value: result.data }
					: { success: !1, error: result.error };
			},
		},
	);
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, { validate } = {}) {
	return {
		[schemaSymbol]: !0,
		_type: void 0,
		[validatorSymbol]: !0,
		jsonSchema: jsonSchema2,
		validate,
	};
}
function isSchema(value) {
	return (
		typeof value === "object" &&
		value !== null &&
		schemaSymbol in value &&
		value[schemaSymbol] === !0 &&
		"jsonSchema" in value &&
		"validate" in value
	);
}
function asSchema(schema) {
	return isSchema(schema) ? schema : zodSchema(schema);
}
var import_api = __toESM(require_src(), 1),
	import_api2 = __toESM(require_src(), 1);
var __defProp3 = Object.defineProperty;
var __export2 = (target, all2) => {
	for (var name17 in all2)
		__defProp3(target, name17, { get: all2[name17], enumerable: !0 });
};
function prepareResponseHeaders(headers, { contentType, dataStreamVersion }) {
	let responseHeaders = new Headers(headers != null ? headers : {});
	if (!responseHeaders.has("Content-Type"))
		responseHeaders.set("Content-Type", contentType);
	if (dataStreamVersion !== void 0)
		responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
	return responseHeaders;
}
var name14 = "AI_InvalidArgumentError",
	marker15 = `vercel.ai.error.${name14}`,
	symbol15 = Symbol.for(marker15),
	_a15,
	InvalidArgumentError2 = class extends AISDKError {
		constructor({ parameter, value, message }) {
			super({
				name: name14,
				message: `Invalid argument for parameter ${parameter}: ${message}`,
			});
			(this[_a15] = !0), (this.parameter = parameter), (this.value = value);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker15);
		}
	};
_a15 = symbol15;
var name22 = "AI_RetryError",
	marker22 = `vercel.ai.error.${name22}`,
	symbol22 = Symbol.for(marker22),
	_a22,
	RetryError = class extends AISDKError {
		constructor({ message, reason, errors }) {
			super({ name: name22, message });
			(this[_a22] = !0),
				(this.reason = reason),
				(this.errors = errors),
				(this.lastError = errors[errors.length - 1]);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker22);
		}
	};
_a22 = symbol22;
var retryWithExponentialBackoff =
	({ maxRetries = 2, initialDelayInMs = 2000, backoffFactor = 2 } = {}) =>
	async (f) =>
		_retryWithExponentialBackoff(f, {
			maxRetries,
			delayInMs: initialDelayInMs,
			backoffFactor,
		});
async function _retryWithExponentialBackoff(
	f,
	{ maxRetries, delayInMs, backoffFactor },
	errors = [],
) {
	try {
		return await f();
	} catch (error2) {
		if (isAbortError(error2)) throw error2;
		if (maxRetries === 0) throw error2;
		let errorMessage = getErrorMessage2(error2),
			newErrors = [...errors, error2],
			tryNumber = newErrors.length;
		if (tryNumber > maxRetries)
			throw new RetryError({
				message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
				reason: "maxRetriesExceeded",
				errors: newErrors,
			});
		if (
			error2 instanceof Error &&
			APICallError.isInstance(error2) &&
			error2.isRetryable === !0 &&
			tryNumber <= maxRetries
		)
			return (
				await delay2(delayInMs),
				_retryWithExponentialBackoff(
					f,
					{ maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },
					newErrors,
				)
			);
		if (tryNumber === 1) throw error2;
		throw new RetryError({
			message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
			reason: "errorNotRetryable",
			errors: newErrors,
		});
	}
}
function prepareRetries({ maxRetries }) {
	if (maxRetries != null) {
		if (!Number.isInteger(maxRetries))
			throw new InvalidArgumentError2({
				parameter: "maxRetries",
				value: maxRetries,
				message: "maxRetries must be an integer",
			});
		if (maxRetries < 0)
			throw new InvalidArgumentError2({
				parameter: "maxRetries",
				value: maxRetries,
				message: "maxRetries must be >= 0",
			});
	}
	let maxRetriesResult = maxRetries != null ? maxRetries : 2;
	return {
		maxRetries: maxRetriesResult,
		retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult }),
	};
}
function assembleOperationName({ operationId, telemetry }) {
	return {
		"operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
		"resource.name": telemetry == null ? void 0 : telemetry.functionId,
		"ai.operationId": operationId,
		"ai.telemetry.functionId":
			telemetry == null ? void 0 : telemetry.functionId,
	};
}
function getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {
	var _a17;
	return {
		"ai.model.provider": model.provider,
		"ai.model.id": model.modelId,
		...Object.entries(settings).reduce((attributes, [key, value]) => {
			return (attributes[`ai.settings.${key}`] = value), attributes;
		}, {}),
		...Object.entries(
			(_a17 = telemetry == null ? void 0 : telemetry.metadata) != null
				? _a17
				: {},
		).reduce((attributes, [key, value]) => {
			return (attributes[`ai.telemetry.metadata.${key}`] = value), attributes;
		}, {}),
		...Object.entries(headers != null ? headers : {}).reduce(
			(attributes, [key, value]) => {
				if (value !== void 0) attributes[`ai.request.headers.${key}`] = value;
				return attributes;
			},
			{},
		),
	};
}
var noopTracer = {
		startSpan() {
			return noopSpan;
		},
		startActiveSpan(name17, arg1, arg2, arg3) {
			if (typeof arg1 === "function") return arg1(noopSpan);
			if (typeof arg2 === "function") return arg2(noopSpan);
			if (typeof arg3 === "function") return arg3(noopSpan);
		},
	},
	noopSpan = {
		spanContext() {
			return noopSpanContext;
		},
		setAttribute() {
			return this;
		},
		setAttributes() {
			return this;
		},
		addEvent() {
			return this;
		},
		addLink() {
			return this;
		},
		addLinks() {
			return this;
		},
		setStatus() {
			return this;
		},
		updateName() {
			return this;
		},
		end() {
			return this;
		},
		isRecording() {
			return !1;
		},
		recordException() {
			return this;
		},
	},
	noopSpanContext = { traceId: "", spanId: "", traceFlags: 0 };
function getTracer({ isEnabled = !1, tracer } = {}) {
	if (!isEnabled) return noopTracer;
	if (tracer) return tracer;
	return import_api.trace.getTracer("ai");
}
function recordSpan({
	name: name17,
	tracer,
	attributes,
	fn,
	endWhenDone = !0,
}) {
	return tracer.startActiveSpan(name17, { attributes }, async (span) => {
		try {
			let result = await fn(span);
			if (endWhenDone) span.end();
			return result;
		} catch (error2) {
			try {
				if (error2 instanceof Error)
					span.recordException({
						name: error2.name,
						message: error2.message,
						stack: error2.stack,
					}),
						span.setStatus({
							code: import_api2.SpanStatusCode.ERROR,
							message: error2.message,
						});
				else span.setStatus({ code: import_api2.SpanStatusCode.ERROR });
			} finally {
				span.end();
			}
			throw error2;
		}
	});
}
function selectTelemetryAttributes({ telemetry, attributes }) {
	if ((telemetry == null ? void 0 : telemetry.isEnabled) !== !0) return {};
	return Object.entries(attributes).reduce((attributes2, [key, value]) => {
		if (value === void 0) return attributes2;
		if (
			typeof value === "object" &&
			"input" in value &&
			typeof value.input === "function"
		) {
			if ((telemetry == null ? void 0 : telemetry.recordInputs) === !1)
				return attributes2;
			let result = value.input();
			return result === void 0
				? attributes2
				: { ...attributes2, [key]: result };
		}
		if (
			typeof value === "object" &&
			"output" in value &&
			typeof value.output === "function"
		) {
			if ((telemetry == null ? void 0 : telemetry.recordOutputs) === !1)
				return attributes2;
			let result = value.output();
			return result === void 0
				? attributes2
				: { ...attributes2, [key]: result };
		}
		return { ...attributes2, [key]: value };
	}, {});
}
var name32 = "AI_NoImageGeneratedError",
	marker32 = `vercel.ai.error.${name32}`,
	symbol32 = Symbol.for(marker32),
	_a32;
_a32 = symbol32;
var name42 = "AI_NoObjectGeneratedError",
	marker42 = `vercel.ai.error.${name42}`,
	symbol42 = Symbol.for(marker42),
	_a42,
	NoObjectGeneratedError = class extends AISDKError {
		constructor({
			message = "No object generated.",
			cause,
			text: text2,
			response,
			usage,
		}) {
			super({ name: name42, message, cause });
			(this[_a42] = !0),
				(this.text = text2),
				(this.response = response),
				(this.usage = usage);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker42);
		}
	};
_a42 = symbol42;
var name52 = "AI_DownloadError",
	marker52 = `vercel.ai.error.${name52}`,
	symbol52 = Symbol.for(marker52),
	_a52,
	DownloadError = class extends AISDKError {
		constructor({
			url,
			statusCode,
			statusText,
			cause,
			message = cause == null
				? `Failed to download ${url}: ${statusCode} ${statusText}`
				: `Failed to download ${url}: ${cause}`,
		}) {
			super({ name: name52, message, cause });
			(this[_a52] = !0),
				(this.url = url),
				(this.statusCode = statusCode),
				(this.statusText = statusText);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker52);
		}
	};
_a52 = symbol52;
async function download({ url, fetchImplementation = fetch }) {
	var _a17;
	let urlText = url.toString();
	try {
		let response = await fetchImplementation(urlText);
		if (!response.ok)
			throw new DownloadError({
				url: urlText,
				statusCode: response.status,
				statusText: response.statusText,
			});
		return {
			data: new Uint8Array(await response.arrayBuffer()),
			mimeType:
				(_a17 = response.headers.get("content-type")) != null ? _a17 : void 0,
		};
	} catch (error2) {
		if (DownloadError.isInstance(error2)) throw error2;
		throw new DownloadError({ url: urlText, cause: error2 });
	}
}
var mimeTypeSignatures = [
	{ mimeType: "image/gif", bytes: [71, 73, 70] },
	{ mimeType: "image/png", bytes: [137, 80, 78, 71] },
	{ mimeType: "image/jpeg", bytes: [255, 216] },
	{ mimeType: "image/webp", bytes: [82, 73, 70, 70] },
];
function detectImageMimeType(image) {
	for (let { bytes, mimeType } of mimeTypeSignatures)
		if (
			image.length >= bytes.length &&
			bytes.every((byte2, index) => image[index] === byte2)
		)
			return mimeType;
	return;
}
var name62 = "AI_InvalidDataContentError",
	marker62 = `vercel.ai.error.${name62}`,
	symbol62 = Symbol.for(marker62),
	_a62,
	InvalidDataContentError = class extends AISDKError {
		constructor({
			content,
			cause,
			message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,
		}) {
			super({ name: name62, message, cause });
			(this[_a62] = !0), (this.content = content);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker62);
		}
	};
_a62 = symbol62;
var dataContentSchema = z.union([
	z.string(),
	z.instanceof(Uint8Array),
	z.instanceof(ArrayBuffer),
	z.custom(
		(value) => {
			var _a17, _b;
			return (_b =
				(_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) !=
				null
				? _b
				: !1;
		},
		{ message: "Must be a Buffer" },
	),
]);
function convertDataContentToBase64String(content) {
	if (typeof content === "string") return content;
	if (content instanceof ArrayBuffer)
		return convertUint8ArrayToBase64(new Uint8Array(content));
	return convertUint8ArrayToBase64(content);
}
function convertDataContentToUint8Array(content) {
	if (content instanceof Uint8Array) return content;
	if (typeof content === "string")
		try {
			return convertBase64ToUint8Array(content);
		} catch (error2) {
			throw new InvalidDataContentError({
				message:
					"Invalid data content. Content string is not a base64-encoded media.",
				content,
				cause: error2,
			});
		}
	if (content instanceof ArrayBuffer) return new Uint8Array(content);
	throw new InvalidDataContentError({ content });
}
function convertUint8ArrayToText(uint8Array) {
	try {
		return new TextDecoder().decode(uint8Array);
	} catch (error2) {
		throw new Error("Error decoding Uint8Array to text");
	}
}
var name72 = "AI_InvalidMessageRoleError",
	marker72 = `vercel.ai.error.${name72}`,
	symbol72 = Symbol.for(marker72),
	_a72,
	InvalidMessageRoleError = class extends AISDKError {
		constructor({
			role,
			message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`,
		}) {
			super({ name: name72, message });
			(this[_a72] = !0), (this.role = role);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker72);
		}
	};
_a72 = symbol72;
function splitDataUrl(dataUrl) {
	try {
		let [header, base64Content] = dataUrl.split(",");
		return { mimeType: header.split(";")[0].split(":")[1], base64Content };
	} catch (error2) {
		return { mimeType: void 0, base64Content: void 0 };
	}
}
async function convertToLanguageModelPrompt({
	prompt,
	modelSupportsImageUrls = !0,
	modelSupportsUrl = () => !1,
	downloadImplementation = download,
}) {
	let downloadedAssets = await downloadAssets(
		prompt.messages,
		downloadImplementation,
		modelSupportsImageUrls,
		modelSupportsUrl,
	);
	return [
		...(prompt.system != null
			? [{ role: "system", content: prompt.system }]
			: []),
		...prompt.messages.map((message) =>
			convertToLanguageModelMessage(message, downloadedAssets),
		),
	];
}
function convertToLanguageModelMessage(message, downloadedAssets) {
	var _a17, _b, _c, _d, _e, _f;
	let role = message.role;
	switch (role) {
		case "system":
			return {
				role: "system",
				content: message.content,
				providerMetadata:
					(_a17 = message.providerOptions) != null
						? _a17
						: message.experimental_providerMetadata,
			};
		case "user": {
			if (typeof message.content === "string")
				return {
					role: "user",
					content: [{ type: "text", text: message.content }],
					providerMetadata:
						(_b = message.providerOptions) != null
							? _b
							: message.experimental_providerMetadata,
				};
			return {
				role: "user",
				content: message.content
					.map((part) => convertPartToLanguageModelPart(part, downloadedAssets))
					.filter((part) => part.type !== "text" || part.text !== ""),
				providerMetadata:
					(_c = message.providerOptions) != null
						? _c
						: message.experimental_providerMetadata,
			};
		}
		case "assistant": {
			if (typeof message.content === "string")
				return {
					role: "assistant",
					content: [{ type: "text", text: message.content }],
					providerMetadata:
						(_d = message.providerOptions) != null
							? _d
							: message.experimental_providerMetadata,
				};
			return {
				role: "assistant",
				content: message.content
					.filter((part) => part.type !== "text" || part.text !== "")
					.map((part) => {
						let { experimental_providerMetadata, providerOptions, ...rest } =
							part;
						return {
							...rest,
							providerMetadata:
								providerOptions != null
									? providerOptions
									: experimental_providerMetadata,
						};
					}),
				providerMetadata:
					(_e = message.providerOptions) != null
						? _e
						: message.experimental_providerMetadata,
			};
		}
		case "tool":
			return {
				role: "tool",
				content: message.content.map((part) => {
					var _a18;
					return {
						type: "tool-result",
						toolCallId: part.toolCallId,
						toolName: part.toolName,
						result: part.result,
						content: part.experimental_content,
						isError: part.isError,
						providerMetadata:
							(_a18 = part.providerOptions) != null
								? _a18
								: part.experimental_providerMetadata,
					};
				}),
				providerMetadata:
					(_f = message.providerOptions) != null
						? _f
						: message.experimental_providerMetadata,
			};
		default:
			throw new InvalidMessageRoleError({ role });
	}
}
async function downloadAssets(
	messages,
	downloadImplementation,
	modelSupportsImageUrls,
	modelSupportsUrl,
) {
	let urls = messages
			.filter((message) => message.role === "user")
			.map((message) => message.content)
			.filter((content) => Array.isArray(content))
			.flat()
			.filter((part) => part.type === "image" || part.type === "file")
			.filter(
				(part) => !(part.type === "image" && modelSupportsImageUrls === !0),
			)
			.map((part) => (part.type === "image" ? part.image : part.data))
			.map((part) =>
				typeof part === "string" &&
				(part.startsWith("http:") || part.startsWith("https:"))
					? new URL(part)
					: part,
			)
			.filter((image) => image instanceof URL)
			.filter((url) => !modelSupportsUrl(url)),
		downloadedImages = await Promise.all(
			urls.map(async (url) => ({
				url,
				data: await downloadImplementation({ url }),
			})),
		);
	return Object.fromEntries(
		downloadedImages.map(({ url, data }) => [url.toString(), data]),
	);
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
	var _a17, _b, _c, _d;
	if (part.type === "text")
		return {
			type: "text",
			text: part.text,
			providerMetadata:
				(_a17 = part.providerOptions) != null
					? _a17
					: part.experimental_providerMetadata,
		};
	let mimeType = part.mimeType,
		data,
		content,
		normalizedData,
		type2 = part.type;
	switch (type2) {
		case "image":
			data = part.image;
			break;
		case "file":
			data = part.data;
			break;
		default:
			throw new Error(`Unsupported part type: ${type2}`);
	}
	try {
		content = typeof data === "string" ? new URL(data) : data;
	} catch (error2) {
		content = data;
	}
	if (content instanceof URL)
		if (content.protocol === "data:") {
			let { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(
				content.toString(),
			);
			if (dataUrlMimeType == null || base64Content == null)
				throw new Error(`Invalid data URL format in part ${type2}`);
			(mimeType = dataUrlMimeType),
				(normalizedData = convertDataContentToUint8Array(base64Content));
		} else {
			let downloadedFile = downloadedAssets[content.toString()];
			if (downloadedFile)
				(normalizedData = downloadedFile.data),
					mimeType != null || (mimeType = downloadedFile.mimeType);
			else normalizedData = content;
		}
	else normalizedData = convertDataContentToUint8Array(content);
	switch (type2) {
		case "image": {
			if (normalizedData instanceof Uint8Array)
				mimeType =
					(_b = detectImageMimeType(normalizedData)) != null ? _b : mimeType;
			return {
				type: "image",
				image: normalizedData,
				mimeType,
				providerMetadata:
					(_c = part.providerOptions) != null
						? _c
						: part.experimental_providerMetadata,
			};
		}
		case "file": {
			if (mimeType == null)
				throw new Error("Mime type is missing for file part");
			return {
				type: "file",
				data:
					normalizedData instanceof Uint8Array
						? convertDataContentToBase64String(normalizedData)
						: normalizedData,
				filename: part.filename,
				mimeType,
				providerMetadata:
					(_d = part.providerOptions) != null
						? _d
						: part.experimental_providerMetadata,
			};
		}
	}
}
function prepareCallSettings({
	maxTokens,
	temperature,
	topP,
	topK,
	presencePenalty,
	frequencyPenalty,
	stopSequences,
	seed,
}) {
	if (maxTokens != null) {
		if (!Number.isInteger(maxTokens))
			throw new InvalidArgumentError2({
				parameter: "maxTokens",
				value: maxTokens,
				message: "maxTokens must be an integer",
			});
		if (maxTokens < 1)
			throw new InvalidArgumentError2({
				parameter: "maxTokens",
				value: maxTokens,
				message: "maxTokens must be >= 1",
			});
	}
	if (temperature != null) {
		if (typeof temperature !== "number")
			throw new InvalidArgumentError2({
				parameter: "temperature",
				value: temperature,
				message: "temperature must be a number",
			});
	}
	if (topP != null) {
		if (typeof topP !== "number")
			throw new InvalidArgumentError2({
				parameter: "topP",
				value: topP,
				message: "topP must be a number",
			});
	}
	if (topK != null) {
		if (typeof topK !== "number")
			throw new InvalidArgumentError2({
				parameter: "topK",
				value: topK,
				message: "topK must be a number",
			});
	}
	if (presencePenalty != null) {
		if (typeof presencePenalty !== "number")
			throw new InvalidArgumentError2({
				parameter: "presencePenalty",
				value: presencePenalty,
				message: "presencePenalty must be a number",
			});
	}
	if (frequencyPenalty != null) {
		if (typeof frequencyPenalty !== "number")
			throw new InvalidArgumentError2({
				parameter: "frequencyPenalty",
				value: frequencyPenalty,
				message: "frequencyPenalty must be a number",
			});
	}
	if (seed != null) {
		if (!Number.isInteger(seed))
			throw new InvalidArgumentError2({
				parameter: "seed",
				value: seed,
				message: "seed must be an integer",
			});
	}
	return {
		maxTokens,
		temperature: temperature != null ? temperature : 0,
		topP,
		topK,
		presencePenalty,
		frequencyPenalty,
		stopSequences:
			stopSequences != null && stopSequences.length > 0
				? stopSequences
				: void 0,
		seed,
	};
}
function attachmentsToParts(attachments) {
	var _a17, _b, _c;
	let parts = [];
	for (let attachment of attachments) {
		let url;
		try {
			url = new URL(attachment.url);
		} catch (error2) {
			throw new Error(`Invalid URL: ${attachment.url}`);
		}
		switch (url.protocol) {
			case "http:":
			case "https:": {
				if (
					(_a17 = attachment.contentType) == null
						? void 0
						: _a17.startsWith("image/")
				)
					parts.push({ type: "image", image: url });
				else {
					if (!attachment.contentType)
						throw new Error(
							"If the attachment is not an image, it must specify a content type",
						);
					parts.push({
						type: "file",
						data: url,
						mimeType: attachment.contentType,
					});
				}
				break;
			}
			case "data:": {
				let header, base64Content, mimeType;
				try {
					([header, base64Content] = attachment.url.split(",")),
						(mimeType = header.split(";")[0].split(":")[1]);
				} catch (error2) {
					throw new Error(`Error processing data URL: ${attachment.url}`);
				}
				if (mimeType == null || base64Content == null)
					throw new Error(`Invalid data URL format: ${attachment.url}`);
				if (
					(_b = attachment.contentType) == null
						? void 0
						: _b.startsWith("image/")
				)
					parts.push({
						type: "image",
						image: convertDataContentToUint8Array(base64Content),
					});
				else if (
					(_c = attachment.contentType) == null
						? void 0
						: _c.startsWith("text/")
				)
					parts.push({
						type: "text",
						text: convertUint8ArrayToText(
							convertDataContentToUint8Array(base64Content),
						),
					});
				else {
					if (!attachment.contentType)
						throw new Error(
							"If the attachment is not an image or text, it must specify a content type",
						);
					parts.push({
						type: "file",
						data: base64Content,
						mimeType: attachment.contentType,
					});
				}
				break;
			}
			default:
				throw new Error(`Unsupported URL protocol: ${url.protocol}`);
		}
	}
	return parts;
}
var name82 = "AI_MessageConversionError",
	marker82 = `vercel.ai.error.${name82}`,
	symbol82 = Symbol.for(marker82),
	_a82,
	MessageConversionError = class extends AISDKError {
		constructor({ originalMessage, message }) {
			super({ name: name82, message });
			(this[_a82] = !0), (this.originalMessage = originalMessage);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker82);
		}
	};
_a82 = symbol82;
function convertToCoreMessages(messages, options) {
	var _a17, _b;
	let tools =
			(_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {},
		coreMessages = [];
	for (let i = 0; i < messages.length; i++) {
		let message = messages[i],
			isLastMessage = i === messages.length - 1,
			{ role, content, experimental_attachments } = message;
		switch (role) {
			case "system": {
				coreMessages.push({ role: "system", content });
				break;
			}
			case "user": {
				coreMessages.push({
					role: "user",
					content: experimental_attachments
						? [
								{ type: "text", text: content },
								...attachmentsToParts(experimental_attachments),
							]
						: content,
				});
				break;
			}
			case "assistant": {
				if (message.parts != null) {
					let processBlock2 = function () {
						let content2 = [];
						for (let part of block)
							switch (part.type) {
								case "text":
									content2.push({ type: "text", text: part.text });
									break;
								case "reasoning": {
									for (let detail of part.details)
										switch (detail.type) {
											case "text":
												content2.push({
													type: "reasoning",
													text: detail.text,
													signature: detail.signature,
												});
												break;
											case "redacted":
												content2.push({
													type: "redacted-reasoning",
													data: detail.data,
												});
												break;
										}
									break;
								}
								case "tool-invocation":
									content2.push({
										type: "tool-call",
										toolCallId: part.toolInvocation.toolCallId,
										toolName: part.toolInvocation.toolName,
										args: part.toolInvocation.args,
									});
									break;
								default:
									throw new Error(`Unsupported part: ${part}`);
							}
						coreMessages.push({ role: "assistant", content: content2 });
						let stepInvocations = block
							.filter((part) => part.type === "tool-invocation")
							.map((part) => part.toolInvocation);
						if (stepInvocations.length > 0)
							coreMessages.push({
								role: "tool",
								content: stepInvocations.map((toolInvocation) => {
									if (!("result" in toolInvocation))
										throw new MessageConversionError({
											originalMessage: message,
											message:
												"ToolInvocation must have a result: " +
												JSON.stringify(toolInvocation),
										});
									let { toolCallId, toolName, result } = toolInvocation,
										tool2 = tools[toolName];
									return (tool2 == null
										? void 0
										: tool2.experimental_toToolResultContent) != null
										? {
												type: "tool-result",
												toolCallId,
												toolName,
												result: tool2.experimental_toToolResultContent(result),
												experimental_content:
													tool2.experimental_toToolResultContent(result),
											}
										: { type: "tool-result", toolCallId, toolName, result };
								}),
							});
						(block = []), (blockHasToolInvocations = !1), currentStep++;
					};
					var processBlock = processBlock2;
					let currentStep = 0,
						blockHasToolInvocations = !1,
						block = [];
					for (let part of message.parts)
						switch (part.type) {
							case "reasoning":
								block.push(part);
								break;
							case "text": {
								if (blockHasToolInvocations) processBlock2();
								block.push(part);
								break;
							}
							case "tool-invocation": {
								if (
									((_b = part.toolInvocation.step) != null ? _b : 0) !==
									currentStep
								)
									processBlock2();
								block.push(part), (blockHasToolInvocations = !0);
								break;
							}
						}
					processBlock2();
					break;
				}
				let toolInvocations = message.toolInvocations;
				if (toolInvocations == null || toolInvocations.length === 0) {
					coreMessages.push({ role: "assistant", content });
					break;
				}
				let maxStep = toolInvocations.reduce((max, toolInvocation) => {
					var _a18;
					return Math.max(max, (_a18 = toolInvocation.step) != null ? _a18 : 0);
				}, 0);
				for (let i2 = 0; i2 <= maxStep; i2++) {
					let stepInvocations = toolInvocations.filter((toolInvocation) => {
						var _a18;
						return ((_a18 = toolInvocation.step) != null ? _a18 : 0) === i2;
					});
					if (stepInvocations.length === 0) continue;
					coreMessages.push({
						role: "assistant",
						content: [
							...(isLastMessage && content && i2 === 0
								? [{ type: "text", text: content }]
								: []),
							...stepInvocations.map(({ toolCallId, toolName, args }) => ({
								type: "tool-call",
								toolCallId,
								toolName,
								args,
							})),
						],
					}),
						coreMessages.push({
							role: "tool",
							content: stepInvocations.map((toolInvocation) => {
								if (!("result" in toolInvocation))
									throw new MessageConversionError({
										originalMessage: message,
										message:
											"ToolInvocation must have a result: " +
											JSON.stringify(toolInvocation),
									});
								let { toolCallId, toolName, result } = toolInvocation,
									tool2 = tools[toolName];
								return (tool2 == null
									? void 0
									: tool2.experimental_toToolResultContent) != null
									? {
											type: "tool-result",
											toolCallId,
											toolName,
											result: tool2.experimental_toToolResultContent(result),
											experimental_content:
												tool2.experimental_toToolResultContent(result),
										}
									: { type: "tool-result", toolCallId, toolName, result };
							}),
						});
				}
				if (content && !isLastMessage)
					coreMessages.push({ role: "assistant", content });
				break;
			}
			case "data":
				break;
			default:
				throw new MessageConversionError({
					originalMessage: message,
					message: `Unsupported role: ${role}`,
				});
		}
	}
	return coreMessages;
}
function detectPromptType(prompt) {
	if (!Array.isArray(prompt)) return "other";
	if (prompt.length === 0) return "messages";
	let characteristics = prompt.map(detectSingleMessageCharacteristics);
	if (characteristics.some((c) => c === "has-ui-specific-parts"))
		return "ui-messages";
	else if (
		characteristics.every(
			(c) => c === "has-core-specific-parts" || c === "message",
		)
	)
		return "messages";
	else return "other";
}
function detectSingleMessageCharacteristics(message) {
	if (
		typeof message === "object" &&
		message !== null &&
		(message.role === "function" ||
			message.role === "data" ||
			"toolInvocations" in message ||
			"experimental_attachments" in message)
	)
		return "has-ui-specific-parts";
	else if (
		typeof message === "object" &&
		message !== null &&
		"content" in message &&
		(Array.isArray(message.content) ||
			"experimental_providerMetadata" in message ||
			"providerOptions" in message)
	)
		return "has-core-specific-parts";
	else if (
		typeof message === "object" &&
		message !== null &&
		"role" in message &&
		"content" in message &&
		typeof message.content === "string" &&
		["system", "user", "assistant", "tool"].includes(message.role)
	)
		return "message";
	else return "other";
}
var jsonValueSchema = z.lazy(() =>
		z.union([
			z.null(),
			z.string(),
			z.number(),
			z.boolean(),
			z.record(z.string(), jsonValueSchema),
			z.array(jsonValueSchema),
		]),
	),
	providerMetadataSchema = z.record(
		z.string(),
		z.record(z.string(), jsonValueSchema),
	),
	toolResultContentSchema = z.array(
		z.union([
			z.object({ type: z.literal("text"), text: z.string() }),
			z.object({
				type: z.literal("image"),
				data: z.string(),
				mimeType: z.string().optional(),
			}),
		]),
	),
	textPartSchema = z.object({
		type: z.literal("text"),
		text: z.string(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	imagePartSchema = z.object({
		type: z.literal("image"),
		image: z.union([dataContentSchema, z.instanceof(URL)]),
		mimeType: z.string().optional(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	filePartSchema = z.object({
		type: z.literal("file"),
		data: z.union([dataContentSchema, z.instanceof(URL)]),
		filename: z.string().optional(),
		mimeType: z.string(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	reasoningPartSchema = z.object({
		type: z.literal("reasoning"),
		text: z.string(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	redactedReasoningPartSchema = z.object({
		type: z.literal("redacted-reasoning"),
		data: z.string(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	toolCallPartSchema = z.object({
		type: z.literal("tool-call"),
		toolCallId: z.string(),
		toolName: z.string(),
		args: z.unknown(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	toolResultPartSchema = z.object({
		type: z.literal("tool-result"),
		toolCallId: z.string(),
		toolName: z.string(),
		result: z.unknown(),
		content: toolResultContentSchema.optional(),
		isError: z.boolean().optional(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	coreSystemMessageSchema = z.object({
		role: z.literal("system"),
		content: z.string(),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	coreUserMessageSchema = z.object({
		role: z.literal("user"),
		content: z.union([
			z.string(),
			z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),
		]),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	coreAssistantMessageSchema = z.object({
		role: z.literal("assistant"),
		content: z.union([
			z.string(),
			z.array(
				z.union([
					textPartSchema,
					reasoningPartSchema,
					redactedReasoningPartSchema,
					toolCallPartSchema,
				]),
			),
		]),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	coreToolMessageSchema = z.object({
		role: z.literal("tool"),
		content: z.array(toolResultPartSchema),
		providerOptions: providerMetadataSchema.optional(),
		experimental_providerMetadata: providerMetadataSchema.optional(),
	}),
	coreMessageSchema = z.union([
		coreSystemMessageSchema,
		coreUserMessageSchema,
		coreAssistantMessageSchema,
		coreToolMessageSchema,
	]);
function standardizePrompt({ prompt, tools }) {
	if (prompt.prompt == null && prompt.messages == null)
		throw new InvalidPromptError({
			prompt,
			message: "prompt or messages must be defined",
		});
	if (prompt.prompt != null && prompt.messages != null)
		throw new InvalidPromptError({
			prompt,
			message: "prompt and messages cannot be defined at the same time",
		});
	if (prompt.system != null && typeof prompt.system !== "string")
		throw new InvalidPromptError({
			prompt,
			message: "system must be a string",
		});
	if (prompt.prompt != null) {
		if (typeof prompt.prompt !== "string")
			throw new InvalidPromptError({
				prompt,
				message: "prompt must be a string",
			});
		return {
			type: "prompt",
			system: prompt.system,
			messages: [{ role: "user", content: prompt.prompt }],
		};
	}
	if (prompt.messages != null) {
		let promptType = detectPromptType(prompt.messages);
		if (promptType === "other")
			throw new InvalidPromptError({
				prompt,
				message: "messages must be an array of CoreMessage or UIMessage",
			});
		let messages =
				promptType === "ui-messages"
					? convertToCoreMessages(prompt.messages, { tools })
					: prompt.messages,
			validationResult = safeValidateTypes({
				value: messages,
				schema: z.array(coreMessageSchema),
			});
		if (!validationResult.success)
			throw new InvalidPromptError({
				prompt,
				message: "messages must be an array of CoreMessage or UIMessage",
				cause: validationResult.error,
			});
		return { type: "messages", messages, system: prompt.system };
	}
	throw new Error("unreachable");
}
function calculateLanguageModelUsage({ promptTokens, completionTokens }) {
	return {
		promptTokens,
		completionTokens,
		totalTokens: promptTokens + completionTokens,
	};
}
function addLanguageModelUsage(usage1, usage2) {
	return {
		promptTokens: usage1.promptTokens + usage2.promptTokens,
		completionTokens: usage1.completionTokens + usage2.completionTokens,
		totalTokens: usage1.totalTokens + usage2.totalTokens,
	};
}
var DEFAULT_SCHEMA_PREFIX = "JSON schema:",
	DEFAULT_SCHEMA_SUFFIX =
		"You MUST answer with a JSON object that matches the JSON schema above.",
	DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
	prompt,
	schema,
	schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
	schemaSuffix = schema != null
		? DEFAULT_SCHEMA_SUFFIX
		: DEFAULT_GENERIC_SUFFIX,
}) {
	return [
		prompt != null && prompt.length > 0 ? prompt : void 0,
		prompt != null && prompt.length > 0 ? "" : void 0,
		schemaPrefix,
		schema != null ? JSON.stringify(schema) : void 0,
		schemaSuffix,
	]
		.filter((line) => line != null)
		.join(`
`);
}
var originalGenerateId = createIdGenerator({ prefix: "aiobj", size: 24 });
var originalGenerateId2 = createIdGenerator({ prefix: "aiobj", size: 24 });
var name92 = "AI_NoOutputSpecifiedError",
	marker92 = `vercel.ai.error.${name92}`,
	symbol92 = Symbol.for(marker92),
	_a92,
	NoOutputSpecifiedError = class extends AISDKError {
		constructor({ message = "No output specified." } = {}) {
			super({ name: name92, message });
			this[_a92] = !0;
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker92);
		}
	};
_a92 = symbol92;
var name102 = "AI_ToolExecutionError",
	marker102 = `vercel.ai.error.${name102}`,
	symbol102 = Symbol.for(marker102),
	_a102,
	ToolExecutionError = class extends AISDKError {
		constructor({
			toolArgs,
			toolName,
			toolCallId,
			cause,
			message = `Error executing tool ${toolName}: ${getErrorMessage(cause)}`,
		}) {
			super({ name: name102, message, cause });
			(this[_a102] = !0),
				(this.toolArgs = toolArgs),
				(this.toolName = toolName),
				(this.toolCallId = toolCallId);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker102);
		}
	};
_a102 = symbol102;
function isNonEmptyObject(object2) {
	return object2 != null && Object.keys(object2).length > 0;
}
function prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {
	if (!isNonEmptyObject(tools)) return { tools: void 0, toolChoice: void 0 };
	return {
		tools: (activeTools != null
			? Object.entries(tools).filter(([name17]) => activeTools.includes(name17))
			: Object.entries(tools)
		).map(([name17, tool2]) => {
			let toolType = tool2.type;
			switch (toolType) {
				case void 0:
				case "function":
					return {
						type: "function",
						name: name17,
						description: tool2.description,
						parameters: asSchema(tool2.parameters).jsonSchema,
					};
				case "provider-defined":
					return {
						type: "provider-defined",
						name: name17,
						id: tool2.id,
						args: tool2.args,
					};
				default:
					throw new Error(`Unsupported tool type: ${toolType}`);
			}
		}),
		toolChoice:
			toolChoice == null
				? { type: "auto" }
				: typeof toolChoice === "string"
					? { type: toolChoice }
					: { type: "tool", toolName: toolChoice.toolName },
	};
}
var lastWhitespaceRegexp = /^([\s\S]*?)(\s+)(\S*)$/;
function splitOnLastWhitespace(text2) {
	let match = text2.match(lastWhitespaceRegexp);
	return match
		? { prefix: match[1], whitespace: match[2], suffix: match[3] }
		: void 0;
}
function removeTextAfterLastWhitespace(text2) {
	let match = splitOnLastWhitespace(text2);
	return match ? match.prefix + match.whitespace : text2;
}
var name112 = "AI_InvalidToolArgumentsError",
	marker112 = `vercel.ai.error.${name112}`,
	symbol112 = Symbol.for(marker112),
	_a112,
	InvalidToolArgumentsError = class extends AISDKError {
		constructor({
			toolArgs,
			toolName,
			cause,
			message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(cause)}`,
		}) {
			super({ name: name112, message, cause });
			(this[_a112] = !0),
				(this.toolArgs = toolArgs),
				(this.toolName = toolName);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker112);
		}
	};
_a112 = symbol112;
var name122 = "AI_NoSuchToolError",
	marker122 = `vercel.ai.error.${name122}`,
	symbol122 = Symbol.for(marker122),
	_a122,
	NoSuchToolError = class extends AISDKError {
		constructor({
			toolName,
			availableTools = void 0,
			message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`,
		}) {
			super({ name: name122, message });
			(this[_a122] = !0),
				(this.toolName = toolName),
				(this.availableTools = availableTools);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker122);
		}
	};
_a122 = symbol122;
var name132 = "AI_ToolCallRepairError",
	marker132 = `vercel.ai.error.${name132}`,
	symbol132 = Symbol.for(marker132),
	_a132,
	ToolCallRepairError = class extends AISDKError {
		constructor({
			cause,
			originalError,
			message = `Error repairing tool call: ${getErrorMessage(cause)}`,
		}) {
			super({ name: name132, message, cause });
			(this[_a132] = !0), (this.originalError = originalError);
		}
		static isInstance(error2) {
			return AISDKError.hasMarker(error2, marker132);
		}
	};
_a132 = symbol132;
async function parseToolCall({
	toolCall,
	tools,
	repairToolCall,
	system,
	messages,
}) {
	if (tools == null) throw new NoSuchToolError({ toolName: toolCall.toolName });
	try {
		return await doParseToolCall({ toolCall, tools });
	} catch (error2) {
		if (
			repairToolCall == null ||
			!(
				NoSuchToolError.isInstance(error2) ||
				InvalidToolArgumentsError.isInstance(error2)
			)
		)
			throw error2;
		let repairedToolCall = null;
		try {
			repairedToolCall = await repairToolCall({
				toolCall,
				tools,
				parameterSchema: ({ toolName }) =>
					asSchema(tools[toolName].parameters).jsonSchema,
				system,
				messages,
				error: error2,
			});
		} catch (repairError) {
			throw new ToolCallRepairError({
				cause: repairError,
				originalError: error2,
			});
		}
		if (repairedToolCall == null) throw error2;
		return await doParseToolCall({ toolCall: repairedToolCall, tools });
	}
}
async function doParseToolCall({ toolCall, tools }) {
	let toolName = toolCall.toolName,
		tool2 = tools[toolName];
	if (tool2 == null)
		throw new NoSuchToolError({
			toolName: toolCall.toolName,
			availableTools: Object.keys(tools),
		});
	let schema = asSchema(tool2.parameters),
		parseResult =
			toolCall.args.trim() === ""
				? safeValidateTypes({ value: {}, schema })
				: safeParseJSON({ text: toolCall.args, schema });
	if (parseResult.success === !1)
		throw new InvalidToolArgumentsError({
			toolName,
			toolArgs: toolCall.args,
			cause: parseResult.error,
		});
	return {
		type: "tool-call",
		toolCallId: toolCall.toolCallId,
		toolName,
		args: parseResult.value,
	};
}
function asReasoningText(reasoning) {
	let reasoningText = reasoning
		.filter((part) => part.type === "text")
		.map((part) => part.text)
		.join("");
	return reasoningText.length > 0 ? reasoningText : void 0;
}
function toResponseMessages({
	text: text2 = "",
	reasoning,
	tools,
	toolCalls,
	toolResults,
	messageId,
	generateMessageId,
}) {
	let responseMessages = [];
	if (
		(responseMessages.push({
			role: "assistant",
			content: [
				...reasoning.map((part) =>
					part.type === "text"
						? { ...part, type: "reasoning" }
						: { ...part, type: "redacted-reasoning" },
				),
				{ type: "text", text: text2 },
				...toolCalls,
			],
			id: messageId,
		}),
		toolResults.length > 0)
	)
		responseMessages.push({
			role: "tool",
			id: generateMessageId(),
			content: toolResults.map((toolResult) => {
				let tool2 = tools[toolResult.toolName];
				return (tool2 == null
					? void 0
					: tool2.experimental_toToolResultContent) != null
					? {
							type: "tool-result",
							toolCallId: toolResult.toolCallId,
							toolName: toolResult.toolName,
							result: tool2.experimental_toToolResultContent(toolResult.result),
							experimental_content: tool2.experimental_toToolResultContent(
								toolResult.result,
							),
						}
					: {
							type: "tool-result",
							toolCallId: toolResult.toolCallId,
							toolName: toolResult.toolName,
							result: toolResult.result,
						};
			}),
		});
	return responseMessages;
}
var originalGenerateId3 = createIdGenerator({ prefix: "aitxt", size: 24 }),
	originalGenerateMessageId = createIdGenerator({ prefix: "msg", size: 24 });
async function generateText({
	model,
	tools,
	toolChoice,
	system,
	prompt,
	messages,
	maxRetries: maxRetriesArg,
	abortSignal,
	headers,
	maxSteps = 1,
	experimental_generateMessageId: generateMessageId = originalGenerateMessageId,
	experimental_output: output,
	experimental_continueSteps: continueSteps = !1,
	experimental_telemetry: telemetry,
	experimental_providerMetadata,
	providerOptions = experimental_providerMetadata,
	experimental_activeTools: activeTools,
	experimental_repairToolCall: repairToolCall,
	_internal: {
		generateId: generateId3 = originalGenerateId3,
		currentDate = () => new Date(),
	} = {},
	onStepFinish,
	...settings
}) {
	var _a17;
	if (maxSteps < 1)
		throw new InvalidArgumentError2({
			parameter: "maxSteps",
			value: maxSteps,
			message: "maxSteps must be at least 1",
		});
	let { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg }),
		baseTelemetryAttributes = getBaseTelemetryAttributes({
			model,
			telemetry,
			headers,
			settings: { ...settings, maxRetries },
		}),
		initialPrompt = standardizePrompt({
			prompt: {
				system:
					(_a17 =
						output == null
							? void 0
							: output.injectIntoSystemPrompt({ system, model })) != null
						? _a17
						: system,
				prompt,
				messages,
			},
			tools,
		}),
		tracer = getTracer(telemetry);
	return recordSpan({
		name: "ai.generateText",
		attributes: selectTelemetryAttributes({
			telemetry,
			attributes: {
				...assembleOperationName({ operationId: "ai.generateText", telemetry }),
				...baseTelemetryAttributes,
				"ai.prompt": {
					input: () => JSON.stringify({ system, prompt, messages }),
				},
				"ai.settings.maxSteps": maxSteps,
			},
		}),
		tracer,
		fn: async (span) => {
			var _a18, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
			let mode = {
					type: "regular",
					...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),
				},
				callSettings = prepareCallSettings(settings),
				currentModelResponse,
				currentToolCalls = [],
				currentToolResults = [],
				currentReasoningDetails = [],
				stepCount = 0,
				responseMessages = [],
				text2 = "",
				sources = [],
				steps = [],
				usage = { completionTokens: 0, promptTokens: 0, totalTokens: 0 },
				stepType = "initial";
			do {
				let promptFormat = stepCount === 0 ? initialPrompt.type : "messages",
					stepInputMessages = [...initialPrompt.messages, ...responseMessages],
					promptMessages = await convertToLanguageModelPrompt({
						prompt: {
							type: promptFormat,
							system: initialPrompt.system,
							messages: stepInputMessages,
						},
						modelSupportsImageUrls: model.supportsImageUrls,
						modelSupportsUrl:
							(_a18 = model.supportsUrl) == null ? void 0 : _a18.bind(model),
					});
				(currentModelResponse = await retry(() =>
					recordSpan({
						name: "ai.generateText.doGenerate",
						attributes: selectTelemetryAttributes({
							telemetry,
							attributes: {
								...assembleOperationName({
									operationId: "ai.generateText.doGenerate",
									telemetry,
								}),
								...baseTelemetryAttributes,
								"ai.prompt.format": { input: () => promptFormat },
								"ai.prompt.messages": {
									input: () => JSON.stringify(promptMessages),
								},
								"ai.prompt.tools": {
									input: () => {
										var _a19;
										return (_a19 = mode.tools) == null
											? void 0
											: _a19.map((tool2) => JSON.stringify(tool2));
									},
								},
								"ai.prompt.toolChoice": {
									input: () =>
										mode.toolChoice != null
											? JSON.stringify(mode.toolChoice)
											: void 0,
								},
								"gen_ai.system": model.provider,
								"gen_ai.request.model": model.modelId,
								"gen_ai.request.frequency_penalty": settings.frequencyPenalty,
								"gen_ai.request.max_tokens": settings.maxTokens,
								"gen_ai.request.presence_penalty": settings.presencePenalty,
								"gen_ai.request.stop_sequences": settings.stopSequences,
								"gen_ai.request.temperature": settings.temperature,
								"gen_ai.request.top_k": settings.topK,
								"gen_ai.request.top_p": settings.topP,
							},
						}),
						tracer,
						fn: async (span2) => {
							var _a19, _b2, _c2, _d2, _e2, _f2;
							let result = await model.doGenerate({
									mode,
									...callSettings,
									inputFormat: promptFormat,
									responseFormat:
										output == null ? void 0 : output.responseFormat({ model }),
									prompt: promptMessages,
									providerMetadata: providerOptions,
									abortSignal,
									headers,
								}),
								responseData = {
									id:
										(_b2 =
											(_a19 = result.response) == null ? void 0 : _a19.id) !=
										null
											? _b2
											: generateId3(),
									timestamp:
										(_d2 =
											(_c2 = result.response) == null
												? void 0
												: _c2.timestamp) != null
											? _d2
											: currentDate(),
									modelId:
										(_f2 =
											(_e2 = result.response) == null ? void 0 : _e2.modelId) !=
										null
											? _f2
											: model.modelId,
								};
							return (
								span2.setAttributes(
									selectTelemetryAttributes({
										telemetry,
										attributes: {
											"ai.response.finishReason": result.finishReason,
											"ai.response.text": { output: () => result.text },
											"ai.response.toolCalls": {
												output: () => JSON.stringify(result.toolCalls),
											},
											"ai.response.id": responseData.id,
											"ai.response.model": responseData.modelId,
											"ai.response.timestamp":
												responseData.timestamp.toISOString(),
											"ai.usage.promptTokens": result.usage.promptTokens,
											"ai.usage.completionTokens":
												result.usage.completionTokens,
											"gen_ai.response.finish_reasons": [result.finishReason],
											"gen_ai.response.id": responseData.id,
											"gen_ai.response.model": responseData.modelId,
											"gen_ai.usage.input_tokens": result.usage.promptTokens,
											"gen_ai.usage.output_tokens":
												result.usage.completionTokens,
										},
									}),
								),
								{ ...result, response: responseData }
							);
						},
					}),
				)),
					(currentToolCalls = await Promise.all(
						((_b = currentModelResponse.toolCalls) != null ? _b : []).map(
							(toolCall) =>
								parseToolCall({
									toolCall,
									tools,
									repairToolCall,
									system,
									messages: stepInputMessages,
								}),
						),
					)),
					(currentToolResults =
						tools == null
							? []
							: await executeTools({
									toolCalls: currentToolCalls,
									tools,
									tracer,
									telemetry,
									messages: stepInputMessages,
									abortSignal,
								}));
				let currentUsage = calculateLanguageModelUsage(
					currentModelResponse.usage,
				);
				usage = addLanguageModelUsage(usage, currentUsage);
				let nextStepType = "done";
				if (++stepCount < maxSteps) {
					if (
						continueSteps &&
						currentModelResponse.finishReason === "length" &&
						currentToolCalls.length === 0
					)
						nextStepType = "continue";
					else if (
						currentToolCalls.length > 0 &&
						currentToolResults.length === currentToolCalls.length
					)
						nextStepType = "tool-result";
				}
				let originalText = (_c = currentModelResponse.text) != null ? _c : "",
					stepTextLeadingWhitespaceTrimmed =
						stepType === "continue" && text2.trimEnd() !== text2
							? originalText.trimStart()
							: originalText,
					stepText =
						nextStepType === "continue"
							? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)
							: stepTextLeadingWhitespaceTrimmed;
				if (
					((text2 =
						nextStepType === "continue" || stepType === "continue"
							? text2 + stepText
							: stepText),
					(currentReasoningDetails = asReasoningDetails(
						currentModelResponse.reasoning,
					)),
					sources.push(
						...((_d = currentModelResponse.sources) != null ? _d : []),
					),
					stepType === "continue")
				) {
					let lastMessage = responseMessages[responseMessages.length - 1];
					if (typeof lastMessage.content === "string")
						lastMessage.content += stepText;
					else lastMessage.content.push({ text: stepText, type: "text" });
				} else
					responseMessages.push(
						...toResponseMessages({
							text: text2,
							reasoning: asReasoningDetails(currentModelResponse.reasoning),
							tools: tools != null ? tools : {},
							toolCalls: currentToolCalls,
							toolResults: currentToolResults,
							messageId: generateMessageId(),
							generateMessageId,
						}),
					);
				let currentStepResult = {
					stepType,
					text: stepText,
					reasoning: asReasoningText(currentReasoningDetails),
					reasoningDetails: currentReasoningDetails,
					sources: (_e = currentModelResponse.sources) != null ? _e : [],
					toolCalls: currentToolCalls,
					toolResults: currentToolResults,
					finishReason: currentModelResponse.finishReason,
					usage: currentUsage,
					warnings: currentModelResponse.warnings,
					logprobs: currentModelResponse.logprobs,
					request: (_f = currentModelResponse.request) != null ? _f : {},
					response: {
						...currentModelResponse.response,
						headers:
							(_g = currentModelResponse.rawResponse) == null
								? void 0
								: _g.headers,
						body:
							(_h = currentModelResponse.rawResponse) == null
								? void 0
								: _h.body,
						messages: structuredClone(responseMessages),
					},
					providerMetadata: currentModelResponse.providerMetadata,
					experimental_providerMetadata: currentModelResponse.providerMetadata,
					isContinued: nextStepType === "continue",
				};
				steps.push(currentStepResult),
					await (onStepFinish == null
						? void 0
						: onStepFinish(currentStepResult)),
					(stepType = nextStepType);
			} while (stepType !== "done");
			return (
				span.setAttributes(
					selectTelemetryAttributes({
						telemetry,
						attributes: {
							"ai.response.finishReason": currentModelResponse.finishReason,
							"ai.response.text": { output: () => currentModelResponse.text },
							"ai.response.toolCalls": {
								output: () => JSON.stringify(currentModelResponse.toolCalls),
							},
							"ai.usage.promptTokens": currentModelResponse.usage.promptTokens,
							"ai.usage.completionTokens":
								currentModelResponse.usage.completionTokens,
						},
					}),
				),
				new DefaultGenerateTextResult({
					text: text2,
					reasoning: asReasoningText(currentReasoningDetails),
					reasoningDetails: currentReasoningDetails,
					sources,
					outputResolver: () => {
						if (output == null) throw new NoOutputSpecifiedError();
						return output.parseOutput(
							{ text: text2 },
							{ response: currentModelResponse.response, usage },
						);
					},
					toolCalls: currentToolCalls,
					toolResults: currentToolResults,
					finishReason: currentModelResponse.finishReason,
					usage,
					warnings: currentModelResponse.warnings,
					request: (_i = currentModelResponse.request) != null ? _i : {},
					response: {
						...currentModelResponse.response,
						headers:
							(_j = currentModelResponse.rawResponse) == null
								? void 0
								: _j.headers,
						body:
							(_k = currentModelResponse.rawResponse) == null
								? void 0
								: _k.body,
						messages: responseMessages,
					},
					logprobs: currentModelResponse.logprobs,
					steps,
					providerMetadata: currentModelResponse.providerMetadata,
				})
			);
		},
	});
}
async function executeTools({
	toolCalls,
	tools,
	tracer,
	telemetry,
	messages,
	abortSignal,
}) {
	return (
		await Promise.all(
			toolCalls.map(async ({ toolCallId, toolName, args }) => {
				let tool2 = tools[toolName];
				if ((tool2 == null ? void 0 : tool2.execute) == null) return;
				let result = await recordSpan({
					name: "ai.toolCall",
					attributes: selectTelemetryAttributes({
						telemetry,
						attributes: {
							...assembleOperationName({
								operationId: "ai.toolCall",
								telemetry,
							}),
							"ai.toolCall.name": toolName,
							"ai.toolCall.id": toolCallId,
							"ai.toolCall.args": { output: () => JSON.stringify(args) },
						},
					}),
					tracer,
					fn: async (span) => {
						try {
							let result2 = await tool2.execute(args, {
								toolCallId,
								messages,
								abortSignal,
							});
							try {
								span.setAttributes(
									selectTelemetryAttributes({
										telemetry,
										attributes: {
											"ai.toolCall.result": {
												output: () => JSON.stringify(result2),
											},
										},
									}),
								);
							} catch (ignored) {}
							return result2;
						} catch (error2) {
							throw new ToolExecutionError({
								toolCallId,
								toolName,
								toolArgs: args,
								cause: error2,
							});
						}
					},
				});
				return { type: "tool-result", toolCallId, toolName, args, result };
			}),
		)
	).filter((result) => result != null);
}
var DefaultGenerateTextResult = class {
	constructor(options) {
		(this.text = options.text),
			(this.reasoning = options.reasoning),
			(this.reasoningDetails = options.reasoningDetails),
			(this.toolCalls = options.toolCalls),
			(this.toolResults = options.toolResults),
			(this.finishReason = options.finishReason),
			(this.usage = options.usage),
			(this.warnings = options.warnings),
			(this.request = options.request),
			(this.response = options.response),
			(this.steps = options.steps),
			(this.experimental_providerMetadata = options.providerMetadata),
			(this.providerMetadata = options.providerMetadata),
			(this.logprobs = options.logprobs),
			(this.outputResolver = options.outputResolver),
			(this.sources = options.sources);
	}
	get experimental_output() {
		return this.outputResolver();
	}
};
function asReasoningDetails(reasoning) {
	if (reasoning == null) return [];
	if (typeof reasoning === "string") return [{ type: "text", text: reasoning }];
	return reasoning;
}
var output_exports = {};
__export2(output_exports, { object: () => object2, text: () => text });
var name142 = "AI_InvalidStreamPartError",
	marker142 = `vercel.ai.error.${name142}`,
	symbol142 = Symbol.for(marker142),
	_a142;
_a142 = symbol142;
var name15 = "AI_MCPClientError",
	marker152 = `vercel.ai.error.${name15}`,
	symbol152 = Symbol.for(marker152),
	_a152;
_a152 = symbol152;
var text = () => ({
		type: "text",
		responseFormat: () => ({ type: "text" }),
		injectIntoSystemPrompt({ system }) {
			return system;
		},
		parsePartial({ text: text2 }) {
			return { partial: text2 };
		},
		parseOutput({ text: text2 }) {
			return text2;
		},
	}),
	object2 = ({ schema: inputSchema }) => {
		let schema = asSchema(inputSchema);
		return {
			type: "object",
			responseFormat: ({ model }) => ({
				type: "json",
				schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0,
			}),
			injectIntoSystemPrompt({ system, model }) {
				return model.supportsStructuredOutputs
					? system
					: injectJsonInstruction({
							prompt: system,
							schema: schema.jsonSchema,
						});
			},
			parsePartial({ text: text2 }) {
				let result = parsePartialJson(text2);
				switch (result.state) {
					case "failed-parse":
					case "undefined-input":
						return;
					case "repaired-parse":
					case "successful-parse":
						return { partial: result.value };
					default: {
						let _exhaustiveCheck = result.state;
						throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
					}
				}
			},
			parseOutput({ text: text2 }, context) {
				let parseResult = safeParseJSON({ text: text2 });
				if (!parseResult.success)
					throw new NoObjectGeneratedError({
						message: "No object generated: could not parse the response.",
						cause: parseResult.error,
						text: text2,
						response: context.response,
						usage: context.usage,
					});
				let validationResult = safeValidateTypes({
					value: parseResult.value,
					schema,
				});
				if (!validationResult.success)
					throw new NoObjectGeneratedError({
						message: "No object generated: response did not match schema.",
						cause: validationResult.error,
						text: text2,
						response: context.response,
						usage: context.usage,
					});
				return validationResult.value;
			},
		};
	};
function mergeStreams(stream1, stream2) {
	let reader1 = stream1.getReader(),
		reader2 = stream2.getReader(),
		lastRead1 = void 0,
		lastRead2 = void 0,
		stream1Done = !1,
		stream2Done = !1;
	async function readStream1(controller) {
		try {
			if (lastRead1 == null) lastRead1 = reader1.read();
			let result = await lastRead1;
			if (((lastRead1 = void 0), !result.done))
				controller.enqueue(result.value);
			else controller.close();
		} catch (error2) {
			controller.error(error2);
		}
	}
	async function readStream2(controller) {
		try {
			if (lastRead2 == null) lastRead2 = reader2.read();
			let result = await lastRead2;
			if (((lastRead2 = void 0), !result.done))
				controller.enqueue(result.value);
			else controller.close();
		} catch (error2) {
			controller.error(error2);
		}
	}
	return new ReadableStream({
		async pull(controller) {
			try {
				if (stream1Done) {
					await readStream2(controller);
					return;
				}
				if (stream2Done) {
					await readStream1(controller);
					return;
				}
				if (lastRead1 == null) lastRead1 = reader1.read();
				if (lastRead2 == null) lastRead2 = reader2.read();
				let { result, reader } = await Promise.race([
					lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
					lastRead2.then((result2) => ({ result: result2, reader: reader2 })),
				]);
				if (!result.done) controller.enqueue(result.value);
				if (reader === reader1) {
					if (((lastRead1 = void 0), result.done))
						await readStream2(controller), (stream1Done = !0);
				} else if (((lastRead2 = void 0), result.done))
					(stream2Done = !0), await readStream1(controller);
			} catch (error2) {
				controller.error(error2);
			}
		},
		cancel() {
			reader1.cancel(), reader2.cancel();
		},
	});
}
var originalGenerateId4 = createIdGenerator({ prefix: "aitxt", size: 24 }),
	originalGenerateMessageId2 = createIdGenerator({ prefix: "msg", size: 24 });
var name16 = "AI_NoSuchProviderError",
	marker16 = `vercel.ai.error.${name16}`,
	symbol16 = Symbol.for(marker16),
	_a16;
_a16 = symbol16;
var JSONRPC_VERSION = "2.0",
	ClientOrServerImplementationSchema = z
		.object({ name: z.string(), version: z.string() })
		.passthrough(),
	BaseParamsSchema = z
		.object({ _meta: z.optional(z.object({}).passthrough()) })
		.passthrough(),
	RequestSchema = z.object({
		method: z.string(),
		params: z.optional(BaseParamsSchema),
	}),
	ResultSchema = BaseParamsSchema,
	NotificationSchema = z.object({
		method: z.string(),
		params: z.optional(BaseParamsSchema),
	}),
	RequestIdSchema = z.union([z.string(), z.number().int()]),
	JSONRPCRequestSchema = z
		.object({ jsonrpc: z.literal(JSONRPC_VERSION), id: RequestIdSchema })
		.merge(RequestSchema)
		.strict(),
	JSONRPCResponseSchema = z
		.object({
			jsonrpc: z.literal(JSONRPC_VERSION),
			id: RequestIdSchema,
			result: ResultSchema,
		})
		.strict(),
	JSONRPCErrorSchema = z
		.object({
			jsonrpc: z.literal(JSONRPC_VERSION),
			id: RequestIdSchema,
			error: z.object({
				code: z.number().int(),
				message: z.string(),
				data: z.optional(z.unknown()),
			}),
		})
		.strict(),
	JSONRPCNotificationSchema = z
		.object({ jsonrpc: z.literal(JSONRPC_VERSION) })
		.merge(NotificationSchema)
		.strict(),
	JSONRPCMessageSchema = z.union([
		JSONRPCRequestSchema,
		JSONRPCNotificationSchema,
		JSONRPCResponseSchema,
		JSONRPCErrorSchema,
	]),
	ServerCapabilitiesSchema = z
		.object({
			experimental: z.optional(z.object({}).passthrough()),
			logging: z.optional(z.object({}).passthrough()),
			prompts: z.optional(
				z.object({ listChanged: z.optional(z.boolean()) }).passthrough(),
			),
			resources: z.optional(
				z
					.object({
						subscribe: z.optional(z.boolean()),
						listChanged: z.optional(z.boolean()),
					})
					.passthrough(),
			),
			tools: z.optional(
				z.object({ listChanged: z.optional(z.boolean()) }).passthrough(),
			),
		})
		.passthrough(),
	InitializeResultSchema = ResultSchema.extend({
		protocolVersion: z.string(),
		capabilities: ServerCapabilitiesSchema,
		serverInfo: ClientOrServerImplementationSchema,
		instructions: z.optional(z.string()),
	}),
	PaginatedResultSchema = ResultSchema.extend({
		nextCursor: z.optional(z.string()),
	}),
	ToolSchema = z
		.object({
			name: z.string(),
			description: z.optional(z.string()),
			inputSchema: z
				.object({
					type: z.literal("object"),
					properties: z.optional(z.object({}).passthrough()),
				})
				.passthrough(),
		})
		.passthrough(),
	ListToolsResultSchema = PaginatedResultSchema.extend({
		tools: z.array(ToolSchema),
	}),
	TextContentSchema = z
		.object({ type: z.literal("text"), text: z.string() })
		.passthrough(),
	ImageContentSchema = z
		.object({
			type: z.literal("image"),
			data: z.string().base64(),
			mimeType: z.string(),
		})
		.passthrough(),
	ResourceContentsSchema = z
		.object({ uri: z.string(), mimeType: z.optional(z.string()) })
		.passthrough(),
	TextResourceContentsSchema = ResourceContentsSchema.extend({
		text: z.string(),
	}),
	BlobResourceContentsSchema = ResourceContentsSchema.extend({
		blob: z.string().base64(),
	}),
	EmbeddedResourceSchema = z
		.object({
			type: z.literal("resource"),
			resource: z.union([
				TextResourceContentsSchema,
				BlobResourceContentsSchema,
			]),
		})
		.passthrough(),
	CallToolResultSchema = ResultSchema.extend({
		content: z.array(
			z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),
		),
		isError: z.boolean().default(!1).optional(),
	}).or(ResultSchema.extend({ toolResult: z.unknown() }));
var langchain_adapter_exports = {};
__export2(langchain_adapter_exports, {
	mergeIntoDataStream: () => mergeIntoDataStream,
	toDataStream: () => toDataStream,
	toDataStreamResponse: () => toDataStreamResponse,
});
function createCallbacksTransformer(callbacks = {}) {
	let textEncoder = new TextEncoder(),
		aggregatedResponse = "";
	return new TransformStream({
		async start() {
			if (callbacks.onStart) await callbacks.onStart();
		},
		async transform(message, controller) {
			if (
				(controller.enqueue(textEncoder.encode(message)),
				(aggregatedResponse += message),
				callbacks.onToken)
			)
				await callbacks.onToken(message);
			if (callbacks.onText && typeof message === "string")
				await callbacks.onText(message);
		},
		async flush() {
			if (callbacks.onCompletion)
				await callbacks.onCompletion(aggregatedResponse);
			if (callbacks.onFinal) await callbacks.onFinal(aggregatedResponse);
		},
	});
}
function toDataStreamInternal(stream, callbacks) {
	return stream
		.pipeThrough(
			new TransformStream({
				transform: async (value, controller) => {
					var _a17;
					if (typeof value === "string") {
						controller.enqueue(value);
						return;
					}
					if ("event" in value) {
						if (value.event === "on_chat_model_stream")
							forwardAIMessageChunk(
								(_a17 = value.data) == null ? void 0 : _a17.chunk,
								controller,
							);
						return;
					}
					forwardAIMessageChunk(value, controller);
				},
			}),
		)
		.pipeThrough(createCallbacksTransformer(callbacks))
		.pipeThrough(new TextDecoderStream())
		.pipeThrough(
			new TransformStream({
				transform: async (chunk, controller) => {
					controller.enqueue(formatDataStreamPart("text", chunk));
				},
			}),
		);
}
function toDataStream(stream, callbacks) {
	return toDataStreamInternal(stream, callbacks).pipeThrough(
		new TextEncoderStream(),
	);
}
function toDataStreamResponse(stream, options) {
	var _a17;
	let dataStream = toDataStreamInternal(
			stream,
			options == null ? void 0 : options.callbacks,
		).pipeThrough(new TextEncoderStream()),
		data = options == null ? void 0 : options.data,
		init = options == null ? void 0 : options.init,
		responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
	return new Response(responseStream, {
		status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
		statusText: init == null ? void 0 : init.statusText,
		headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
			contentType: "text/plain; charset=utf-8",
			dataStreamVersion: "v1",
		}),
	});
}
function mergeIntoDataStream(stream, options) {
	options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
function forwardAIMessageChunk(chunk, controller) {
	if (typeof chunk.content === "string") controller.enqueue(chunk.content);
	else {
		let content = chunk.content;
		for (let item of content)
			if (item.type === "text") controller.enqueue(item.text);
	}
}
var llamaindex_adapter_exports = {};
__export2(llamaindex_adapter_exports, {
	mergeIntoDataStream: () => mergeIntoDataStream2,
	toDataStream: () => toDataStream2,
	toDataStreamResponse: () => toDataStreamResponse2,
});
function toDataStreamInternal2(stream, callbacks) {
	let trimStart = trimStartOfStream();
	return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())
		.pipeThrough(
			new TransformStream({
				async transform(message, controller) {
					controller.enqueue(trimStart(message.delta));
				},
			}),
		)
		.pipeThrough(createCallbacksTransformer(callbacks))
		.pipeThrough(new TextDecoderStream())
		.pipeThrough(
			new TransformStream({
				transform: async (chunk, controller) => {
					controller.enqueue(formatDataStreamPart("text", chunk));
				},
			}),
		);
}
function toDataStream2(stream, callbacks) {
	return toDataStreamInternal2(stream, callbacks).pipeThrough(
		new TextEncoderStream(),
	);
}
function toDataStreamResponse2(stream, options = {}) {
	var _a17;
	let { init, data, callbacks } = options,
		dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(
			new TextEncoderStream(),
		),
		responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
	return new Response(responseStream, {
		status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
		statusText: init == null ? void 0 : init.statusText,
		headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
			contentType: "text/plain; charset=utf-8",
			dataStreamVersion: "v1",
		}),
	});
}
function mergeIntoDataStream2(stream, options) {
	options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
function trimStartOfStream() {
	let isStreamStart = !0;
	return (text2) => {
		if (isStreamStart) {
			if (((text2 = text2.trimStart()), text2)) isStreamStart = !1;
		}
		return text2;
	};
}
var groq2 = createGroq({ apiKey: process.env.GROQ_API_KEY }),
	DEFAULT_MODEL = async () => {
		return (await flagsmith_default.getEnvironmentFlags()).getFeatureValue(
			"ai_model_name",
		);
	},
	generateText2 = async (params) => {
		return await generateText({
			model: groq2(`${await DEFAULT_MODEL()}` || "llama3-70b-8192"),
			...params,
		});
	};
import { Database } from "bun:sqlite";
var db = new Database("./tempsql");
db.exec(`
    CREATE TABLE IF NOT EXISTS pr_comments (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      owner TEXT NOT NULL,
      repo TEXT NOT NULL,
      pull INTEGER NOT NULL,
      filename TEXT NOT NULL,
      comment TEXT NOT NULL,
      meta JSON NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);
var db_default = db;
function getUserAgent() {
	if (typeof navigator === "object" && "userAgent" in navigator)
		return navigator.userAgent;
	if (typeof process === "object" && process.version !== void 0)
		return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
	return "<environment undetectable>";
}
function register(state, name17, method, options) {
	if (typeof method !== "function")
		throw new Error("method for before hook must be a function");
	if (!options) options = {};
	if (Array.isArray(name17))
		return name17.reverse().reduce((callback, name18) => {
			return register.bind(null, state, name18, callback, options);
		}, method)();
	return Promise.resolve().then(() => {
		if (!state.registry[name17]) return method(options);
		return state.registry[name17].reduce((method2, registered) => {
			return registered.hook.bind(null, method2, options);
		}, method)();
	});
}
function addHook(state, kind, name17, hook) {
	let orig = hook;
	if (!state.registry[name17]) state.registry[name17] = [];
	if (kind === "before")
		hook = (method, options) => {
			return Promise.resolve()
				.then(orig.bind(null, options))
				.then(method.bind(null, options));
		};
	if (kind === "after")
		hook = (method, options) => {
			let result;
			return Promise.resolve()
				.then(method.bind(null, options))
				.then((result_) => {
					return (result = result_), orig(result, options);
				})
				.then(() => {
					return result;
				});
		};
	if (kind === "error")
		hook = (method, options) => {
			return Promise.resolve()
				.then(method.bind(null, options))
				.catch((error2) => {
					return orig(error2, options);
				});
		};
	state.registry[name17].push({ hook, orig });
}
function removeHook(state, name17, method) {
	if (!state.registry[name17]) return;
	let index = state.registry[name17]
		.map((registered) => {
			return registered.orig;
		})
		.indexOf(method);
	if (index === -1) return;
	state.registry[name17].splice(index, 1);
}
var bind = Function.bind,
	bindable = bind.bind(bind);
function bindApi(hook, state, name17) {
	let removeHookRef = bindable(removeHook, null).apply(
		null,
		name17 ? [state, name17] : [state],
	);
	(hook.api = { remove: removeHookRef }),
		(hook.remove = removeHookRef),
		["before", "error", "after", "wrap"].forEach((kind) => {
			let args = name17 ? [state, kind, name17] : [state, kind];
			hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
		});
}
function Singular() {
	let singularHookName = Symbol("Singular"),
		singularHookState = { registry: {} },
		singularHook = register.bind(null, singularHookState, singularHookName);
	return (
		bindApi(singularHook, singularHookState, singularHookName), singularHook
	);
}
function Collection() {
	let state = { registry: {} },
		hook = register.bind(null, state);
	return bindApi(hook, state), hook;
}
var before_after_hook_default = { Singular, Collection };
var VERSION = "0.0.0-development",
	userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`,
	DEFAULTS = {
		method: "GET",
		baseUrl: "https://api.github.com",
		headers: {
			accept: "application/vnd.github.v3+json",
			"user-agent": userAgent,
		},
		mediaType: { format: "" },
	};
function lowercaseKeys(object3) {
	if (!object3) return {};
	return Object.keys(object3).reduce((newObj, key) => {
		return (newObj[key.toLowerCase()] = object3[key]), newObj;
	}, {});
}
function isPlainObject(value) {
	if (typeof value !== "object" || value === null) return !1;
	if (Object.prototype.toString.call(value) !== "[object Object]") return !1;
	let proto = Object.getPrototypeOf(value);
	if (proto === null) return !0;
	let Ctor =
		Object.prototype.hasOwnProperty.call(proto, "constructor") &&
		proto.constructor;
	return (
		typeof Ctor === "function" &&
		Ctor instanceof Ctor &&
		Function.prototype.call(Ctor) === Function.prototype.call(value)
	);
}
function mergeDeep2(defaults, options) {
	let result = Object.assign({}, defaults);
	return (
		Object.keys(options).forEach((key) => {
			if (isPlainObject(options[key]))
				if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
				else result[key] = mergeDeep2(defaults[key], options[key]);
			else Object.assign(result, { [key]: options[key] });
		}),
		result
	);
}
function removeUndefinedProperties(obj) {
	for (let key in obj) if (obj[key] === void 0) delete obj[key];
	return obj;
}
function merge(defaults, route, options) {
	if (typeof route === "string") {
		let [method, url] = route.split(" ");
		options = Object.assign(url ? { method, url } : { url: method }, options);
	} else options = Object.assign({}, route);
	(options.headers = lowercaseKeys(options.headers)),
		removeUndefinedProperties(options),
		removeUndefinedProperties(options.headers);
	let mergedOptions = mergeDeep2(defaults || {}, options);
	if (options.url === "/graphql") {
		if (defaults && defaults.mediaType.previews?.length)
			mergedOptions.mediaType.previews = defaults.mediaType.previews
				.filter(
					(preview) => !mergedOptions.mediaType.previews.includes(preview),
				)
				.concat(mergedOptions.mediaType.previews);
		mergedOptions.mediaType.previews = (
			mergedOptions.mediaType.previews || []
		).map((preview) => preview.replace(/-preview/, ""));
	}
	return mergedOptions;
}
function addQueryParameters(url, parameters) {
	let separator = /\?/.test(url) ? "&" : "?",
		names = Object.keys(parameters);
	if (names.length === 0) return url;
	return (
		url +
		separator +
		names
			.map((name17) => {
				if (name17 === "q")
					return (
						"q=" + parameters.q.split("+").map(encodeURIComponent).join("+")
					);
				return `${name17}=${encodeURIComponent(parameters[name17])}`;
			})
			.join("&")
	);
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
	return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
	let matches = url.match(urlVariableRegex);
	if (!matches) return [];
	return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object3, keysToOmit) {
	let result = { __proto__: null };
	for (let key of Object.keys(object3))
		if (keysToOmit.indexOf(key) === -1) result[key] = object3[key];
	return result;
}
function encodeReserved(str) {
	return str
		.split(/(%[0-9A-Fa-f]{2})/g)
		.map(function (part) {
			if (!/%[0-9A-Fa-f]/.test(part))
				part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
			return part;
		})
		.join("");
}
function encodeUnreserved(str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return "%" + c.charCodeAt(0).toString(16).toUpperCase();
	});
}
function encodeValue(operator, value, key) {
	if (
		((value =
			operator === "+" || operator === "#"
				? encodeReserved(value)
				: encodeUnreserved(value)),
		key)
	)
		return encodeUnreserved(key) + "=" + value;
	else return value;
}
function isDefined(value) {
	return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
	return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
	var value = context[key],
		result = [];
	if (isDefined(value) && value !== "")
		if (
			typeof value === "string" ||
			typeof value === "number" ||
			typeof value === "boolean"
		) {
			if (((value = value.toString()), modifier && modifier !== "*"))
				value = value.substring(0, parseInt(modifier, 10));
			result.push(
				encodeValue(operator, value, isKeyOperator(operator) ? key : ""),
			);
		} else if (modifier === "*")
			if (Array.isArray(value))
				value.filter(isDefined).forEach(function (value2) {
					result.push(
						encodeValue(operator, value2, isKeyOperator(operator) ? key : ""),
					);
				});
			else
				Object.keys(value).forEach(function (k) {
					if (isDefined(value[k]))
						result.push(encodeValue(operator, value[k], k));
				});
		else {
			let tmp = [];
			if (Array.isArray(value))
				value.filter(isDefined).forEach(function (value2) {
					tmp.push(encodeValue(operator, value2));
				});
			else
				Object.keys(value).forEach(function (k) {
					if (isDefined(value[k]))
						tmp.push(encodeUnreserved(k)),
							tmp.push(encodeValue(operator, value[k].toString()));
				});
			if (isKeyOperator(operator))
				result.push(encodeUnreserved(key) + "=" + tmp.join(","));
			else if (tmp.length !== 0) result.push(tmp.join(","));
		}
	else if (operator === ";") {
		if (isDefined(value)) result.push(encodeUnreserved(key));
	} else if (value === "" && (operator === "&" || operator === "?"))
		result.push(encodeUnreserved(key) + "=");
	else if (value === "") result.push("");
	return result;
}
function parseUrl(template) {
	return { expand: expand.bind(null, template) };
}
function expand(template, context) {
	var operators = ["+", "#", ".", "/", ";", "?", "&"];
	if (
		((template = template.replace(
			/\{([^\{\}]+)\}|([^\{\}]+)/g,
			function (_, expression, literal2) {
				if (expression) {
					let operator = "",
						values = [];
					if (operators.indexOf(expression.charAt(0)) !== -1)
						(operator = expression.charAt(0)),
							(expression = expression.substr(1));
					if (
						(expression.split(/,/g).forEach(function (variable) {
							var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
							values.push(
								getValues(context, operator, tmp[1], tmp[2] || tmp[3]),
							);
						}),
						operator && operator !== "+")
					) {
						var separator = ",";
						if (operator === "?") separator = "&";
						else if (operator !== "#") separator = operator;
						return (
							(values.length !== 0 ? operator : "") + values.join(separator)
						);
					} else return values.join(",");
				} else return encodeReserved(literal2);
			},
		)),
		template === "/")
	)
		return template;
	else return template.replace(/\/$/, "");
}
function parse3(options) {
	let method = options.method.toUpperCase(),
		url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}"),
		headers = Object.assign({}, options.headers),
		body,
		parameters = omit(options, [
			"method",
			"baseUrl",
			"url",
			"headers",
			"request",
			"mediaType",
		]),
		urlVariableNames = extractUrlVariableNames(url);
	if (((url = parseUrl(url).expand(parameters)), !/^http/.test(url)))
		url = options.baseUrl + url;
	let omittedParameters = Object.keys(options)
			.filter((option) => urlVariableNames.includes(option))
			.concat("baseUrl"),
		remainingParameters = omit(parameters, omittedParameters);
	if (!/application\/octet-stream/i.test(headers.accept)) {
		if (options.mediaType.format)
			headers.accept = headers.accept
				.split(/,/)
				.map((format) =>
					format.replace(
						/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
						`application/vnd$1$2.${options.mediaType.format}`,
					),
				)
				.join(",");
		if (url.endsWith("/graphql")) {
			if (options.mediaType.previews?.length) {
				let previewsFromAcceptHeader =
					headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
				headers.accept = previewsFromAcceptHeader
					.concat(options.mediaType.previews)
					.map((preview) => {
						let format = options.mediaType.format
							? `.${options.mediaType.format}`
							: "+json";
						return `application/vnd.github.${preview}-preview${format}`;
					})
					.join(",");
			}
		}
	}
	if (["GET", "HEAD"].includes(method))
		url = addQueryParameters(url, remainingParameters);
	else if ("data" in remainingParameters) body = remainingParameters.data;
	else if (Object.keys(remainingParameters).length) body = remainingParameters;
	if (!headers["content-type"] && typeof body !== "undefined")
		headers["content-type"] = "application/json; charset=utf-8";
	if (["PATCH", "PUT"].includes(method) && typeof body === "undefined")
		body = "";
	return Object.assign(
		{ method, url, headers },
		typeof body !== "undefined" ? { body } : null,
		options.request ? { request: options.request } : null,
	);
}
function endpointWithDefaults(defaults, route, options) {
	return parse3(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
	let DEFAULTS2 = merge(oldDefaults, newDefaults),
		endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
	return Object.assign(endpoint2, {
		DEFAULTS: DEFAULTS2,
		defaults: withDefaults.bind(null, DEFAULTS2),
		merge: merge.bind(null, DEFAULTS2),
		parse: parse3,
	});
}
var endpoint = withDefaults(null, DEFAULTS);
var NullObject = function NullObject2() {};
NullObject.prototype = Object.create(null);
var paramRE =
		/; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu,
	quotedPairRE = /\\([\v\u0020-\u00ff])/gu,
	mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u,
	defaultContentType = { type: "", parameters: new NullObject() };
Object.freeze(defaultContentType.parameters);
Object.freeze(defaultContentType);
function safeParse(header) {
	if (typeof header !== "string") return defaultContentType;
	let index = header.indexOf(";"),
		type2 = index !== -1 ? header.slice(0, index).trim() : header.trim();
	if (mediaTypeRE.test(type2) === !1) return defaultContentType;
	let result = { type: type2.toLowerCase(), parameters: new NullObject() };
	if (index === -1) return result;
	let key, match, value;
	paramRE.lastIndex = index;
	while ((match = paramRE.exec(header))) {
		if (match.index !== index) return defaultContentType;
		if (
			((index += match[0].length),
			(key = match[1].toLowerCase()),
			(value = match[2]),
			value[0] === '"')
		)
			(value = value.slice(1, value.length - 1)),
				quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
		result.parameters[key] = value;
	}
	if (index !== header.length) return defaultContentType;
	return result;
}
var $safeParse = safeParse;
class RequestError extends Error {
	name;
	status;
	request;
	response;
	constructor(message, statusCode, options) {
		super(message);
		if (
			((this.name = "HttpError"),
			(this.status = Number.parseInt(statusCode)),
			Number.isNaN(this.status))
		)
			this.status = 0;
		if ("response" in options) this.response = options.response;
		let requestCopy = Object.assign({}, options.request);
		if (options.request.headers.authorization)
			requestCopy.headers = Object.assign({}, options.request.headers, {
				authorization: options.request.headers.authorization.replace(
					/(?<! ) .*$/,
					" [REDACTED]",
				),
			});
		(requestCopy.url = requestCopy.url
			.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
			.replace(/\baccess_token=\w+/g, "access_token=[REDACTED]")),
			(this.request = requestCopy);
	}
}
var VERSION2 = "0.0.0-development",
	defaults_default = {
		headers: {
			"user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`,
		},
	};
function isPlainObject2(value) {
	if (typeof value !== "object" || value === null) return !1;
	if (Object.prototype.toString.call(value) !== "[object Object]") return !1;
	let proto = Object.getPrototypeOf(value);
	if (proto === null) return !0;
	let Ctor =
		Object.prototype.hasOwnProperty.call(proto, "constructor") &&
		proto.constructor;
	return (
		typeof Ctor === "function" &&
		Ctor instanceof Ctor &&
		Function.prototype.call(Ctor) === Function.prototype.call(value)
	);
}
async function fetchWrapper(requestOptions) {
	let fetch2 = requestOptions.request?.fetch || globalThis.fetch;
	if (!fetch2)
		throw new Error(
			"fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing",
		);
	let log = requestOptions.request?.log || console,
		parseSuccessResponseBody =
			requestOptions.request?.parseSuccessResponseBody !== !1,
		body =
			isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)
				? JSON.stringify(requestOptions.body)
				: requestOptions.body,
		requestHeaders = Object.fromEntries(
			Object.entries(requestOptions.headers).map(([name17, value]) => [
				name17,
				String(value),
			]),
		),
		fetchResponse;
	try {
		fetchResponse = await fetch2(requestOptions.url, {
			method: requestOptions.method,
			body,
			redirect: requestOptions.request?.redirect,
			headers: requestHeaders,
			signal: requestOptions.request?.signal,
			...(requestOptions.body && { duplex: "half" }),
		});
	} catch (error2) {
		let message = "Unknown Error";
		if (error2 instanceof Error) {
			if (error2.name === "AbortError") throw ((error2.status = 500), error2);
			if (
				((message = error2.message),
				error2.name === "TypeError" && "cause" in error2)
			) {
				if (error2.cause instanceof Error) message = error2.cause.message;
				else if (typeof error2.cause === "string") message = error2.cause;
			}
		}
		let requestError = new RequestError(message, 500, {
			request: requestOptions,
		});
		throw ((requestError.cause = error2), requestError);
	}
	let { status, url } = fetchResponse,
		responseHeaders = {};
	for (let [key, value] of fetchResponse.headers) responseHeaders[key] = value;
	let octokitResponse = { url, status, headers: responseHeaders, data: "" };
	if ("deprecation" in responseHeaders) {
		let matches =
				responseHeaders.link &&
				responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/),
			deprecationLink = matches && matches.pop();
		log.warn(
			`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`,
		);
	}
	if (status === 204 || status === 205) return octokitResponse;
	if (requestOptions.method === "HEAD") {
		if (status < 400) return octokitResponse;
		throw new RequestError(fetchResponse.statusText, status, {
			response: octokitResponse,
			request: requestOptions,
		});
	}
	if (status === 304)
		throw (
			((octokitResponse.data = await getResponseData(fetchResponse)),
			new RequestError("Not modified", status, {
				response: octokitResponse,
				request: requestOptions,
			}))
		);
	if (status >= 400)
		throw (
			((octokitResponse.data = await getResponseData(fetchResponse)),
			new RequestError(toErrorMessage(octokitResponse.data), status, {
				response: octokitResponse,
				request: requestOptions,
			}))
		);
	return (
		(octokitResponse.data = parseSuccessResponseBody
			? await getResponseData(fetchResponse)
			: fetchResponse.body),
		octokitResponse
	);
}
async function getResponseData(response) {
	let contentType = response.headers.get("content-type");
	if (!contentType) return response.text().catch(() => "");
	let mimetype = $safeParse(contentType);
	if (isJSONResponse(mimetype)) {
		let text2 = "";
		try {
			return (text2 = await response.text()), JSON.parse(text2);
		} catch (err) {
			return text2;
		}
	} else if (
		mimetype.type.startsWith("text/") ||
		mimetype.parameters.charset?.toLowerCase() === "utf-8"
	)
		return response.text().catch(() => "");
	else return response.arrayBuffer().catch(() => new ArrayBuffer(0));
}
function isJSONResponse(mimetype) {
	return (
		mimetype.type === "application/json" ||
		mimetype.type === "application/scim+json"
	);
}
function toErrorMessage(data) {
	if (typeof data === "string") return data;
	if (data instanceof ArrayBuffer) return "Unknown error";
	if ("message" in data) {
		let suffix =
			"documentation_url" in data ? ` - ${data.documentation_url}` : "";
		return Array.isArray(data.errors)
			? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}`
			: `${data.message}${suffix}`;
	}
	return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
	let endpoint2 = oldEndpoint.defaults(newDefaults);
	return Object.assign(
		function (route, parameters) {
			let endpointOptions = endpoint2.merge(route, parameters);
			if (!endpointOptions.request || !endpointOptions.request.hook)
				return fetchWrapper(endpoint2.parse(endpointOptions));
			let request2 = (route2, parameters2) => {
				return fetchWrapper(
					endpoint2.parse(endpoint2.merge(route2, parameters2)),
				);
			};
			return (
				Object.assign(request2, {
					endpoint: endpoint2,
					defaults: withDefaults2.bind(null, endpoint2),
				}),
				endpointOptions.request.hook(request2, endpointOptions)
			);
		},
		{ endpoint: endpoint2, defaults: withDefaults2.bind(null, endpoint2) },
	);
}
var request = withDefaults2(endpoint, defaults_default);
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
	return (
		`Request failed due to following response errors:
` +
		data.errors
			.map((e) => ` - ${e.message}`)
			.join(`
`)
	);
}
var GraphqlResponseError = class extends Error {
		constructor(request2, headers, response) {
			super(_buildMessageForResponseErrors(response));
			if (
				((this.request = request2),
				(this.headers = headers),
				(this.response = response),
				(this.errors = response.errors),
				(this.data = response.data),
				Error.captureStackTrace)
			)
				Error.captureStackTrace(this, this.constructor);
		}
		name = "GraphqlResponseError";
		errors;
		data;
	},
	NON_VARIABLE_OPTIONS = [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"query",
		"mediaType",
		"operationName",
	],
	FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"],
	GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
	if (options) {
		if (typeof query === "string" && "query" in options)
			return Promise.reject(
				new Error('[@octokit/graphql] "query" cannot be used as variable name'),
			);
		for (let key in options) {
			if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
			return Promise.reject(
				new Error(
					`[@octokit/graphql] "${key}" cannot be used as variable name`,
				),
			);
		}
	}
	let parsedOptions =
			typeof query === "string" ? Object.assign({ query }, options) : query,
		requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
			if (NON_VARIABLE_OPTIONS.includes(key))
				return (result[key] = parsedOptions[key]), result;
			if (!result.variables) result.variables = {};
			return (result.variables[key] = parsedOptions[key]), result;
		}, {}),
		baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
	if (GHES_V3_SUFFIX_REGEX.test(baseUrl))
		requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
	return request2(requestOptions).then((response) => {
		if (response.data.errors) {
			let headers = {};
			for (let key of Object.keys(response.headers))
				headers[key] = response.headers[key];
			throw new GraphqlResponseError(requestOptions, headers, response.data);
		}
		return response.data.data;
	});
}
function withDefaults3(request2, newDefaults) {
	let newRequest = request2.defaults(newDefaults);
	return Object.assign(
		(query, options) => {
			return graphql(newRequest, query, options);
		},
		{
			defaults: withDefaults3.bind(null, newRequest),
			endpoint: newRequest.endpoint,
		},
	);
}
var graphql2 = withDefaults3(request, {
	headers: { "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}` },
	method: "POST",
	url: "/graphql",
});
function withCustomRequest(customRequest) {
	return withDefaults3(customRequest, { method: "POST", url: "/graphql" });
}
var b64url = "(?:[a-zA-Z0-9_-]+)",
	sep = "\\.",
	jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`),
	isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
	let isApp = isJWT(token),
		isInstallation = token.startsWith("v1.") || token.startsWith("ghs_"),
		isUserToServer = token.startsWith("ghu_");
	return {
		type: "token",
		token,
		tokenType: isApp
			? "app"
			: isInstallation
				? "installation"
				: isUserToServer
					? "user-to-server"
					: "oauth",
	};
}
function withAuthorizationPrefix(token) {
	if (token.split(/\./).length === 3) return `bearer ${token}`;
	return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
	let endpoint2 = request2.endpoint.merge(route, parameters);
	return (
		(endpoint2.headers.authorization = withAuthorizationPrefix(token)),
		request2(endpoint2)
	);
}
var createTokenAuth = function createTokenAuth2(token) {
	if (!token)
		throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
	if (typeof token !== "string")
		throw new Error(
			"[@octokit/auth-token] Token passed to createTokenAuth is not a string",
		);
	return (
		(token = token.replace(/^(token|bearer) +/i, "")),
		Object.assign(auth.bind(null, token), { hook: hook.bind(null, token) })
	);
};
var VERSION4 = "6.1.4";
var noop2 = () => {},
	consoleWarn = console.warn.bind(console),
	consoleError = console.error.bind(console),
	userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
class Octokit {
	static VERSION = VERSION4;
	static defaults(defaults) {
		return class extends this {
			constructor(...args) {
				let options = args[0] || {};
				if (typeof defaults === "function") {
					super(defaults(options));
					return;
				}
				super(
					Object.assign(
						{},
						defaults,
						options,
						options.userAgent && defaults.userAgent
							? { userAgent: `${options.userAgent} ${defaults.userAgent}` }
							: null,
					),
				);
			}
		};
	}
	static plugins = [];
	static plugin(...newPlugins) {
		let currentPlugins = this.plugins;
		return class extends this {
			static plugins = currentPlugins.concat(
				newPlugins.filter((plugin) => !currentPlugins.includes(plugin)),
			);
		};
	}
	constructor(options = {}) {
		let hook2 = new before_after_hook_default.Collection(),
			requestDefaults = {
				baseUrl: request.endpoint.DEFAULTS.baseUrl,
				headers: {},
				request: Object.assign({}, options.request, {
					hook: hook2.bind(null, "request"),
				}),
				mediaType: { previews: [], format: "" },
			};
		if (
			((requestDefaults.headers["user-agent"] = options.userAgent
				? `${options.userAgent} ${userAgentTrail}`
				: userAgentTrail),
			options.baseUrl)
		)
			requestDefaults.baseUrl = options.baseUrl;
		if (options.previews) requestDefaults.mediaType.previews = options.previews;
		if (options.timeZone)
			requestDefaults.headers["time-zone"] = options.timeZone;
		if (
			((this.request = request.defaults(requestDefaults)),
			(this.graphql = withCustomRequest(this.request).defaults(
				requestDefaults,
			)),
			(this.log = Object.assign(
				{ debug: noop2, info: noop2, warn: consoleWarn, error: consoleError },
				options.log,
			)),
			(this.hook = hook2),
			!options.authStrategy)
		)
			if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
			else {
				let auth2 = createTokenAuth(options.auth);
				hook2.wrap("request", auth2.hook), (this.auth = auth2);
			}
		else {
			let { authStrategy, ...otherOptions } = options,
				auth2 = authStrategy(
					Object.assign(
						{
							request: this.request,
							log: this.log,
							octokit: this,
							octokitOptions: otherOptions,
						},
						options.auth,
					),
				);
			hook2.wrap("request", auth2.hook), (this.auth = auth2);
		}
		let classConstructor = this.constructor;
		for (let i = 0; i < classConstructor.plugins.length; ++i)
			Object.assign(this, classConstructor.plugins[i](this, options));
	}
	request;
	graphql;
	log;
	hook;
	auth;
}
var VERSION5 = "5.3.1";
function requestLog(octokit) {
	octokit.hook.wrap("request", (request2, options) => {
		octokit.log.debug("request", options);
		let start = Date.now(),
			requestOptions = octokit.request.endpoint.parse(options),
			path = requestOptions.url.replace(options.baseUrl, "");
		return request2(options)
			.then((response) => {
				let requestId = response.headers["x-github-request-id"];
				return (
					octokit.log.info(
						`${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`,
					),
					response
				);
			})
			.catch((error2) => {
				let requestId =
					error2.response?.headers["x-github-request-id"] || "UNKNOWN";
				throw (
					(octokit.log.error(
						`${requestOptions.method} ${path} - ${error2.status} with id ${requestId} in ${Date.now() - start}ms`,
					),
					error2)
				);
			});
	});
}
requestLog.VERSION = VERSION5;
var VERSION6 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
	if (!response.data) return { ...response, data: [] };
	if (!("total_count" in response.data && !("url" in response.data)))
		return response;
	let incompleteResults = response.data.incomplete_results,
		repositorySelection = response.data.repository_selection,
		totalCount = response.data.total_count;
	delete response.data.incomplete_results,
		delete response.data.repository_selection,
		delete response.data.total_count;
	let namespaceKey = Object.keys(response.data)[0],
		data = response.data[namespaceKey];
	if (((response.data = data), typeof incompleteResults !== "undefined"))
		response.data.incomplete_results = incompleteResults;
	if (typeof repositorySelection !== "undefined")
		response.data.repository_selection = repositorySelection;
	return (response.data.total_count = totalCount), response;
}
function iterator(octokit, route, parameters) {
	let options =
			typeof route === "function"
				? route.endpoint(parameters)
				: octokit.request.endpoint(route, parameters),
		requestMethod = typeof route === "function" ? route : octokit.request,
		method = options.method,
		headers = options.headers,
		url = options.url;
	return {
		[Symbol.asyncIterator]: () => ({
			async next() {
				if (!url) return { done: !0 };
				try {
					let response = await requestMethod({ method, url, headers }),
						normalizedResponse = normalizePaginatedListResponse(response);
					return (
						(url = ((normalizedResponse.headers.link || "").match(
							/<([^<>]+)>;\s*rel="next"/,
						) || [])[1]),
						{ value: normalizedResponse }
					);
				} catch (error2) {
					if (error2.status !== 409) throw error2;
					return (url = ""), { value: { status: 200, headers: {}, data: [] } };
				}
			},
		}),
	};
}
function paginate(octokit, route, parameters, mapFn) {
	if (typeof parameters === "function")
		(mapFn = parameters), (parameters = void 0);
	return gather(
		octokit,
		[],
		iterator(octokit, route, parameters)[Symbol.asyncIterator](),
		mapFn,
	);
}
function gather(octokit, results, iterator2, mapFn) {
	return iterator2.next().then((result) => {
		if (result.done) return results;
		let earlyExit = !1;
		function done() {
			earlyExit = !0;
		}
		if (
			((results = results.concat(
				mapFn ? mapFn(result.value, done) : result.value.data,
			)),
			earlyExit)
		)
			return results;
		return gather(octokit, results, iterator2, mapFn);
	});
}
var composePaginateRest = Object.assign(paginate, { iterator });
function paginateRest(octokit) {
	return {
		paginate: Object.assign(paginate.bind(null, octokit), {
			iterator: iterator.bind(null, octokit),
		}),
	};
}
paginateRest.VERSION = VERSION6;
var VERSION7 = "13.5.0";
var Endpoints = {
		actions: {
			addCustomLabelsToSelfHostedRunnerForOrg: [
				"POST /orgs/{org}/actions/runners/{runner_id}/labels",
			],
			addCustomLabelsToSelfHostedRunnerForRepo: [
				"POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
			],
			addRepoAccessToSelfHostedRunnerGroupInOrg: [
				"PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}",
			],
			addSelectedRepoToOrgSecret: [
				"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
			],
			addSelectedRepoToOrgVariable: [
				"PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
			],
			approveWorkflowRun: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
			],
			cancelWorkflowRun: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
			],
			createEnvironmentVariable: [
				"POST /repos/{owner}/{repo}/environments/{environment_name}/variables",
			],
			createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
			createOrUpdateEnvironmentSecret: [
				"PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
			],
			createOrUpdateOrgSecret: [
				"PUT /orgs/{org}/actions/secrets/{secret_name}",
			],
			createOrUpdateRepoSecret: [
				"PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
			],
			createOrgVariable: ["POST /orgs/{org}/actions/variables"],
			createRegistrationTokenForOrg: [
				"POST /orgs/{org}/actions/runners/registration-token",
			],
			createRegistrationTokenForRepo: [
				"POST /repos/{owner}/{repo}/actions/runners/registration-token",
			],
			createRemoveTokenForOrg: [
				"POST /orgs/{org}/actions/runners/remove-token",
			],
			createRemoveTokenForRepo: [
				"POST /repos/{owner}/{repo}/actions/runners/remove-token",
			],
			createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
			createWorkflowDispatch: [
				"POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
			],
			deleteActionsCacheById: [
				"DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}",
			],
			deleteActionsCacheByKey: [
				"DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}",
			],
			deleteArtifact: [
				"DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
			],
			deleteEnvironmentSecret: [
				"DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
			],
			deleteEnvironmentVariable: [
				"DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
			],
			deleteHostedRunnerForOrg: [
				"DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
			],
			deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
			deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
			deleteRepoSecret: [
				"DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
			],
			deleteRepoVariable: [
				"DELETE /repos/{owner}/{repo}/actions/variables/{name}",
			],
			deleteSelfHostedRunnerFromOrg: [
				"DELETE /orgs/{org}/actions/runners/{runner_id}",
			],
			deleteSelfHostedRunnerFromRepo: [
				"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
			],
			deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
			deleteWorkflowRunLogs: [
				"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
			],
			disableSelectedRepositoryGithubActionsOrganization: [
				"DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
			],
			disableWorkflow: [
				"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
			],
			downloadArtifact: [
				"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
			],
			downloadJobLogsForWorkflowRun: [
				"GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
			],
			downloadWorkflowRunAttemptLogs: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs",
			],
			downloadWorkflowRunLogs: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
			],
			enableSelectedRepositoryGithubActionsOrganization: [
				"PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
			],
			enableWorkflow: [
				"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
			],
			forceCancelWorkflowRun: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel",
			],
			generateRunnerJitconfigForOrg: [
				"POST /orgs/{org}/actions/runners/generate-jitconfig",
			],
			generateRunnerJitconfigForRepo: [
				"POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig",
			],
			getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
			getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
			getActionsCacheUsageByRepoForOrg: [
				"GET /orgs/{org}/actions/cache/usage-by-repository",
			],
			getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
			getAllowedActionsOrganization: [
				"GET /orgs/{org}/actions/permissions/selected-actions",
			],
			getAllowedActionsRepository: [
				"GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
			],
			getArtifact: [
				"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
			],
			getCustomOidcSubClaimForRepo: [
				"GET /repos/{owner}/{repo}/actions/oidc/customization/sub",
			],
			getEnvironmentPublicKey: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key",
			],
			getEnvironmentSecret: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
			],
			getEnvironmentVariable: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
			],
			getGithubActionsDefaultWorkflowPermissionsOrganization: [
				"GET /orgs/{org}/actions/permissions/workflow",
			],
			getGithubActionsDefaultWorkflowPermissionsRepository: [
				"GET /repos/{owner}/{repo}/actions/permissions/workflow",
			],
			getGithubActionsPermissionsOrganization: [
				"GET /orgs/{org}/actions/permissions",
			],
			getGithubActionsPermissionsRepository: [
				"GET /repos/{owner}/{repo}/actions/permissions",
			],
			getHostedRunnerForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
			],
			getHostedRunnersGithubOwnedImagesForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/images/github-owned",
			],
			getHostedRunnersLimitsForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/limits",
			],
			getHostedRunnersMachineSpecsForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/machine-sizes",
			],
			getHostedRunnersPartnerImagesForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/images/partner",
			],
			getHostedRunnersPlatformsForOrg: [
				"GET /orgs/{org}/actions/hosted-runners/platforms",
			],
			getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
			getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
			getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
			getPendingDeploymentsForRun: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
			],
			getRepoPermissions: [
				"GET /repos/{owner}/{repo}/actions/permissions",
				{},
				{ renamed: ["actions", "getGithubActionsPermissionsRepository"] },
			],
			getRepoPublicKey: [
				"GET /repos/{owner}/{repo}/actions/secrets/public-key",
			],
			getRepoSecret: [
				"GET /repos/{owner}/{repo}/actions/secrets/{secret_name}",
			],
			getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
			getReviewsForRun: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
			],
			getSelfHostedRunnerForOrg: [
				"GET /orgs/{org}/actions/runners/{runner_id}",
			],
			getSelfHostedRunnerForRepo: [
				"GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
			],
			getWorkflow: [
				"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}",
			],
			getWorkflowAccessToRepository: [
				"GET /repos/{owner}/{repo}/actions/permissions/access",
			],
			getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
			getWorkflowRunAttempt: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}",
			],
			getWorkflowRunUsage: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
			],
			getWorkflowUsage: [
				"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
			],
			listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
			listEnvironmentSecrets: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
			],
			listEnvironmentVariables: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
			],
			listGithubHostedRunnersInGroupForOrg: [
				"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners",
			],
			listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
			listJobsForWorkflowRun: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
			],
			listJobsForWorkflowRunAttempt: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
			],
			listLabelsForSelfHostedRunnerForOrg: [
				"GET /orgs/{org}/actions/runners/{runner_id}/labels",
			],
			listLabelsForSelfHostedRunnerForRepo: [
				"GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
			],
			listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
			listOrgVariables: ["GET /orgs/{org}/actions/variables"],
			listRepoOrganizationSecrets: [
				"GET /repos/{owner}/{repo}/actions/organization-secrets",
			],
			listRepoOrganizationVariables: [
				"GET /repos/{owner}/{repo}/actions/organization-variables",
			],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
			listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
			listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
			listRunnerApplicationsForOrg: [
				"GET /orgs/{org}/actions/runners/downloads",
			],
			listRunnerApplicationsForRepo: [
				"GET /repos/{owner}/{repo}/actions/runners/downloads",
			],
			listSelectedReposForOrgSecret: [
				"GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
			],
			listSelectedReposForOrgVariable: [
				"GET /orgs/{org}/actions/variables/{name}/repositories",
			],
			listSelectedRepositoriesEnabledGithubActionsOrganization: [
				"GET /orgs/{org}/actions/permissions/repositories",
			],
			listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
			listSelfHostedRunnersForRepo: [
				"GET /repos/{owner}/{repo}/actions/runners",
			],
			listWorkflowRunArtifacts: [
				"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
			],
			listWorkflowRuns: [
				"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
			],
			listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
			reRunJobForWorkflowRun: [
				"POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun",
			],
			reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
			reRunWorkflowFailedJobs: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs",
			],
			removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
				"DELETE /orgs/{org}/actions/runners/{runner_id}/labels",
			],
			removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
				"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
			],
			removeCustomLabelFromSelfHostedRunnerForOrg: [
				"DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}",
			],
			removeCustomLabelFromSelfHostedRunnerForRepo: [
				"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}",
			],
			removeSelectedRepoFromOrgSecret: [
				"DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
			],
			removeSelectedRepoFromOrgVariable: [
				"DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
			],
			reviewCustomGatesForRun: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule",
			],
			reviewPendingDeploymentsForRun: [
				"POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
			],
			setAllowedActionsOrganization: [
				"PUT /orgs/{org}/actions/permissions/selected-actions",
			],
			setAllowedActionsRepository: [
				"PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
			],
			setCustomLabelsForSelfHostedRunnerForOrg: [
				"PUT /orgs/{org}/actions/runners/{runner_id}/labels",
			],
			setCustomLabelsForSelfHostedRunnerForRepo: [
				"PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
			],
			setCustomOidcSubClaimForRepo: [
				"PUT /repos/{owner}/{repo}/actions/oidc/customization/sub",
			],
			setGithubActionsDefaultWorkflowPermissionsOrganization: [
				"PUT /orgs/{org}/actions/permissions/workflow",
			],
			setGithubActionsDefaultWorkflowPermissionsRepository: [
				"PUT /repos/{owner}/{repo}/actions/permissions/workflow",
			],
			setGithubActionsPermissionsOrganization: [
				"PUT /orgs/{org}/actions/permissions",
			],
			setGithubActionsPermissionsRepository: [
				"PUT /repos/{owner}/{repo}/actions/permissions",
			],
			setSelectedReposForOrgSecret: [
				"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
			],
			setSelectedReposForOrgVariable: [
				"PUT /orgs/{org}/actions/variables/{name}/repositories",
			],
			setSelectedRepositoriesEnabledGithubActionsOrganization: [
				"PUT /orgs/{org}/actions/permissions/repositories",
			],
			setWorkflowAccessToRepository: [
				"PUT /repos/{owner}/{repo}/actions/permissions/access",
			],
			updateEnvironmentVariable: [
				"PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
			],
			updateHostedRunnerForOrg: [
				"PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
			],
			updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
			updateRepoVariable: [
				"PATCH /repos/{owner}/{repo}/actions/variables/{name}",
			],
		},
		activity: {
			checkRepoIsStarredByAuthenticatedUser: [
				"GET /user/starred/{owner}/{repo}",
			],
			deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
			deleteThreadSubscription: [
				"DELETE /notifications/threads/{thread_id}/subscription",
			],
			getFeeds: ["GET /feeds"],
			getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
			getThread: ["GET /notifications/threads/{thread_id}"],
			getThreadSubscriptionForAuthenticatedUser: [
				"GET /notifications/threads/{thread_id}/subscription",
			],
			listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
			listNotificationsForAuthenticatedUser: ["GET /notifications"],
			listOrgEventsForAuthenticatedUser: [
				"GET /users/{username}/events/orgs/{org}",
			],
			listPublicEvents: ["GET /events"],
			listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
			listPublicEventsForUser: ["GET /users/{username}/events/public"],
			listPublicOrgEvents: ["GET /orgs/{org}/events"],
			listReceivedEventsForUser: ["GET /users/{username}/received_events"],
			listReceivedPublicEventsForUser: [
				"GET /users/{username}/received_events/public",
			],
			listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
			listRepoNotificationsForAuthenticatedUser: [
				"GET /repos/{owner}/{repo}/notifications",
			],
			listReposStarredByAuthenticatedUser: ["GET /user/starred"],
			listReposStarredByUser: ["GET /users/{username}/starred"],
			listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
			listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
			listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
			listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
			markNotificationsAsRead: ["PUT /notifications"],
			markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
			markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
			markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
			setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
			setThreadSubscription: [
				"PUT /notifications/threads/{thread_id}/subscription",
			],
			starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
			unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
		},
		apps: {
			addRepoToInstallation: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
			],
			addRepoToInstallationForAuthenticatedUser: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
			],
			checkToken: ["POST /applications/{client_id}/token"],
			createFromManifest: ["POST /app-manifests/{code}/conversions"],
			createInstallationAccessToken: [
				"POST /app/installations/{installation_id}/access_tokens",
			],
			deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
			deleteInstallation: ["DELETE /app/installations/{installation_id}"],
			deleteToken: ["DELETE /applications/{client_id}/token"],
			getAuthenticated: ["GET /app"],
			getBySlug: ["GET /apps/{app_slug}"],
			getInstallation: ["GET /app/installations/{installation_id}"],
			getOrgInstallation: ["GET /orgs/{org}/installation"],
			getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
			getSubscriptionPlanForAccount: [
				"GET /marketplace_listing/accounts/{account_id}",
			],
			getSubscriptionPlanForAccountStubbed: [
				"GET /marketplace_listing/stubbed/accounts/{account_id}",
			],
			getUserInstallation: ["GET /users/{username}/installation"],
			getWebhookConfigForApp: ["GET /app/hook/config"],
			getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
			listAccountsForPlan: [
				"GET /marketplace_listing/plans/{plan_id}/accounts",
			],
			listAccountsForPlanStubbed: [
				"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
			],
			listInstallationReposForAuthenticatedUser: [
				"GET /user/installations/{installation_id}/repositories",
			],
			listInstallationRequestsForAuthenticatedApp: [
				"GET /app/installation-requests",
			],
			listInstallations: ["GET /app/installations"],
			listInstallationsForAuthenticatedUser: ["GET /user/installations"],
			listPlans: ["GET /marketplace_listing/plans"],
			listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
			listReposAccessibleToInstallation: ["GET /installation/repositories"],
			listSubscriptionsForAuthenticatedUser: [
				"GET /user/marketplace_purchases",
			],
			listSubscriptionsForAuthenticatedUserStubbed: [
				"GET /user/marketplace_purchases/stubbed",
			],
			listWebhookDeliveries: ["GET /app/hook/deliveries"],
			redeliverWebhookDelivery: [
				"POST /app/hook/deliveries/{delivery_id}/attempts",
			],
			removeRepoFromInstallation: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
			],
			removeRepoFromInstallationForAuthenticatedUser: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
			],
			resetToken: ["PATCH /applications/{client_id}/token"],
			revokeInstallationAccessToken: ["DELETE /installation/token"],
			scopeToken: ["POST /applications/{client_id}/token/scoped"],
			suspendInstallation: [
				"PUT /app/installations/{installation_id}/suspended",
			],
			unsuspendInstallation: [
				"DELETE /app/installations/{installation_id}/suspended",
			],
			updateWebhookConfigForApp: ["PATCH /app/hook/config"],
		},
		billing: {
			getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
			getGithubActionsBillingUser: [
				"GET /users/{username}/settings/billing/actions",
			],
			getGithubBillingUsageReportOrg: [
				"GET /organizations/{org}/settings/billing/usage",
			],
			getGithubPackagesBillingOrg: [
				"GET /orgs/{org}/settings/billing/packages",
			],
			getGithubPackagesBillingUser: [
				"GET /users/{username}/settings/billing/packages",
			],
			getSharedStorageBillingOrg: [
				"GET /orgs/{org}/settings/billing/shared-storage",
			],
			getSharedStorageBillingUser: [
				"GET /users/{username}/settings/billing/shared-storage",
			],
		},
		checks: {
			create: ["POST /repos/{owner}/{repo}/check-runs"],
			createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
			get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
			getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
			listAnnotations: [
				"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
			],
			listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
			listForSuite: [
				"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
			],
			listSuitesForRef: [
				"GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
			],
			rerequestRun: [
				"POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest",
			],
			rerequestSuite: [
				"POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
			],
			setSuitesPreferences: [
				"PATCH /repos/{owner}/{repo}/check-suites/preferences",
			],
			update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
		},
		codeScanning: {
			commitAutofix: [
				"POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits",
			],
			createAutofix: [
				"POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix",
			],
			createVariantAnalysis: [
				"POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses",
			],
			deleteAnalysis: [
				"DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
			],
			deleteCodeqlDatabase: [
				"DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}",
			],
			getAlert: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
				{},
				{ renamedParameters: { alert_id: "alert_number" } },
			],
			getAnalysis: [
				"GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
			],
			getAutofix: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix",
			],
			getCodeqlDatabase: [
				"GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}",
			],
			getDefaultSetup: [
				"GET /repos/{owner}/{repo}/code-scanning/default-setup",
			],
			getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
			getVariantAnalysis: [
				"GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}",
			],
			getVariantAnalysisRepoTask: [
				"GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}",
			],
			listAlertInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
			],
			listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
			listAlertsInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
				{},
				{ renamed: ["codeScanning", "listAlertInstances"] },
			],
			listCodeqlDatabases: [
				"GET /repos/{owner}/{repo}/code-scanning/codeql/databases",
			],
			listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
			updateAlert: [
				"PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
			],
			updateDefaultSetup: [
				"PATCH /repos/{owner}/{repo}/code-scanning/default-setup",
			],
			uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
		},
		codeSecurity: {
			attachConfiguration: [
				"POST /orgs/{org}/code-security/configurations/{configuration_id}/attach",
			],
			attachEnterpriseConfiguration: [
				"POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach",
			],
			createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
			createConfigurationForEnterprise: [
				"POST /enterprises/{enterprise}/code-security/configurations",
			],
			deleteConfiguration: [
				"DELETE /orgs/{org}/code-security/configurations/{configuration_id}",
			],
			deleteConfigurationForEnterprise: [
				"DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
			],
			detachConfiguration: [
				"DELETE /orgs/{org}/code-security/configurations/detach",
			],
			getConfiguration: [
				"GET /orgs/{org}/code-security/configurations/{configuration_id}",
			],
			getConfigurationForRepository: [
				"GET /repos/{owner}/{repo}/code-security-configuration",
			],
			getConfigurationsForEnterprise: [
				"GET /enterprises/{enterprise}/code-security/configurations",
			],
			getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
			getDefaultConfigurations: [
				"GET /orgs/{org}/code-security/configurations/defaults",
			],
			getDefaultConfigurationsForEnterprise: [
				"GET /enterprises/{enterprise}/code-security/configurations/defaults",
			],
			getRepositoriesForConfiguration: [
				"GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories",
			],
			getRepositoriesForEnterpriseConfiguration: [
				"GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories",
			],
			getSingleConfigurationForEnterprise: [
				"GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
			],
			setConfigurationAsDefault: [
				"PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults",
			],
			setConfigurationAsDefaultForEnterprise: [
				"PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults",
			],
			updateConfiguration: [
				"PATCH /orgs/{org}/code-security/configurations/{configuration_id}",
			],
			updateEnterpriseConfiguration: [
				"PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
			],
		},
		codesOfConduct: {
			getAllCodesOfConduct: ["GET /codes_of_conduct"],
			getConductCode: ["GET /codes_of_conduct/{key}"],
		},
		codespaces: {
			addRepositoryForSecretForAuthenticatedUser: [
				"PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
			],
			addSelectedRepoToOrgSecret: [
				"PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
			],
			checkPermissionsForDevcontainer: [
				"GET /repos/{owner}/{repo}/codespaces/permissions_check",
			],
			codespaceMachinesForAuthenticatedUser: [
				"GET /user/codespaces/{codespace_name}/machines",
			],
			createForAuthenticatedUser: ["POST /user/codespaces"],
			createOrUpdateOrgSecret: [
				"PUT /orgs/{org}/codespaces/secrets/{secret_name}",
			],
			createOrUpdateRepoSecret: [
				"PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
			],
			createOrUpdateSecretForAuthenticatedUser: [
				"PUT /user/codespaces/secrets/{secret_name}",
			],
			createWithPrForAuthenticatedUser: [
				"POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces",
			],
			createWithRepoForAuthenticatedUser: [
				"POST /repos/{owner}/{repo}/codespaces",
			],
			deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
			deleteFromOrganization: [
				"DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}",
			],
			deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
			deleteRepoSecret: [
				"DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
			],
			deleteSecretForAuthenticatedUser: [
				"DELETE /user/codespaces/secrets/{secret_name}",
			],
			exportForAuthenticatedUser: [
				"POST /user/codespaces/{codespace_name}/exports",
			],
			getCodespacesForUserInOrg: [
				"GET /orgs/{org}/members/{username}/codespaces",
			],
			getExportDetailsForAuthenticatedUser: [
				"GET /user/codespaces/{codespace_name}/exports/{export_id}",
			],
			getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
			getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
			getPublicKeyForAuthenticatedUser: [
				"GET /user/codespaces/secrets/public-key",
			],
			getRepoPublicKey: [
				"GET /repos/{owner}/{repo}/codespaces/secrets/public-key",
			],
			getRepoSecret: [
				"GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
			],
			getSecretForAuthenticatedUser: [
				"GET /user/codespaces/secrets/{secret_name}",
			],
			listDevcontainersInRepositoryForAuthenticatedUser: [
				"GET /repos/{owner}/{repo}/codespaces/devcontainers",
			],
			listForAuthenticatedUser: ["GET /user/codespaces"],
			listInOrganization: [
				"GET /orgs/{org}/codespaces",
				{},
				{ renamedParameters: { org_id: "org" } },
			],
			listInRepositoryForAuthenticatedUser: [
				"GET /repos/{owner}/{repo}/codespaces",
			],
			listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
			listRepositoriesForSecretForAuthenticatedUser: [
				"GET /user/codespaces/secrets/{secret_name}/repositories",
			],
			listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
			listSelectedReposForOrgSecret: [
				"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
			],
			preFlightWithRepoForAuthenticatedUser: [
				"GET /repos/{owner}/{repo}/codespaces/new",
			],
			publishForAuthenticatedUser: [
				"POST /user/codespaces/{codespace_name}/publish",
			],
			removeRepositoryForSecretForAuthenticatedUser: [
				"DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
			],
			removeSelectedRepoFromOrgSecret: [
				"DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
			],
			repoMachinesForAuthenticatedUser: [
				"GET /repos/{owner}/{repo}/codespaces/machines",
			],
			setRepositoriesForSecretForAuthenticatedUser: [
				"PUT /user/codespaces/secrets/{secret_name}/repositories",
			],
			setSelectedReposForOrgSecret: [
				"PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
			],
			startForAuthenticatedUser: [
				"POST /user/codespaces/{codespace_name}/start",
			],
			stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
			stopInOrganization: [
				"POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop",
			],
			updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
		},
		copilot: {
			addCopilotSeatsForTeams: [
				"POST /orgs/{org}/copilot/billing/selected_teams",
			],
			addCopilotSeatsForUsers: [
				"POST /orgs/{org}/copilot/billing/selected_users",
			],
			cancelCopilotSeatAssignmentForTeams: [
				"DELETE /orgs/{org}/copilot/billing/selected_teams",
			],
			cancelCopilotSeatAssignmentForUsers: [
				"DELETE /orgs/{org}/copilot/billing/selected_users",
			],
			copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
			copilotMetricsForTeam: [
				"GET /orgs/{org}/team/{team_slug}/copilot/metrics",
			],
			getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
			getCopilotSeatDetailsForUser: [
				"GET /orgs/{org}/members/{username}/copilot",
			],
			listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
			usageMetricsForOrg: ["GET /orgs/{org}/copilot/usage"],
			usageMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/usage"],
		},
		dependabot: {
			addSelectedRepoToOrgSecret: [
				"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
			],
			createOrUpdateOrgSecret: [
				"PUT /orgs/{org}/dependabot/secrets/{secret_name}",
			],
			createOrUpdateRepoSecret: [
				"PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
			],
			deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
			deleteRepoSecret: [
				"DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
			],
			getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
			getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
			getRepoPublicKey: [
				"GET /repos/{owner}/{repo}/dependabot/secrets/public-key",
			],
			getRepoSecret: [
				"GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
			],
			listAlertsForEnterprise: [
				"GET /enterprises/{enterprise}/dependabot/alerts",
			],
			listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
			listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
			listSelectedReposForOrgSecret: [
				"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
			],
			removeSelectedRepoFromOrgSecret: [
				"DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
			],
			setSelectedReposForOrgSecret: [
				"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
			],
			updateAlert: [
				"PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}",
			],
		},
		dependencyGraph: {
			createRepositorySnapshot: [
				"POST /repos/{owner}/{repo}/dependency-graph/snapshots",
			],
			diffRange: [
				"GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}",
			],
			exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"],
		},
		emojis: { get: ["GET /emojis"] },
		gists: {
			checkIsStarred: ["GET /gists/{gist_id}/star"],
			create: ["POST /gists"],
			createComment: ["POST /gists/{gist_id}/comments"],
			delete: ["DELETE /gists/{gist_id}"],
			deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
			fork: ["POST /gists/{gist_id}/forks"],
			get: ["GET /gists/{gist_id}"],
			getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
			getRevision: ["GET /gists/{gist_id}/{sha}"],
			list: ["GET /gists"],
			listComments: ["GET /gists/{gist_id}/comments"],
			listCommits: ["GET /gists/{gist_id}/commits"],
			listForUser: ["GET /users/{username}/gists"],
			listForks: ["GET /gists/{gist_id}/forks"],
			listPublic: ["GET /gists/public"],
			listStarred: ["GET /gists/starred"],
			star: ["PUT /gists/{gist_id}/star"],
			unstar: ["DELETE /gists/{gist_id}/star"],
			update: ["PATCH /gists/{gist_id}"],
			updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
		},
		git: {
			createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
			createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
			createRef: ["POST /repos/{owner}/{repo}/git/refs"],
			createTag: ["POST /repos/{owner}/{repo}/git/tags"],
			createTree: ["POST /repos/{owner}/{repo}/git/trees"],
			deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
			getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
			getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
			getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
			getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
			getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
			listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
			updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
		},
		gitignore: {
			getAllTemplates: ["GET /gitignore/templates"],
			getTemplate: ["GET /gitignore/templates/{name}"],
		},
		hostedCompute: {
			createNetworkConfigurationForOrg: [
				"POST /orgs/{org}/settings/network-configurations",
			],
			deleteNetworkConfigurationFromOrg: [
				"DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}",
			],
			getNetworkConfigurationForOrg: [
				"GET /orgs/{org}/settings/network-configurations/{network_configuration_id}",
			],
			getNetworkSettingsForOrg: [
				"GET /orgs/{org}/settings/network-settings/{network_settings_id}",
			],
			listNetworkConfigurationsForOrg: [
				"GET /orgs/{org}/settings/network-configurations",
			],
			updateNetworkConfigurationForOrg: [
				"PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}",
			],
		},
		interactions: {
			getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
			getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
			getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
			getRestrictionsForYourPublicRepos: [
				"GET /user/interaction-limits",
				{},
				{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] },
			],
			removeRestrictionsForAuthenticatedUser: [
				"DELETE /user/interaction-limits",
			],
			removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
			removeRestrictionsForRepo: [
				"DELETE /repos/{owner}/{repo}/interaction-limits",
			],
			removeRestrictionsForYourPublicRepos: [
				"DELETE /user/interaction-limits",
				{},
				{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] },
			],
			setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
			setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
			setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
			setRestrictionsForYourPublicRepos: [
				"PUT /user/interaction-limits",
				{},
				{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] },
			],
		},
		issues: {
			addAssignees: [
				"POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
			],
			addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			addSubIssue: [
				"POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
			],
			checkUserCanBeAssigned: [
				"GET /repos/{owner}/{repo}/assignees/{assignee}",
			],
			checkUserCanBeAssignedToIssue: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}",
			],
			create: ["POST /repos/{owner}/{repo}/issues"],
			createComment: [
				"POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
			],
			createLabel: ["POST /repos/{owner}/{repo}/labels"],
			createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
			deleteComment: [
				"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
			],
			deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
			deleteMilestone: [
				"DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
			],
			get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
			getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
			getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
			getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
			list: ["GET /issues"],
			listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
			listComments: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
			],
			listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
			listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
			listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
			listEventsForTimeline: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
			],
			listForAuthenticatedUser: ["GET /user/issues"],
			listForOrg: ["GET /orgs/{org}/issues"],
			listForRepo: ["GET /repos/{owner}/{repo}/issues"],
			listLabelsForMilestone: [
				"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
			],
			listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
			listLabelsOnIssue: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
			],
			listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
			listSubIssues: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
			],
			lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			removeAllLabels: [
				"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
			],
			removeAssignees: [
				"DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
			],
			removeLabel: [
				"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
			],
			removeSubIssue: [
				"DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue",
			],
			reprioritizeSubIssue: [
				"PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority",
			],
			setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
			updateComment: [
				"PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}",
			],
			updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
			updateMilestone: [
				"PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
			],
		},
		licenses: {
			get: ["GET /licenses/{license}"],
			getAllCommonlyUsed: ["GET /licenses"],
			getForRepo: ["GET /repos/{owner}/{repo}/license"],
		},
		markdown: {
			render: ["POST /markdown"],
			renderRaw: [
				"POST /markdown/raw",
				{ headers: { "content-type": "text/plain; charset=utf-8" } },
			],
		},
		meta: {
			get: ["GET /meta"],
			getAllVersions: ["GET /versions"],
			getOctocat: ["GET /octocat"],
			getZen: ["GET /zen"],
			root: ["GET /"],
		},
		migrations: {
			deleteArchiveForAuthenticatedUser: [
				"DELETE /user/migrations/{migration_id}/archive",
			],
			deleteArchiveForOrg: [
				"DELETE /orgs/{org}/migrations/{migration_id}/archive",
			],
			downloadArchiveForOrg: [
				"GET /orgs/{org}/migrations/{migration_id}/archive",
			],
			getArchiveForAuthenticatedUser: [
				"GET /user/migrations/{migration_id}/archive",
			],
			getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
			getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
			listForAuthenticatedUser: ["GET /user/migrations"],
			listForOrg: ["GET /orgs/{org}/migrations"],
			listReposForAuthenticatedUser: [
				"GET /user/migrations/{migration_id}/repositories",
			],
			listReposForOrg: [
				"GET /orgs/{org}/migrations/{migration_id}/repositories",
			],
			listReposForUser: [
				"GET /user/migrations/{migration_id}/repositories",
				{},
				{ renamed: ["migrations", "listReposForAuthenticatedUser"] },
			],
			startForAuthenticatedUser: ["POST /user/migrations"],
			startForOrg: ["POST /orgs/{org}/migrations"],
			unlockRepoForAuthenticatedUser: [
				"DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
			],
			unlockRepoForOrg: [
				"DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
			],
		},
		oidc: {
			getOidcCustomSubTemplateForOrg: [
				"GET /orgs/{org}/actions/oidc/customization/sub",
			],
			updateOidcCustomSubTemplateForOrg: [
				"PUT /orgs/{org}/actions/oidc/customization/sub",
			],
		},
		orgs: {
			addSecurityManagerTeam: [
				"PUT /orgs/{org}/security-managers/teams/{team_slug}",
				{},
				{
					deprecated:
						"octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team",
				},
			],
			assignTeamToOrgRole: [
				"PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}",
			],
			assignUserToOrgRole: [
				"PUT /orgs/{org}/organization-roles/users/{username}/{role_id}",
			],
			blockUser: ["PUT /orgs/{org}/blocks/{username}"],
			cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
			checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
			checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
			checkPublicMembershipForUser: [
				"GET /orgs/{org}/public_members/{username}",
			],
			convertMemberToOutsideCollaborator: [
				"PUT /orgs/{org}/outside_collaborators/{username}",
			],
			createInvitation: ["POST /orgs/{org}/invitations"],
			createIssueType: ["POST /orgs/{org}/issue-types"],
			createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
			createOrUpdateCustomPropertiesValuesForRepos: [
				"PATCH /orgs/{org}/properties/values",
			],
			createOrUpdateCustomProperty: [
				"PUT /orgs/{org}/properties/schema/{custom_property_name}",
			],
			createWebhook: ["POST /orgs/{org}/hooks"],
			delete: ["DELETE /orgs/{org}"],
			deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
			deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
			enableOrDisableSecurityProductOnAllOrgRepos: [
				"POST /orgs/{org}/{security_product}/{enablement}",
				{},
				{
					deprecated:
						"octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization",
				},
			],
			get: ["GET /orgs/{org}"],
			getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
			getCustomProperty: [
				"GET /orgs/{org}/properties/schema/{custom_property_name}",
			],
			getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
			getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
			getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
			getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
			getOrgRulesetVersion: [
				"GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}",
			],
			getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
			getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
			getWebhookDelivery: [
				"GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
			],
			list: ["GET /organizations"],
			listAppInstallations: ["GET /orgs/{org}/installations"],
			listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
			listBlockedUsers: ["GET /orgs/{org}/blocks"],
			listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
			listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
			listForAuthenticatedUser: ["GET /user/orgs"],
			listForUser: ["GET /users/{username}/orgs"],
			listInvitationTeams: [
				"GET /orgs/{org}/invitations/{invitation_id}/teams",
			],
			listIssueTypes: ["GET /orgs/{org}/issue-types"],
			listMembers: ["GET /orgs/{org}/members"],
			listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
			listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
			listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
			listOrgRoles: ["GET /orgs/{org}/organization-roles"],
			listOrganizationFineGrainedPermissions: [
				"GET /orgs/{org}/organization-fine-grained-permissions",
			],
			listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
			listPatGrantRepositories: [
				"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
			],
			listPatGrantRequestRepositories: [
				"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
			],
			listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
			listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
			listPendingInvitations: ["GET /orgs/{org}/invitations"],
			listPublicMembers: ["GET /orgs/{org}/public_members"],
			listSecurityManagerTeams: [
				"GET /orgs/{org}/security-managers",
				{},
				{
					deprecated:
						"octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams",
				},
			],
			listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /orgs/{org}/hooks"],
			pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: [
				"POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
			],
			removeCustomProperty: [
				"DELETE /orgs/{org}/properties/schema/{custom_property_name}",
			],
			removeMember: ["DELETE /orgs/{org}/members/{username}"],
			removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
			removeOutsideCollaborator: [
				"DELETE /orgs/{org}/outside_collaborators/{username}",
			],
			removePublicMembershipForAuthenticatedUser: [
				"DELETE /orgs/{org}/public_members/{username}",
			],
			removeSecurityManagerTeam: [
				"DELETE /orgs/{org}/security-managers/teams/{team_slug}",
				{},
				{
					deprecated:
						"octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team",
				},
			],
			reviewPatGrantRequest: [
				"POST /orgs/{org}/personal-access-token-requests/{pat_request_id}",
			],
			reviewPatGrantRequestsInBulk: [
				"POST /orgs/{org}/personal-access-token-requests",
			],
			revokeAllOrgRolesTeam: [
				"DELETE /orgs/{org}/organization-roles/teams/{team_slug}",
			],
			revokeAllOrgRolesUser: [
				"DELETE /orgs/{org}/organization-roles/users/{username}",
			],
			revokeOrgRoleTeam: [
				"DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}",
			],
			revokeOrgRoleUser: [
				"DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}",
			],
			setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
			setPublicMembershipForAuthenticatedUser: [
				"PUT /orgs/{org}/public_members/{username}",
			],
			unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
			update: ["PATCH /orgs/{org}"],
			updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
			updateMembershipForAuthenticatedUser: [
				"PATCH /user/memberships/orgs/{org}",
			],
			updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
			updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
			updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
			updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
		},
		packages: {
			deletePackageForAuthenticatedUser: [
				"DELETE /user/packages/{package_type}/{package_name}",
			],
			deletePackageForOrg: [
				"DELETE /orgs/{org}/packages/{package_type}/{package_name}",
			],
			deletePackageForUser: [
				"DELETE /users/{username}/packages/{package_type}/{package_name}",
			],
			deletePackageVersionForAuthenticatedUser: [
				"DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			deletePackageVersionForOrg: [
				"DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			deletePackageVersionForUser: [
				"DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			getAllPackageVersionsForAPackageOwnedByAnOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
			],
			getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
				{},
				{
					renamed: [
						"packages",
						"getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
					],
				},
			],
			getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
			],
			getAllPackageVersionsForPackageOwnedByOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
			],
			getAllPackageVersionsForPackageOwnedByUser: [
				"GET /users/{username}/packages/{package_type}/{package_name}/versions",
			],
			getPackageForAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}",
			],
			getPackageForOrganization: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}",
			],
			getPackageForUser: [
				"GET /users/{username}/packages/{package_type}/{package_name}",
			],
			getPackageVersionForAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			getPackageVersionForOrganization: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			getPackageVersionForUser: [
				"GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
			],
			listDockerMigrationConflictingPackagesForAuthenticatedUser: [
				"GET /user/docker/conflicts",
			],
			listDockerMigrationConflictingPackagesForOrganization: [
				"GET /orgs/{org}/docker/conflicts",
			],
			listDockerMigrationConflictingPackagesForUser: [
				"GET /users/{username}/docker/conflicts",
			],
			listPackagesForAuthenticatedUser: ["GET /user/packages"],
			listPackagesForOrganization: ["GET /orgs/{org}/packages"],
			listPackagesForUser: ["GET /users/{username}/packages"],
			restorePackageForAuthenticatedUser: [
				"POST /user/packages/{package_type}/{package_name}/restore{?token}",
			],
			restorePackageForOrg: [
				"POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
			],
			restorePackageForUser: [
				"POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
			],
			restorePackageVersionForAuthenticatedUser: [
				"POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
			],
			restorePackageVersionForOrg: [
				"POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
			],
			restorePackageVersionForUser: [
				"POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
			],
		},
		privateRegistries: {
			createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
			deleteOrgPrivateRegistry: [
				"DELETE /orgs/{org}/private-registries/{secret_name}",
			],
			getOrgPrivateRegistry: [
				"GET /orgs/{org}/private-registries/{secret_name}",
			],
			getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
			listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
			updateOrgPrivateRegistry: [
				"PATCH /orgs/{org}/private-registries/{secret_name}",
			],
		},
		projects: {
			addCollaborator: [
				"PUT /projects/{project_id}/collaborators/{username}",
				{},
				{
					deprecated:
						"octokit.rest.projects.addCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#add-project-collaborator",
				},
			],
			createCard: [
				"POST /projects/columns/{column_id}/cards",
				{},
				{
					deprecated:
						"octokit.rest.projects.createCard() is deprecated, see https://docs.github.com/rest/projects/cards#create-a-project-card",
				},
			],
			createColumn: [
				"POST /projects/{project_id}/columns",
				{},
				{
					deprecated:
						"octokit.rest.projects.createColumn() is deprecated, see https://docs.github.com/rest/projects/columns#create-a-project-column",
				},
			],
			createForAuthenticatedUser: [
				"POST /user/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.createForAuthenticatedUser() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-user-project",
				},
			],
			createForOrg: [
				"POST /orgs/{org}/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.createForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#create-an-organization-project",
				},
			],
			createForRepo: [
				"POST /repos/{owner}/{repo}/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.createForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-repository-project",
				},
			],
			delete: [
				"DELETE /projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.delete() is deprecated, see https://docs.github.com/rest/projects/projects#delete-a-project",
				},
			],
			deleteCard: [
				"DELETE /projects/columns/cards/{card_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.deleteCard() is deprecated, see https://docs.github.com/rest/projects/cards#delete-a-project-card",
				},
			],
			deleteColumn: [
				"DELETE /projects/columns/{column_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.deleteColumn() is deprecated, see https://docs.github.com/rest/projects/columns#delete-a-project-column",
				},
			],
			get: [
				"GET /projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.get() is deprecated, see https://docs.github.com/rest/projects/projects#get-a-project",
				},
			],
			getCard: [
				"GET /projects/columns/cards/{card_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.getCard() is deprecated, see https://docs.github.com/rest/projects/cards#get-a-project-card",
				},
			],
			getColumn: [
				"GET /projects/columns/{column_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.getColumn() is deprecated, see https://docs.github.com/rest/projects/columns#get-a-project-column",
				},
			],
			getPermissionForUser: [
				"GET /projects/{project_id}/collaborators/{username}/permission",
				{},
				{
					deprecated:
						"octokit.rest.projects.getPermissionForUser() is deprecated, see https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user",
				},
			],
			listCards: [
				"GET /projects/columns/{column_id}/cards",
				{},
				{
					deprecated:
						"octokit.rest.projects.listCards() is deprecated, see https://docs.github.com/rest/projects/cards#list-project-cards",
				},
			],
			listCollaborators: [
				"GET /projects/{project_id}/collaborators",
				{},
				{
					deprecated:
						"octokit.rest.projects.listCollaborators() is deprecated, see https://docs.github.com/rest/projects/collaborators#list-project-collaborators",
				},
			],
			listColumns: [
				"GET /projects/{project_id}/columns",
				{},
				{
					deprecated:
						"octokit.rest.projects.listColumns() is deprecated, see https://docs.github.com/rest/projects/columns#list-project-columns",
				},
			],
			listForOrg: [
				"GET /orgs/{org}/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.listForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#list-organization-projects",
				},
			],
			listForRepo: [
				"GET /repos/{owner}/{repo}/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.listForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#list-repository-projects",
				},
			],
			listForUser: [
				"GET /users/{username}/projects",
				{},
				{
					deprecated:
						"octokit.rest.projects.listForUser() is deprecated, see https://docs.github.com/rest/projects/projects#list-user-projects",
				},
			],
			moveCard: [
				"POST /projects/columns/cards/{card_id}/moves",
				{},
				{
					deprecated:
						"octokit.rest.projects.moveCard() is deprecated, see https://docs.github.com/rest/projects/cards#move-a-project-card",
				},
			],
			moveColumn: [
				"POST /projects/columns/{column_id}/moves",
				{},
				{
					deprecated:
						"octokit.rest.projects.moveColumn() is deprecated, see https://docs.github.com/rest/projects/columns#move-a-project-column",
				},
			],
			removeCollaborator: [
				"DELETE /projects/{project_id}/collaborators/{username}",
				{},
				{
					deprecated:
						"octokit.rest.projects.removeCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator",
				},
			],
			update: [
				"PATCH /projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.update() is deprecated, see https://docs.github.com/rest/projects/projects#update-a-project",
				},
			],
			updateCard: [
				"PATCH /projects/columns/cards/{card_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.updateCard() is deprecated, see https://docs.github.com/rest/projects/cards#update-an-existing-project-card",
				},
			],
			updateColumn: [
				"PATCH /projects/columns/{column_id}",
				{},
				{
					deprecated:
						"octokit.rest.projects.updateColumn() is deprecated, see https://docs.github.com/rest/projects/columns#update-an-existing-project-column",
				},
			],
		},
		pulls: {
			checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			create: ["POST /repos/{owner}/{repo}/pulls"],
			createReplyForReviewComment: [
				"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
			],
			createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			createReviewComment: [
				"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
			],
			deletePendingReview: [
				"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
			],
			deleteReviewComment: [
				"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
			],
			dismissReview: [
				"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
			],
			get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
			getReview: [
				"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
			],
			getReviewComment: [
				"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}",
			],
			list: ["GET /repos/{owner}/{repo}/pulls"],
			listCommentsForReview: [
				"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
			],
			listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
			listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
			listRequestedReviewers: [
				"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
			],
			listReviewComments: [
				"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
			],
			listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
			listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			removeRequestedReviewers: [
				"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
			],
			requestReviewers: [
				"POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
			],
			submitReview: [
				"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
			],
			update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
			updateBranch: [
				"PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
			],
			updateReview: [
				"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
			],
			updateReviewComment: [
				"PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
			],
		},
		rateLimit: { get: ["GET /rate_limit"] },
		reactions: {
			createForCommitComment: [
				"POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
			],
			createForIssue: [
				"POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
			],
			createForIssueComment: [
				"POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
			],
			createForPullRequestReviewComment: [
				"POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
			],
			createForRelease: [
				"POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
			],
			createForTeamDiscussionCommentInOrg: [
				"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
			],
			createForTeamDiscussionInOrg: [
				"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
			],
			deleteForCommitComment: [
				"DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
			],
			deleteForIssue: [
				"DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
			],
			deleteForIssueComment: [
				"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
			],
			deleteForPullRequestComment: [
				"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
			],
			deleteForRelease: [
				"DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}",
			],
			deleteForTeamDiscussion: [
				"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
			],
			deleteForTeamDiscussionComment: [
				"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
			],
			listForCommitComment: [
				"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
			],
			listForIssue: [
				"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
			],
			listForIssueComment: [
				"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
			],
			listForPullRequestReviewComment: [
				"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
			],
			listForRelease: [
				"GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
			],
			listForTeamDiscussionCommentInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
			],
			listForTeamDiscussionInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
			],
		},
		repos: {
			acceptInvitation: [
				"PATCH /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] },
			],
			acceptInvitationForAuthenticatedUser: [
				"PATCH /user/repository_invitations/{invitation_id}",
			],
			addAppAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" },
			],
			addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
			addStatusCheckContexts: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" },
			],
			addTeamAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" },
			],
			addUserAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" },
			],
			cancelPagesDeployment: [
				"POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel",
			],
			checkAutomatedSecurityFixes: [
				"GET /repos/{owner}/{repo}/automated-security-fixes",
			],
			checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
			checkPrivateVulnerabilityReporting: [
				"GET /repos/{owner}/{repo}/private-vulnerability-reporting",
			],
			checkVulnerabilityAlerts: [
				"GET /repos/{owner}/{repo}/vulnerability-alerts",
			],
			codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
			compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
			compareCommitsWithBasehead: [
				"GET /repos/{owner}/{repo}/compare/{basehead}",
			],
			createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
			createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
			createCommitComment: [
				"POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
			],
			createCommitSignatureProtection: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
			],
			createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
			createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
			createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
			createDeploymentBranchPolicy: [
				"POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
			],
			createDeploymentProtectionRule: [
				"POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules",
			],
			createDeploymentStatus: [
				"POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
			],
			createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
			createForAuthenticatedUser: ["POST /user/repos"],
			createFork: ["POST /repos/{owner}/{repo}/forks"],
			createInOrg: ["POST /orgs/{org}/repos"],
			createOrUpdateCustomPropertiesValues: [
				"PATCH /repos/{owner}/{repo}/properties/values",
			],
			createOrUpdateEnvironment: [
				"PUT /repos/{owner}/{repo}/environments/{environment_name}",
			],
			createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
			createOrgRuleset: ["POST /orgs/{org}/rulesets"],
			createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
			createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
			createRelease: ["POST /repos/{owner}/{repo}/releases"],
			createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
			createUsingTemplate: [
				"POST /repos/{template_owner}/{template_repo}/generate",
			],
			createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
			declineInvitation: [
				"DELETE /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] },
			],
			declineInvitationForAuthenticatedUser: [
				"DELETE /user/repository_invitations/{invitation_id}",
			],
			delete: ["DELETE /repos/{owner}/{repo}"],
			deleteAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
			],
			deleteAdminBranchProtection: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
			],
			deleteAnEnvironment: [
				"DELETE /repos/{owner}/{repo}/environments/{environment_name}",
			],
			deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			deleteBranchProtection: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
			],
			deleteCommitComment: [
				"DELETE /repos/{owner}/{repo}/comments/{comment_id}",
			],
			deleteCommitSignatureProtection: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
			],
			deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
			deleteDeployment: [
				"DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
			],
			deleteDeploymentBranchPolicy: [
				"DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
			],
			deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
			deleteInvitation: [
				"DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
			],
			deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
			deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
			deletePullRequestReviewProtection: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
			],
			deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
			deleteReleaseAsset: [
				"DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
			],
			deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
			disableAutomatedSecurityFixes: [
				"DELETE /repos/{owner}/{repo}/automated-security-fixes",
			],
			disableDeploymentProtectionRule: [
				"DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}",
			],
			disablePrivateVulnerabilityReporting: [
				"DELETE /repos/{owner}/{repo}/private-vulnerability-reporting",
			],
			disableVulnerabilityAlerts: [
				"DELETE /repos/{owner}/{repo}/vulnerability-alerts",
			],
			downloadArchive: [
				"GET /repos/{owner}/{repo}/zipball/{ref}",
				{},
				{ renamed: ["repos", "downloadZipballArchive"] },
			],
			downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
			downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
			enableAutomatedSecurityFixes: [
				"PUT /repos/{owner}/{repo}/automated-security-fixes",
			],
			enablePrivateVulnerabilityReporting: [
				"PUT /repos/{owner}/{repo}/private-vulnerability-reporting",
			],
			enableVulnerabilityAlerts: [
				"PUT /repos/{owner}/{repo}/vulnerability-alerts",
			],
			generateReleaseNotes: [
				"POST /repos/{owner}/{repo}/releases/generate-notes",
			],
			get: ["GET /repos/{owner}/{repo}"],
			getAccessRestrictions: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
			],
			getAdminBranchProtection: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
			],
			getAllDeploymentProtectionRules: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules",
			],
			getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
			getAllStatusCheckContexts: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
			],
			getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
			getAppsWithAccessToProtectedBranch: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
			],
			getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
			getBranchProtection: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection",
			],
			getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
			getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
			getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
			getCollaboratorPermissionLevel: [
				"GET /repos/{owner}/{repo}/collaborators/{username}/permission",
			],
			getCombinedStatusForRef: [
				"GET /repos/{owner}/{repo}/commits/{ref}/status",
			],
			getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
			getCommitActivityStats: [
				"GET /repos/{owner}/{repo}/stats/commit_activity",
			],
			getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
			getCommitSignatureProtection: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
			],
			getCommunityProfileMetrics: [
				"GET /repos/{owner}/{repo}/community/profile",
			],
			getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
			getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
			getCustomDeploymentProtectionRule: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}",
			],
			getCustomPropertiesValues: [
				"GET /repos/{owner}/{repo}/properties/values",
			],
			getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
			getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
			getDeploymentBranchPolicy: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
			],
			getDeploymentStatus: [
				"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
			],
			getEnvironment: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}",
			],
			getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
			getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
			getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
			getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
			getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
			getOrgRulesets: ["GET /orgs/{org}/rulesets"],
			getPages: ["GET /repos/{owner}/{repo}/pages"],
			getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
			getPagesDeployment: [
				"GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}",
			],
			getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
			getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
			getPullRequestReviewProtection: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
			],
			getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
			getReadme: ["GET /repos/{owner}/{repo}/readme"],
			getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
			getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
			getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
			getRepoRuleSuite: [
				"GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}",
			],
			getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
			getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			getRepoRulesetHistory: [
				"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history",
			],
			getRepoRulesetVersion: [
				"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}",
			],
			getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
			getStatusChecksProtection: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
			],
			getTeamsWithAccessToProtectedBranch: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
			],
			getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
			getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
			getUsersWithAccessToProtectedBranch: [
				"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
			],
			getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
			getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
			getWebhookConfigForRepo: [
				"GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
			],
			getWebhookDelivery: [
				"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
			],
			listActivities: ["GET /repos/{owner}/{repo}/activity"],
			listAttestations: [
				"GET /repos/{owner}/{repo}/attestations/{subject_digest}",
			],
			listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
			listBranches: ["GET /repos/{owner}/{repo}/branches"],
			listBranchesForHeadCommit: [
				"GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
			],
			listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
			listCommentsForCommit: [
				"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
			],
			listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
			listCommitStatusesForRef: [
				"GET /repos/{owner}/{repo}/commits/{ref}/statuses",
			],
			listCommits: ["GET /repos/{owner}/{repo}/commits"],
			listContributors: ["GET /repos/{owner}/{repo}/contributors"],
			listCustomDeploymentRuleIntegrations: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
			],
			listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
			listDeploymentBranchPolicies: [
				"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
			],
			listDeploymentStatuses: [
				"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
			],
			listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
			listForAuthenticatedUser: ["GET /user/repos"],
			listForOrg: ["GET /orgs/{org}/repos"],
			listForUser: ["GET /users/{username}/repos"],
			listForks: ["GET /repos/{owner}/{repo}/forks"],
			listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
			listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
			listLanguages: ["GET /repos/{owner}/{repo}/languages"],
			listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
			listPublic: ["GET /repositories"],
			listPullRequestsAssociatedWithCommit: [
				"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
			],
			listReleaseAssets: [
				"GET /repos/{owner}/{repo}/releases/{release_id}/assets",
			],
			listReleases: ["GET /repos/{owner}/{repo}/releases"],
			listTags: ["GET /repos/{owner}/{repo}/tags"],
			listTeams: ["GET /repos/{owner}/{repo}/teams"],
			listWebhookDeliveries: [
				"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
			],
			listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
			merge: ["POST /repos/{owner}/{repo}/merges"],
			mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
			pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: [
				"POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
			],
			removeAppAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" },
			],
			removeCollaborator: [
				"DELETE /repos/{owner}/{repo}/collaborators/{username}",
			],
			removeStatusCheckContexts: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" },
			],
			removeStatusCheckProtection: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
			],
			removeTeamAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" },
			],
			removeUserAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" },
			],
			renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
			replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
			requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
			setAdminBranchProtection: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
			],
			setAppAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" },
			],
			setStatusCheckContexts: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" },
			],
			setTeamAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" },
			],
			setUserAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" },
			],
			testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
			transfer: ["POST /repos/{owner}/{repo}/transfer"],
			update: ["PATCH /repos/{owner}/{repo}"],
			updateBranchProtection: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection",
			],
			updateCommitComment: [
				"PATCH /repos/{owner}/{repo}/comments/{comment_id}",
			],
			updateDeploymentBranchPolicy: [
				"PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
			],
			updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
			updateInvitation: [
				"PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
			],
			updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
			updatePullRequestReviewProtection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
			],
			updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
			updateReleaseAsset: [
				"PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
			],
			updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			updateStatusCheckPotection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
				{},
				{ renamed: ["repos", "updateStatusCheckProtection"] },
			],
			updateStatusCheckProtection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
			],
			updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
			updateWebhookConfigForRepo: [
				"PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
			],
			uploadReleaseAsset: [
				"POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
				{ baseUrl: "https://uploads.github.com" },
			],
		},
		search: {
			code: ["GET /search/code"],
			commits: ["GET /search/commits"],
			issuesAndPullRequests: [
				"GET /search/issues",
				{},
				{
					deprecated:
						"octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests",
				},
			],
			labels: ["GET /search/labels"],
			repos: ["GET /search/repositories"],
			topics: ["GET /search/topics"],
			users: ["GET /search/users"],
		},
		secretScanning: {
			createPushProtectionBypass: [
				"POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses",
			],
			getAlert: [
				"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
			],
			getScanHistory: [
				"GET /repos/{owner}/{repo}/secret-scanning/scan-history",
			],
			listAlertsForEnterprise: [
				"GET /enterprises/{enterprise}/secret-scanning/alerts",
			],
			listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
			listLocationsForAlert: [
				"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
			],
			updateAlert: [
				"PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
			],
		},
		securityAdvisories: {
			createFork: [
				"POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks",
			],
			createPrivateVulnerabilityReport: [
				"POST /repos/{owner}/{repo}/security-advisories/reports",
			],
			createRepositoryAdvisory: [
				"POST /repos/{owner}/{repo}/security-advisories",
			],
			createRepositoryAdvisoryCveRequest: [
				"POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve",
			],
			getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
			getRepositoryAdvisory: [
				"GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}",
			],
			listGlobalAdvisories: ["GET /advisories"],
			listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
			listRepositoryAdvisories: [
				"GET /repos/{owner}/{repo}/security-advisories",
			],
			updateRepositoryAdvisory: [
				"PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}",
			],
		},
		teams: {
			addOrUpdateMembershipForUserInOrg: [
				"PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
			],
			addOrUpdateProjectPermissionsInOrg: [
				"PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.addOrUpdateProjectPermissionsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions",
				},
			],
			addOrUpdateProjectPermissionsLegacy: [
				"PUT /teams/{team_id}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.addOrUpdateProjectPermissionsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions-legacy",
				},
			],
			addOrUpdateRepoPermissionsInOrg: [
				"PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
			],
			checkPermissionsForProjectInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.checkPermissionsForProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project",
				},
			],
			checkPermissionsForProjectLegacy: [
				"GET /teams/{team_id}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.checkPermissionsForProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project-legacy",
				},
			],
			checkPermissionsForRepoInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
			],
			create: ["POST /orgs/{org}/teams"],
			createDiscussionCommentInOrg: [
				"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
			],
			createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
			deleteDiscussionCommentInOrg: [
				"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
			],
			deleteDiscussionInOrg: [
				"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
			],
			deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
			getByName: ["GET /orgs/{org}/teams/{team_slug}"],
			getDiscussionCommentInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
			],
			getDiscussionInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
			],
			getMembershipForUserInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
			],
			list: ["GET /orgs/{org}/teams"],
			listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
			listDiscussionCommentsInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
			],
			listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
			listForAuthenticatedUser: ["GET /user/teams"],
			listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
			listPendingInvitationsInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/invitations",
			],
			listProjectsInOrg: [
				"GET /orgs/{org}/teams/{team_slug}/projects",
				{},
				{
					deprecated:
						"octokit.rest.teams.listProjectsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects",
				},
			],
			listProjectsLegacy: [
				"GET /teams/{team_id}/projects",
				{},
				{
					deprecated:
						"octokit.rest.teams.listProjectsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects-legacy",
				},
			],
			listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
			removeMembershipForUserInOrg: [
				"DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
			],
			removeProjectInOrg: [
				"DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.removeProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team",
				},
			],
			removeProjectLegacy: [
				"DELETE /teams/{team_id}/projects/{project_id}",
				{},
				{
					deprecated:
						"octokit.rest.teams.removeProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team-legacy",
				},
			],
			removeRepoInOrg: [
				"DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
			],
			updateDiscussionCommentInOrg: [
				"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
			],
			updateDiscussionInOrg: [
				"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
			],
			updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
		},
		users: {
			addEmailForAuthenticated: [
				"POST /user/emails",
				{},
				{ renamed: ["users", "addEmailForAuthenticatedUser"] },
			],
			addEmailForAuthenticatedUser: ["POST /user/emails"],
			addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
			block: ["PUT /user/blocks/{username}"],
			checkBlocked: ["GET /user/blocks/{username}"],
			checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
			checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
			createGpgKeyForAuthenticated: [
				"POST /user/gpg_keys",
				{},
				{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] },
			],
			createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
			createPublicSshKeyForAuthenticated: [
				"POST /user/keys",
				{},
				{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] },
			],
			createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
			createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
			deleteEmailForAuthenticated: [
				"DELETE /user/emails",
				{},
				{ renamed: ["users", "deleteEmailForAuthenticatedUser"] },
			],
			deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
			deleteGpgKeyForAuthenticated: [
				"DELETE /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] },
			],
			deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
			deletePublicSshKeyForAuthenticated: [
				"DELETE /user/keys/{key_id}",
				{},
				{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] },
			],
			deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
			deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
			deleteSshSigningKeyForAuthenticatedUser: [
				"DELETE /user/ssh_signing_keys/{ssh_signing_key_id}",
			],
			follow: ["PUT /user/following/{username}"],
			getAuthenticated: ["GET /user"],
			getById: ["GET /user/{account_id}"],
			getByUsername: ["GET /users/{username}"],
			getContextForUser: ["GET /users/{username}/hovercard"],
			getGpgKeyForAuthenticated: [
				"GET /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] },
			],
			getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
			getPublicSshKeyForAuthenticated: [
				"GET /user/keys/{key_id}",
				{},
				{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] },
			],
			getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
			getSshSigningKeyForAuthenticatedUser: [
				"GET /user/ssh_signing_keys/{ssh_signing_key_id}",
			],
			list: ["GET /users"],
			listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
			listBlockedByAuthenticated: [
				"GET /user/blocks",
				{},
				{ renamed: ["users", "listBlockedByAuthenticatedUser"] },
			],
			listBlockedByAuthenticatedUser: ["GET /user/blocks"],
			listEmailsForAuthenticated: [
				"GET /user/emails",
				{},
				{ renamed: ["users", "listEmailsForAuthenticatedUser"] },
			],
			listEmailsForAuthenticatedUser: ["GET /user/emails"],
			listFollowedByAuthenticated: [
				"GET /user/following",
				{},
				{ renamed: ["users", "listFollowedByAuthenticatedUser"] },
			],
			listFollowedByAuthenticatedUser: ["GET /user/following"],
			listFollowersForAuthenticatedUser: ["GET /user/followers"],
			listFollowersForUser: ["GET /users/{username}/followers"],
			listFollowingForUser: ["GET /users/{username}/following"],
			listGpgKeysForAuthenticated: [
				"GET /user/gpg_keys",
				{},
				{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] },
			],
			listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
			listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
			listPublicEmailsForAuthenticated: [
				"GET /user/public_emails",
				{},
				{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] },
			],
			listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
			listPublicKeysForUser: ["GET /users/{username}/keys"],
			listPublicSshKeysForAuthenticated: [
				"GET /user/keys",
				{},
				{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] },
			],
			listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
			listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
			listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
			listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
			listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
			setPrimaryEmailVisibilityForAuthenticated: [
				"PATCH /user/email/visibility",
				{},
				{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
			],
			setPrimaryEmailVisibilityForAuthenticatedUser: [
				"PATCH /user/email/visibility",
			],
			unblock: ["DELETE /user/blocks/{username}"],
			unfollow: ["DELETE /user/following/{username}"],
			updateAuthenticated: ["PATCH /user"],
		},
	},
	endpoints_default = Endpoints;
var endpointMethodsMap = new Map();
for (let [scope, endpoints] of Object.entries(endpoints_default))
	for (let [methodName, endpoint2] of Object.entries(endpoints)) {
		let [route, defaults, decorations] = endpoint2,
			[method, url] = route.split(/ /),
			endpointDefaults = Object.assign({ method, url }, defaults);
		if (!endpointMethodsMap.has(scope))
			endpointMethodsMap.set(scope, new Map());
		endpointMethodsMap
			.get(scope)
			.set(methodName, { scope, methodName, endpointDefaults, decorations });
	}
var handler = {
	has({ scope }, methodName) {
		return endpointMethodsMap.get(scope).has(methodName);
	},
	getOwnPropertyDescriptor(target, methodName) {
		return {
			value: this.get(target, methodName),
			configurable: !0,
			writable: !0,
			enumerable: !0,
		};
	},
	defineProperty(target, methodName, descriptor) {
		return Object.defineProperty(target.cache, methodName, descriptor), !0;
	},
	deleteProperty(target, methodName) {
		return delete target.cache[methodName], !0;
	},
	ownKeys({ scope }) {
		return [...endpointMethodsMap.get(scope).keys()];
	},
	set(target, methodName, value) {
		return (target.cache[methodName] = value);
	},
	get({ octokit, scope, cache }, methodName) {
		if (cache[methodName]) return cache[methodName];
		let method = endpointMethodsMap.get(scope).get(methodName);
		if (!method) return;
		let { endpointDefaults, decorations } = method;
		if (decorations)
			cache[methodName] = decorate(
				octokit,
				scope,
				methodName,
				endpointDefaults,
				decorations,
			);
		else cache[methodName] = octokit.request.defaults(endpointDefaults);
		return cache[methodName];
	},
};
function endpointsToMethods(octokit) {
	let newMethods = {};
	for (let scope of endpointMethodsMap.keys())
		newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
	return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
	let requestWithDefaults = octokit.request.defaults(defaults);
	function withDecorations(...args) {
		let options = requestWithDefaults.endpoint.merge(...args);
		if (decorations.mapToData)
			return (
				(options = Object.assign({}, options, {
					data: options[decorations.mapToData],
					[decorations.mapToData]: void 0,
				})),
				requestWithDefaults(options)
			);
		if (decorations.renamed) {
			let [newScope, newMethodName] = decorations.renamed;
			octokit.log.warn(
				`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`,
			);
		}
		if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
		if (decorations.renamedParameters) {
			let options2 = requestWithDefaults.endpoint.merge(...args);
			for (let [name17, alias] of Object.entries(decorations.renamedParameters))
				if (name17 in options2) {
					if (
						(octokit.log.warn(
							`"${name17}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`,
						),
						!(alias in options2))
					)
						options2[alias] = options2[name17];
					delete options2[name17];
				}
			return requestWithDefaults(options2);
		}
		return requestWithDefaults(...args);
	}
	return Object.assign(withDecorations, requestWithDefaults);
}
function restEndpointMethods(octokit) {
	return { rest: endpointsToMethods(octokit) };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit) {
	let api = endpointsToMethods(octokit);
	return { ...api, rest: api };
}
legacyRestEndpointMethods.VERSION = VERSION7;
var VERSION8 = "21.1.1";
var Octokit2 = Octokit.plugin(
	requestLog,
	legacyRestEndpointMethods,
	paginateRest,
).defaults({ userAgent: `octokit-rest.js/${VERSION8}` });
var octokit = new Octokit2({ auth: process.env.GITHUB_TOKEN });
var reviewPrPrompt = (filename, diff) => `
You are an advanced AI code reviewer. Your task is to analyze the following Git diff and provide a constructive and detailed code review.  

### Review Guidelines:
- **Analysis**: Identify potential issues such as bugs, performance bottlenecks, or security risks.  
- **Summary**: Provide a concise explanation of the overall impact of these changes.  
- **Suggested Changes**: Offer clear, actionable recommendations for improvement using GitHub Markdown formatting.  

---

**File:** \`${filename}\`  
### Changes:
\`\`\`diff
${diff}
\`\`\`

## Review:
### \uD83D\uDD0D Summary:
Provide a brief summary of what this change does and its impact.  

### ⚠️ Issues Identified:
List potential issues and concerns, such as code quality, best practices, or security risks.  

### ✅ Suggested Changes:
Provide suggestions in a GitHub-friendly format, including inline code snippets for clarity.  
Use:  
\`\`\`suggestion
// Example improvement here
\`\`\`  
`;
var isCacheEnable = async () => {
		return !!(await flagsmith_default.getEnvironmentFlags()).getFeatureValue(
			"enable_cache",
		);
	},
	v1_default = new Elysia().post(
		"/review",
		async function* ({ body: { owner, repo, pull } }) {
			if (await isCacheEnable()) {
				let results = db_default
					.query(
						"SELECT filename, comment FROM pr_comments WHERE owner = $owner AND repo = $repo AND pull = $pull",
					)
					.all({ $owner: owner, $repo: repo, $pull: pull });
				if (results.length > 0) {
					for (let { filename, comment, meta } of results)
						yield { filename, comment, meta: JSON.parse(meta ?? "{}") };
					return;
				}
			}
			let ghPrInfoRes = await Bun.fetch(
				`https://api.github.com/repos/${owner}/${repo}/pulls/${pull}`,
			);
			if (!ghPrInfoRes.ok)
				throw error(400, { message: "Pull request not found" });
			let ghPrInfo = await ghPrInfoRes.json(),
				{ data: files } = await octokit.pulls.listFiles({
					owner,
					repo,
					pull_number: Number(pull),
				});
			for (let file2 of files) {
				if (!file2.patch) continue;
				let prompt = reviewPrPrompt(file2.filename, file2.patch),
					{ text: text2 } = await generateText2({ prompt }),
					commentData = {
						filename: file2.filename,
						comment: text2,
						meta: {
							body: ghPrInfo.body,
							title: ghPrInfo.title,
							author: ghPrInfo.user.login,
						},
					};
				if (await isCacheEnable())
					db_default
						.query(
							"INSERT INTO pr_comments (owner, repo, pull, filename, comment, meta) VALUES ($owner, $repo, $pull, $filename, $comment, $meta)",
						)
						.run({
							$owner: owner,
							$repo: repo,
							$pull: pull,
							$filename: file2.filename,
							$comment: text2,
							$meta: JSON.stringify(commentData.meta),
						});
				yield commentData;
			}
		},
		{
			body: t.Object({ owner: t.String(), repo: t.String(), pull: t.Number() }),
		},
	);
var v2_default = new Elysia().all("/*", () => {
	throw error(400, { message: "Not Implemented" });
});
var v2Router = new Elysia({ prefix: "/v2" })
		.use(v2_default)
		.all("/", () => ({ version: 2 })),
	v1Router = new Elysia({ prefix: "/v1" })
		.use(v1_default)
		.all("/", () => ({ version: 1 }));
var routes_default = new Proxy(
	{ v1: v1_default, v2: v2_default },
	{
		get(target, prop) {
			return prop in target ? target[prop] : v1_default;
		},
	},
);
var STORE = { visitors: 0 },
	store_default = new Elysia().state(STORE);
var PORT = 0,
	DEFAULT_API_VERSION = (
		await flagsmith_default.getEnvironmentFlags()
	).getFeatureValue("default_api_version"),
	app = new Elysia()
		.use(store_default)
		.use(v1Router)
		.use(v2Router)
		.onError(({ code }) => {
			if (code === "NOT_FOUND") return { message: "Route not found" };
		})
		.onRequest(async ({ store, set: set3 }) => {
			if (
				((store.visitors = store.visitors + 1),
				(await flagsmith_default.getEnvironmentFlags()).getFeatureValue(
					"enable_http_cache",
				))
			)
				set3.headers["Cache-Control"] = "max-age=3600";
		})
		.get("/", ({ store }) => store)
		.get("/flagsmith", async () =>
			JSON.parse(JSON.stringify(await flagsmith_default.getEnvironmentFlags())),
		)
		.get("/test", async () => {
			let { text: text2 } = await generateText2({ prompt: "hi" });
			return { text: text2 };
		})
		.use(routes_default[DEFAULT_API_VERSION])
		.listen(PORT),
	src_default = app;
export { src_default as default };
